{
  "statistics": {
    "detectionDate": "2021-04-03T10:37:18.423Z",
    "formats": {
      "tcl": {
        "sources": {
          "/home/hata6502/sqlite/ext/rtree/util/randomshape.tcl": {
            "lines": 86,
            "tokens": 1015,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 10,
            "duplicatedTokens": 196,
            "percentage": 11.63,
            "percentageTokens": 19.31,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/repair/test/test.tcl": {
            "lines": 66,
            "tokens": 381,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/tool/mklsm1c.tcl": {
            "lines": 87,
            "tokens": 594,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/test/lsm1_common.tcl": {
            "lines": 37,
            "tokens": 223,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/tool/showfts5.tcl": {
            "lines": 88,
            "tokens": 619,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/tool/mkfts5c.tcl": {
            "lines": 112,
            "tokens": 859,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/tool/loadfts5.tcl": {
            "lines": 166,
            "tokens": 1453,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/tool/fts5txt2db.tcl": {
            "lines": 227,
            "tokens": 2168,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/tool/fts5speed.tcl": {
            "lines": 59,
            "tokens": 466,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/test/fts5_common.tcl": {
            "lines": 645,
            "tokens": 5412,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 22,
            "duplicatedTokens": 226,
            "percentage": 3.41,
            "percentageTokens": 4.18,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/unicode/parseunicode.tcl": {
            "lines": 201,
            "tokens": 1394,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 114,
            "duplicatedTokens": 722,
            "percentage": 56.72,
            "percentageTokens": 51.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/unicode/mkunicode.tcl": {
            "lines": 982,
            "tokens": 9197,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/session/session_common.tcl": {
            "lines": 213,
            "tokens": 1908,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 52,
            "duplicatedTokens": 551,
            "percentage": 24.41,
            "percentageTokens": 28.88,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rtree/viewrtree.tcl": {
            "lines": 186,
            "tokens": 2129,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rtree/rtree_util.tcl": {
            "lines": 195,
            "tokens": 1707,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rtree/rtree_perf.tcl": {
            "lines": 72,
            "tokens": 713,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/repair/sqlite3_checker.tcl": {
            "lines": 263,
            "tokens": 2142,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 52,
            "duplicatedTokens": 424,
            "percentage": 19.77,
            "percentageTokens": 19.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rbu/rbu_common.tcl": {
            "lines": 108,
            "tokens": 987,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/mkportersteps.tcl": {
            "lines": 218,
            "tokens": 1950,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/extract_api_docs.tcl": {
            "lines": 246,
            "tokens": 1814,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/mkfts3amal.tcl": {
            "lines": 114,
            "tokens": 819,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 150,
            "duplicatedTokens": 1287,
            "percentage": 131.58,
            "percentageTokens": 157.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3speed.tcl": {
            "lines": 118,
            "tokens": 865,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/mkfts2amal.tcl": {
            "lines": 115,
            "tokens": 822,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 74,
            "duplicatedTokens": 708,
            "percentage": 64.35,
            "percentageTokens": 86.13,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/vsixtest.tcl": {
            "lines": 372,
            "tokens": 2587,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 65,
            "duplicatedTokens": 433,
            "percentage": 17.47,
            "percentageTokens": 16.74,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/vdbe_profile.tcl": {
            "lines": 89,
            "tokens": 920,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/vdbe-compress.tcl": {
            "lines": 142,
            "tokens": 890,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/stack_usage.tcl": {
            "lines": 97,
            "tokens": 972,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/sqltclsh.tcl": {
            "lines": 70,
            "tokens": 602,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 17,
            "duplicatedTokens": 152,
            "percentage": 24.29,
            "percentageTokens": 25.25,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/split-sqlite3c.tcl": {
            "lines": 83,
            "tokens": 591,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/speedtest2.tcl": {
            "lines": 206,
            "tokens": 1873,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 260,
            "duplicatedTokens": 2304,
            "percentage": 126.21,
            "percentageTokens": 123.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/speedtest.tcl": {
            "lines": 274,
            "tokens": 2539,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 115,
            "duplicatedTokens": 1072,
            "percentage": 41.97,
            "percentageTokens": 42.22,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/spaceanal.tcl": {
            "lines": 893,
            "tokens": 8685,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 35,
            "duplicatedTokens": 272,
            "percentage": 3.92,
            "percentageTokens": 3.13,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/soak1.tcl": {
            "lines": 102,
            "tokens": 585,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/restore_jrnl.tcl": {
            "lines": 231,
            "tokens": 2000,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/replace.tcl": {
            "lines": 22,
            "tokens": 276,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/opcodesum.tcl": {
            "lines": 33,
            "tokens": 381,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/omittest.tcl": {
            "lines": 320,
            "tokens": 2201,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkvsix.tcl": {
            "lines": 839,
            "tokens": 5224,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 87,
            "duplicatedTokens": 645,
            "percentage": 10.37,
            "percentageTokens": 12.35,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mksqlite3internalh.tcl": {
            "lines": 147,
            "tokens": 856,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 72,
            "duplicatedTokens": 545,
            "percentage": 48.98,
            "percentageTokens": 63.67,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mksqlite3h.tcl": {
            "lines": 154,
            "tokens": 1256,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 137,
            "percentage": 9.09,
            "percentageTokens": 10.91,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mksqlite3c.tcl": {
            "lines": 452,
            "tokens": 3121,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 267,
            "duplicatedTokens": 2649,
            "percentage": 59.07,
            "percentageTokens": 84.88,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mksqlite3c-noext.tcl": {
            "lines": 366,
            "tokens": 2689,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 221,
            "duplicatedTokens": 2264,
            "percentage": 60.38,
            "percentageTokens": 84.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkspeedsql.tcl": {
            "lines": 236,
            "tokens": 1643,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 277,
            "percentage": 11.44,
            "percentageTokens": 16.86,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkshellc.tcl": {
            "lines": 71,
            "tokens": 761,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkpragmatab.tcl": {
            "lines": 618,
            "tokens": 4345,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 16,
            "duplicatedTokens": 172,
            "percentage": 2.59,
            "percentageTokens": 3.96,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkopts.tcl": {
            "lines": 50,
            "tokens": 417,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkopcodeh.tcl": {
            "lines": 319,
            "tokens": 2720,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkopcodec.tcl": {
            "lines": 49,
            "tokens": 361,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkmsvcmin.tcl": {
            "lines": 111,
            "tokens": 1001,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkctimec.tcl": {
            "lines": 308,
            "tokens": 1077,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkccode.tcl": {
            "lines": 92,
            "tokens": 589,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/fragck.tcl": {
            "lines": 148,
            "tokens": 909,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/extract-sqlite3h.tcl": {
            "lines": 20,
            "tokens": 181,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/cg_anno.tcl": {
            "lines": 78,
            "tokens": 922,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/windowerr.tcl": {
            "lines": 70,
            "tokens": 464,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/window8.tcl": {
            "lines": 422,
            "tokens": 5372,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/window7.tcl": {
            "lines": 89,
            "tokens": 1321,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/window4.tcl": {
            "lines": 422,
            "tokens": 4073,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/window3.tcl": {
            "lines": 361,
            "tokens": 5018,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 986,
            "percentage": 7.48,
            "percentageTokens": 19.65,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/window2.tcl": {
            "lines": 491,
            "tokens": 4844,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 27,
            "duplicatedTokens": 986,
            "percentage": 5.5,
            "percentageTokens": 20.36,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/wapptest.tcl": {
            "lines": 895,
            "tokens": 7630,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/wapp.tcl": {
            "lines": 986,
            "tokens": 8182,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 46,
            "duplicatedTokens": 570,
            "percentage": 4.67,
            "percentageTokens": 6.97,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/wal_common.tcl": {
            "lines": 90,
            "tokens": 740,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/upfrom1.tcl": {
            "lines": 113,
            "tokens": 1085,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/thread_common.tcl": {
            "lines": 108,
            "tokens": 721,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/show_speedtest1_rtree.tcl": {
            "lines": 56,
            "tokens": 498,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/releasetest_data.tcl": {
            "lines": 628,
            "tokens": 3859,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/randexpr1.tcl": {
            "lines": 341,
            "tokens": 3138,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 14,
            "duplicatedTokens": 142,
            "percentage": 4.11,
            "percentageTokens": 4.53,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/pg_common.tcl": {
            "lines": 173,
            "tokens": 1327,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/malloctraceviewer.tcl": {
            "lines": 250,
            "tokens": 2665,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/malloc_common.tcl": {
            "lines": 696,
            "tokens": 4967,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/make-where7.tcl": {
            "lines": 119,
            "tokens": 1136,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/lock_common.tcl": {
            "lines": 204,
            "tokens": 1711,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/fuzz_common.tcl": {
            "lines": 391,
            "tokens": 3209,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/fts3_common.tcl": {
            "lines": 418,
            "tokens": 3211,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 24,
            "duplicatedTokens": 304,
            "percentage": 5.74,
            "percentageTokens": 9.47,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/filter2.tcl": {
            "lines": 129,
            "tokens": 1495,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 10,
            "duplicatedTokens": 170,
            "percentage": 7.75,
            "percentageTokens": 11.37,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/boundary4.tcl": {
            "lines": 339,
            "tokens": 3782,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 171,
            "duplicatedTokens": 1597,
            "percentage": 50.44,
            "percentageTokens": 42.23,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/boundary3.tcl": {
            "lines": 288,
            "tokens": 1932,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 252,
            "duplicatedTokens": 1931,
            "percentage": 87.5,
            "percentageTokens": 99.95,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/boundary2.tcl": {
            "lines": 444,
            "tokens": 2914,
            "sources": 1,
            "clones": 18,
            "duplicatedLines": 321,
            "duplicatedTokens": 2523,
            "percentage": 72.3,
            "percentageTokens": 86.58,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/boundary1.tcl": {
            "lines": 288,
            "tokens": 1939,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 174,
            "duplicatedTokens": 1379,
            "percentage": 60.42,
            "percentageTokens": 71.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/bc_common.tcl": {
            "lines": 71,
            "tokens": 626,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/contrib/sqlitecon.tcl": {
            "lines": 678,
            "tokens": 6670,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 21156,
          "tokens": 177340,
          "sources": 82,
          "clones": 58,
          "duplicatedLines": 1368,
          "duplicatedTokens": 12812,
          "percentage": 6.47,
          "percentageTokens": 7.22,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "markdown": {
        "sources": {
          "/home/hata6502/sqlite/ext/repair/test/README.md": {
            "lines": 12,
            "tokens": 56,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/userauth/user-auth.txt": {
            "lines": 163,
            "tokens": 1455,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rtree/visual01.txt": {
            "lines": 599,
            "tokens": 4385,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/repair/README.md": {
            "lines": 15,
            "tokens": 284,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/README.md": {
            "lines": 57,
            "tokens": 379,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/icu/README.txt": {
            "lines": 168,
            "tokens": 543,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/README.txt": {
            "lines": 3,
            "tokens": 70,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/README.txt": {
            "lines": 3,
            "tokens": 70,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/expert/README.md": {
            "lines": 80,
            "tokens": 706,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/async/README.txt": {
            "lines": 169,
            "tokens": 1280,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/dbtotxt.md": {
            "lines": 55,
            "tokens": 519,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/optfuzz-db01.txt": {
            "lines": 133,
            "tokens": 481,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/in-operator.md": {
            "lines": 101,
            "tokens": 1310,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/README.md": {
            "lines": 5,
            "tokens": 65,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/doc/wal-lock.md": {
            "lines": 83,
            "tokens": 1128,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/doc/vfs-shm.txt": {
            "lines": 129,
            "tokens": 1235,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/doc/vdbesort-memory.md": {
            "lines": 47,
            "tokens": 686,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/doc/trusted-schema.md": {
            "lines": 137,
            "tokens": 1524,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/doc/pager-invariants.txt": {
            "lines": 75,
            "tokens": 570,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/doc/F2FS.txt": {
            "lines": 81,
            "tokens": 835,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/autoconf/README.txt": {
            "lines": 104,
            "tokens": 878,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/magic.txt": {
            "lines": 29,
            "tokens": 196,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/README.md": {
            "lines": 326,
            "tokens": 3788,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/LICENSE.md": {
            "lines": 5,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 2579,
          "tokens": 22539,
          "sources": 24,
          "clones": 0,
          "duplicatedLines": 0,
          "duplicatedTokens": 0,
          "percentage": 0,
          "percentageTokens": 0,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "c": {
        "sources": {
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_win32.c": {
            "lines": 19,
            "tokens": 182,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_util.c": {
            "lines": 213,
            "tokens": 2351,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_tdb4.c": {
            "lines": 978,
            "tokens": 8992,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_tdb.c": {
            "lines": 844,
            "tokens": 7339,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_mem.c": {
            "lines": 399,
            "tokens": 3436,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_io.c": {
            "lines": 246,
            "tokens": 1518,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_func.c": {
            "lines": 172,
            "tokens": 1512,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_datasource.c": {
            "lines": 91,
            "tokens": 794,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_bt.c": {
            "lines": 66,
            "tokens": 629,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest9.c": {
            "lines": 133,
            "tokens": 1069,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest8.c": {
            "lines": 322,
            "tokens": 2847,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 16,
            "duplicatedTokens": 164,
            "percentage": 4.97,
            "percentageTokens": 5.76,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest7.c": {
            "lines": 200,
            "tokens": 1827,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest6.c": {
            "lines": 657,
            "tokens": 5552,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 20,
            "duplicatedTokens": 178,
            "percentage": 3.04,
            "percentageTokens": 3.21,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest5.c": {
            "lines": 631,
            "tokens": 4171,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest4.c": {
            "lines": 125,
            "tokens": 863,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest3.c": {
            "lines": 235,
            "tokens": 1820,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest2.c": {
            "lines": 486,
            "tokens": 3506,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 60,
            "duplicatedTokens": 390,
            "percentage": 12.35,
            "percentageTokens": 11.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest1.c": {
            "lines": 649,
            "tokens": 5848,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 30,
            "duplicatedTokens": 366,
            "percentage": 4.62,
            "percentageTokens": 6.26,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/tool/fts3view.c": {
            "lines": 874,
            "tokens": 7078,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 9,
            "duplicatedTokens": 91,
            "percentage": 1.03,
            "percentageTokens": 1.29,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/autoconf/tea/win/nmakehlp.c": {
            "lines": 693,
            "tokens": 4542,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 220,
            "duplicatedTokens": 1440,
            "percentage": 31.75,
            "percentageTokens": 31.7,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/userauth/userauth.c": {
            "lines": 354,
            "tokens": 2351,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/session/session_speed_test.c": {
            "lines": 357,
            "tokens": 2809,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/session/changeset.c": {
            "lines": 416,
            "tokens": 3564,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 24,
            "duplicatedTokens": 214,
            "percentage": 5.77,
            "percentageTokens": 6,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/repair/checkindex.c": {
            "lines": 921,
            "tokens": 7258,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/repair/checkfreelist.c": {
            "lines": 293,
            "tokens": 1860,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rbu/test_rbu.c": {
            "lines": 390,
            "tokens": 3171,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 31,
            "duplicatedTokens": 363,
            "percentage": 7.95,
            "percentageTokens": 11.45,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rbu/rbu.c": {
            "lines": 194,
            "tokens": 1393,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/zorder.c": {
            "lines": 101,
            "tokens": 569,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/wholenumber.c": {
            "lines": 274,
            "tokens": 1604,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/vtshim.c": {
            "lines": 548,
            "tokens": 5045,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 114,
            "duplicatedTokens": 1192,
            "percentage": 20.8,
            "percentageTokens": 23.63,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/vtablog.c": {
            "lines": 509,
            "tokens": 3497,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 99,
            "duplicatedTokens": 887,
            "percentage": 19.45,
            "percentageTokens": 25.36,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/vfsstat.c": {
            "lines": 818,
            "tokens": 5472,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 80,
            "percentage": 1.34,
            "percentageTokens": 1.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/vfslog.c": {
            "lines": 758,
            "tokens": 6227,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 42,
            "duplicatedTokens": 468,
            "percentage": 5.54,
            "percentageTokens": 7.52,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/uuid.c": {
            "lines": 232,
            "tokens": 1325,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/urifuncs.c": {
            "lines": 208,
            "tokens": 1480,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 84,
            "duplicatedTokens": 992,
            "percentage": 40.38,
            "percentageTokens": 67.03,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/uint.c": {
            "lines": 91,
            "tokens": 582,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 7,
            "duplicatedTokens": 86,
            "percentage": 7.69,
            "percentageTokens": 14.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/totype.c": {
            "lines": 512,
            "tokens": 3488,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 18,
            "duplicatedTokens": 174,
            "percentage": 3.52,
            "percentageTokens": 4.99,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/templatevtab.c": {
            "lines": 267,
            "tokens": 1113,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/stmt.c": {
            "lines": 299,
            "tokens": 1421,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 6,
            "duplicatedTokens": 79,
            "percentage": 2.01,
            "percentageTokens": 5.56,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/sqlar.c": {
            "lines": 123,
            "tokens": 674,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/showauth.c": {
            "lines": 102,
            "tokens": 873,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/shathree.c": {
            "lines": 719,
            "tokens": 7357,
            "sources": 1,
            "clones": 16,
            "duplicatedLines": 308,
            "duplicatedTokens": 2542,
            "percentage": 42.84,
            "percentageTokens": 34.55,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/sha1.c": {
            "lines": 384,
            "tokens": 4190,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 212,
            "duplicatedTokens": 4385,
            "percentage": 55.21,
            "percentageTokens": 104.65,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/series.c": {
            "lines": 444,
            "tokens": 2248,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/scrub.c": {
            "lines": 608,
            "tokens": 5323,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 27,
            "duplicatedTokens": 285,
            "percentage": 4.44,
            "percentageTokens": 5.35,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/rot13.c": {
            "lines": 114,
            "tokens": 765,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/remember.c": {
            "lines": 71,
            "tokens": 219,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/regexp.c": {
            "lines": 759,
            "tokens": 6654,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/prefixes.c": {
            "lines": 315,
            "tokens": 1718,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 6,
            "duplicatedTokens": 77,
            "percentage": 1.9,
            "percentageTokens": 4.48,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/percentile.c": {
            "lines": 219,
            "tokens": 1224,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/normalize.c": {
            "lines": 715,
            "tokens": 6330,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 309,
            "duplicatedTokens": 4017,
            "percentage": 43.22,
            "percentageTokens": 63.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/noop.c": {
            "lines": 67,
            "tokens": 334,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/nextchar.c": {
            "lines": 313,
            "tokens": 2440,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 35,
            "duplicatedTokens": 431,
            "percentage": 11.18,
            "percentageTokens": 17.66,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/mmapwarm.c": {
            "lines": 106,
            "tokens": 743,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/memvfs.c": {
            "lines": 573,
            "tokens": 3814,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 74,
            "percentage": 2.27,
            "percentageTokens": 1.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/memtrace.c": {
            "lines": 107,
            "tokens": 615,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 79,
            "duplicatedTokens": 605,
            "percentage": 73.83,
            "percentageTokens": 98.37,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/memstat.c": {
            "lines": 427,
            "tokens": 2780,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 98,
            "percentage": 3.04,
            "percentageTokens": 3.53,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/ieee754.c": {
            "lines": 288,
            "tokens": 1786,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 14,
            "duplicatedTokens": 200,
            "percentage": 4.86,
            "percentageTokens": 11.2,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/explain.c": {
            "lines": 321,
            "tokens": 1764,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 98,
            "percentage": 4.05,
            "percentageTokens": 5.56,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/eval.c": {
            "lines": 124,
            "tokens": 946,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/decimal.c": {
            "lines": 633,
            "tokens": 5432,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 57,
            "duplicatedTokens": 574,
            "percentage": 9,
            "percentageTokens": 10.57,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/dbdump.c": {
            "lines": 723,
            "tokens": 5483,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/dbdata.c": {
            "lines": 838,
            "tokens": 6013,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 21,
            "duplicatedTokens": 325,
            "percentage": 2.51,
            "percentageTokens": 5.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/csv.c": {
            "lines": 956,
            "tokens": 7012,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 41,
            "duplicatedTokens": 350,
            "percentage": 4.29,
            "percentageTokens": 4.99,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/compress.c": {
            "lines": 130,
            "tokens": 816,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/completion.c": {
            "lines": 500,
            "tokens": 3146,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 58,
            "duplicatedTokens": 597,
            "percentage": 11.6,
            "percentageTokens": 18.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/closure.c": {
            "lines": 964,
            "tokens": 5950,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/cksumvfs.c": {
            "lines": 864,
            "tokens": 5646,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 36,
            "duplicatedTokens": 268,
            "percentage": 4.17,
            "percentageTokens": 4.75,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/carray.c": {
            "lines": 520,
            "tokens": 3125,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 16,
            "duplicatedTokens": 157,
            "percentage": 3.08,
            "percentageTokens": 5.02,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/btreeinfo.c": {
            "lines": 428,
            "tokens": 2609,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/blobio.c": {
            "lines": 151,
            "tokens": 1114,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 58,
            "duplicatedTokens": 514,
            "percentage": 38.41,
            "percentageTokens": 46.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/appendvfs.c": {
            "lines": 668,
            "tokens": 4692,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 80,
            "percentage": 1.8,
            "percentageTokens": 1.71,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/anycollseq.c": {
            "lines": 57,
            "tokens": 266,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm_varint.c": {
            "lines": 194,
            "tokens": 1811,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm_unix.c": {
            "lines": 750,
            "tokens": 6058,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 34,
            "duplicatedTokens": 384,
            "percentage": 4.53,
            "percentageTokens": 6.34,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm_str.c": {
            "lines": 146,
            "tokens": 1037,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm_mutex.c": {
            "lines": 86,
            "tokens": 303,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm_mem.c": {
            "lines": 103,
            "tokens": 817,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/icu/icu.c": {
            "lines": 537,
            "tokens": 3239,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 20,
            "duplicatedTokens": 216,
            "percentage": 3.72,
            "percentageTokens": 6.67,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_vocab.c": {
            "lines": 782,
            "tokens": 5976,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 56,
            "duplicatedTokens": 370,
            "percentage": 7.16,
            "percentageTokens": 6.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_varint.c": {
            "lines": 343,
            "tokens": 2025,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_unicode2.c": {
            "lines": 776,
            "tokens": 17174,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 210,
            "duplicatedTokens": 3912,
            "percentage": 27.06,
            "percentageTokens": 22.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_test_tok.c": {
            "lines": 482,
            "tokens": 3116,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 100,
            "duplicatedTokens": 737,
            "percentage": 20.75,
            "percentageTokens": 23.65,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_test_mi.c": {
            "lines": 420,
            "tokens": 3242,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_hash.c": {
            "lines": 559,
            "tokens": 4540,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 12,
            "duplicatedTokens": 166,
            "percentage": 2.15,
            "percentageTokens": 3.66,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_config.c": {
            "lines": 959,
            "tokens": 7131,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 81,
            "percentage": 1.25,
            "percentageTokens": 1.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_buffer.c": {
            "lines": 402,
            "tokens": 3143,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5_aux.c": {
            "lines": 713,
            "tokens": 5992,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_unicode2.c": {
            "lines": 382,
            "tokens": 5687,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 210,
            "duplicatedTokens": 3912,
            "percentage": 54.97,
            "percentageTokens": 68.79,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_unicode.c": {
            "lines": 368,
            "tokens": 2699,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 59,
            "duplicatedTokens": 442,
            "percentage": 16.03,
            "percentageTokens": 16.38,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_tokenizer1.c": {
            "lines": 233,
            "tokens": 1441,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 240,
            "duplicatedTokens": 1638,
            "percentage": 103,
            "percentageTokens": 113.67,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_tokenizer.c": {
            "lines": 519,
            "tokens": 3870,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 88,
            "duplicatedTokens": 962,
            "percentage": 16.96,
            "percentageTokens": 24.86,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_tokenize_vtab.c": {
            "lines": 455,
            "tokens": 2845,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 56,
            "duplicatedTokens": 534,
            "percentage": 12.31,
            "percentageTokens": 18.77,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_test.c": {
            "lines": 622,
            "tokens": 4583,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_term.c": {
            "lines": 373,
            "tokens": 2522,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 46,
            "duplicatedTokens": 376,
            "percentage": 12.33,
            "percentageTokens": 14.91,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_porter.c": {
            "lines": 661,
            "tokens": 5035,
            "sources": 1,
            "clones": 19,
            "duplicatedLines": 1023,
            "duplicatedTokens": 8846,
            "percentage": 154.77,
            "percentageTokens": 175.69,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_icu.c": {
            "lines": 261,
            "tokens": 1675,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 209,
            "duplicatedTokens": 1511,
            "percentage": 80.08,
            "percentageTokens": 90.21,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_hash.c": {
            "lines": 382,
            "tokens": 2810,
            "sources": 1,
            "clones": 10,
            "duplicatedLines": 168,
            "duplicatedTokens": 1564,
            "percentage": 43.98,
            "percentageTokens": 55.66,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_aux.c": {
            "lines": 549,
            "tokens": 4149,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 46,
            "duplicatedTokens": 376,
            "percentage": 8.38,
            "percentageTokens": 9.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_tokenizer1.c": {
            "lines": 232,
            "tokens": 1402,
            "sources": 1,
            "clones": 11,
            "duplicatedLines": 243,
            "duplicatedTokens": 1611,
            "percentage": 104.74,
            "percentageTokens": 114.91,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_tokenizer.c": {
            "lines": 374,
            "tokens": 2249,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 77,
            "duplicatedTokens": 703,
            "percentage": 20.59,
            "percentageTokens": 31.26,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_porter.c": {
            "lines": 643,
            "tokens": 4948,
            "sources": 1,
            "clones": 13,
            "duplicatedLines": 542,
            "duplicatedTokens": 4132,
            "percentage": 84.29,
            "percentageTokens": 83.51,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_icu.c": {
            "lines": 259,
            "tokens": 1639,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 209,
            "duplicatedTokens": 1511,
            "percentage": 80.69,
            "percentageTokens": 92.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_hash.c": {
            "lines": 375,
            "tokens": 2760,
            "sources": 1,
            "clones": 18,
            "duplicatedLines": 326,
            "duplicatedTokens": 2883,
            "percentage": 86.93,
            "percentageTokens": 104.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/simple_tokenizer.c": {
            "lines": 173,
            "tokens": 1208,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fts1_tokenizer1.c": {
            "lines": 220,
            "tokens": 1332,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 141,
            "duplicatedTokens": 979,
            "percentage": 64.09,
            "percentageTokens": 73.5,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fts1_porter.c": {
            "lines": 642,
            "tokens": 4933,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 572,
            "duplicatedTokens": 4731,
            "percentage": 89.1,
            "percentageTokens": 95.91,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fts1_hash.c": {
            "lines": 368,
            "tokens": 2792,
            "sources": 1,
            "clones": 13,
            "duplicatedLines": 249,
            "duplicatedTokens": 2279,
            "percentage": 67.66,
            "percentageTokens": 81.63,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/ft_hash.c": {
            "lines": 403,
            "tokens": 3178,
            "sources": 1,
            "clones": 11,
            "duplicatedLines": 224,
            "duplicatedTokens": 2039,
            "percentage": 55.58,
            "percentageTokens": 64.16,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/expert/test_expert.c": {
            "lines": 217,
            "tokens": 1544,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/expert/expert.c": {
            "lines": 155,
            "tokens": 1431,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/varint.c": {
            "lines": 122,
            "tokens": 1267,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 21,
            "duplicatedTokens": 276,
            "percentage": 17.21,
            "percentageTokens": 21.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/srcck1.c": {
            "lines": 157,
            "tokens": 1150,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/speedtest8inst1.c": {
            "lines": 217,
            "tokens": 1601,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 9,
            "duplicatedTokens": 125,
            "percentage": 4.15,
            "percentageTokens": 7.81,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/speedtest8.c": {
            "lines": 259,
            "tokens": 1871,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 34,
            "duplicatedTokens": 420,
            "percentage": 13.13,
            "percentageTokens": 22.45,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/speedtest16.c": {
            "lines": 170,
            "tokens": 1223,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 25,
            "duplicatedTokens": 295,
            "percentage": 14.71,
            "percentageTokens": 24.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/showwal.c": {
            "lines": 607,
            "tokens": 5793,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 95,
            "duplicatedTokens": 1006,
            "percentage": 15.65,
            "percentageTokens": 17.37,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/showstat4.c": {
            "lines": 162,
            "tokens": 1607,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 163,
            "percentage": 11.11,
            "percentageTokens": 10.14,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/showshm.c": {
            "lines": 157,
            "tokens": 1347,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 48,
            "duplicatedTokens": 396,
            "percentage": 30.57,
            "percentageTokens": 29.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/showlocks.c": {
            "lines": 98,
            "tokens": 787,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/showjournal.c": {
            "lines": 137,
            "tokens": 1234,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 141,
            "percentage": 8.03,
            "percentageTokens": 11.43,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/rollback-test.c": {
            "lines": 154,
            "tokens": 1296,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/pagesig.c": {
            "lines": 91,
            "tokens": 646,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 22,
            "duplicatedTokens": 210,
            "percentage": 24.18,
            "percentageTokens": 32.51,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/offsets.c": {
            "lines": 328,
            "tokens": 2901,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 12,
            "duplicatedTokens": 192,
            "percentage": 3.66,
            "percentageTokens": 6.62,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mksourceid.c": {
            "lines": 823,
            "tokens": 9685,
            "sources": 1,
            "clones": 11,
            "duplicatedLines": 268,
            "duplicatedTokens": 3427,
            "percentage": 32.56,
            "percentageTokens": 35.38,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkkeywordhash.c": {
            "lines": 713,
            "tokens": 6620,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/max-limits.c": {
            "lines": 40,
            "tokens": 358,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/logest.c": {
            "lines": 169,
            "tokens": 1750,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/loadfts.c": {
            "lines": 241,
            "tokens": 1798,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/libvers.c": {
            "lines": 14,
            "tokens": 78,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/index_usage.c": {
            "lines": 232,
            "tokens": 1734,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 5,
            "duplicatedTokens": 74,
            "percentage": 2.16,
            "percentageTokens": 4.27,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/getlock.c": {
            "lines": 133,
            "tokens": 998,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/fast_vacuum.c": {
            "lines": 233,
            "tokens": 950,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/extract.c": {
            "lines": 45,
            "tokens": 316,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/enlargedb.c": {
            "lines": 67,
            "tokens": 668,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/dbtotxt.c": {
            "lines": 145,
            "tokens": 1287,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/dbhash.c": {
            "lines": 482,
            "tokens": 4948,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 99,
            "duplicatedTokens": 2136,
            "percentage": 20.54,
            "percentageTokens": 43.17,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/checkSpacing.c": {
            "lines": 83,
            "tokens": 687,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/wordcount.c": {
            "lines": 658,
            "tokens": 5487,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 75,
            "percentage": 1.82,
            "percentageTokens": 1.37,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/tt3_vacuum.c": {
            "lines": 89,
            "tokens": 590,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/tt3_stress.c": {
            "lines": 363,
            "tokens": 2949,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 8,
            "duplicatedTokens": 88,
            "percentage": 2.2,
            "percentageTokens": 2.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/tt3_shared.c": {
            "lines": 53,
            "tokens": 327,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/tt3_lookaside1.c": {
            "lines": 98,
            "tokens": 668,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 10,
            "duplicatedTokens": 172,
            "percentage": 10.2,
            "percentageTokens": 25.75,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/tt3_index.c": {
            "lines": 73,
            "tokens": 429,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 20,
            "duplicatedTokens": 242,
            "percentage": 27.4,
            "percentageTokens": 56.41,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/tt3_checkpoint.c": {
            "lines": 147,
            "tokens": 911,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/threadtest4.c": {
            "lines": 483,
            "tokens": 3867,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/threadtest2.c": {
            "lines": 132,
            "tokens": 850,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/threadtest1.c": {
            "lines": 288,
            "tokens": 2415,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/startup.c": {
            "lines": 627,
            "tokens": 3500,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 66,
            "duplicatedTokens": 668,
            "percentage": 10.53,
            "percentageTokens": 19.09,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/ossshell.c": {
            "lines": 99,
            "tokens": 633,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/ossfuzz.c": {
            "lines": 200,
            "tokens": 1242,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 12,
            "duplicatedTokens": 75,
            "percentage": 6,
            "percentageTokens": 6.04,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/optfuzz.c": {
            "lines": 308,
            "tokens": 2464,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/optfuzz-db01.c": {
            "lines": 946,
            "tokens": 51263,
            "sources": 1,
            "clones": 42,
            "duplicatedLines": 754,
            "duplicatedTokens": 41410,
            "percentage": 79.7,
            "percentageTokens": 80.78,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/dbfuzz2.c": {
            "lines": 402,
            "tokens": 2827,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 79,
            "duplicatedTokens": 605,
            "percentage": 19.65,
            "percentageTokens": 21.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/dbfuzz.c": {
            "lines": 753,
            "tokens": 5865,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 57,
            "duplicatedTokens": 568,
            "percentage": 7.57,
            "percentageTokens": 9.68,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/crashtest1.c": {
            "lines": 95,
            "tokens": 611,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/atrc.c": {
            "lines": 149,
            "tokens": 867,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/walker.c": {
            "lines": 246,
            "tokens": 1504,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vdbevtab.c": {
            "lines": 423,
            "tokens": 3140,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 7,
            "duplicatedTokens": 87,
            "percentage": 1.65,
            "percentageTokens": 2.77,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vdbetrace.c": {
            "lines": 193,
            "tokens": 1484,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vdbeblob.c": {
            "lines": 507,
            "tokens": 3578,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vacuum.c": {
            "lines": 403,
            "tokens": 2575,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/utf.c": {
            "lines": 486,
            "tokens": 3283,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 64,
            "duplicatedTokens": 417,
            "percentage": 13.17,
            "percentageTokens": 12.7,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/upsert.c": {
            "lines": 314,
            "tokens": 2475,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/treeview.c": {
            "lines": 774,
            "tokens": 6965,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/tokenize.c": {
            "lines": 855,
            "tokens": 8660,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 245,
            "duplicatedTokens": 2504,
            "percentage": 28.65,
            "percentageTokens": 28.91,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/threads.c": {
            "lines": 273,
            "tokens": 1659,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 26,
            "duplicatedTokens": 228,
            "percentage": 9.52,
            "percentageTokens": 13.74,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_wsd.c": {
            "lines": 81,
            "tokens": 552,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_window.c": {
            "lines": 347,
            "tokens": 2817,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 94,
            "duplicatedTokens": 813,
            "percentage": 27.09,
            "percentageTokens": 28.86,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_windirent.c": {
            "lines": 190,
            "tokens": 1183,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_vfstrace.c": {
            "lines": 891,
            "tokens": 7697,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_vdbecov.c": {
            "lines": 117,
            "tokens": 817,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_thread.c": {
            "lines": 633,
            "tokens": 3979,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 20,
            "duplicatedTokens": 266,
            "percentage": 3.16,
            "percentageTokens": 6.69,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_tclvar.c": {
            "lines": 561,
            "tokens": 3872,
            "sources": 1,
            "clones": 7,
            "duplicatedLines": 56,
            "duplicatedTokens": 604,
            "percentage": 9.98,
            "percentageTokens": 15.6,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_tclsh.c": {
            "lines": 204,
            "tokens": 1204,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_syscall.c": {
            "lines": 761,
            "tokens": 5547,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_superlock.c": {
            "lines": 361,
            "tokens": 2161,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_sqllog.c": {
            "lines": 555,
            "tokens": 3254,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_server.c": {
            "lines": 515,
            "tokens": 1692,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_schema.c": {
            "lines": 361,
            "tokens": 2140,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 26,
            "duplicatedTokens": 279,
            "percentage": 7.2,
            "percentageTokens": 13.04,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_rtree.c": {
            "lines": 510,
            "tokens": 3873,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 130,
            "duplicatedTokens": 1255,
            "percentage": 25.49,
            "percentageTokens": 32.4,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_pcache.c": {
            "lines": 466,
            "tokens": 3066,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 12,
            "duplicatedTokens": 184,
            "percentage": 2.58,
            "percentageTokens": 6,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_onefile.c": {
            "lines": 829,
            "tokens": 5835,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 18,
            "duplicatedTokens": 230,
            "percentage": 2.17,
            "percentageTokens": 3.94,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_mutex.c": {
            "lines": 509,
            "tokens": 3508,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 66,
            "duplicatedTokens": 539,
            "percentage": 12.97,
            "percentageTokens": 15.36,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_md5.c": {
            "lines": 448,
            "tokens": 4669,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 22,
            "duplicatedTokens": 146,
            "percentage": 4.91,
            "percentageTokens": 3.13,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_loadext.c": {
            "lines": 127,
            "tokens": 895,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_journal.c": {
            "lines": 866,
            "tokens": 5897,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_intarray.c": {
            "lines": 391,
            "tokens": 2315,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 10,
            "duplicatedTokens": 94,
            "percentage": 2.56,
            "percentageTokens": 4.06,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_init.c": {
            "lines": 294,
            "tokens": 2269,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 8,
            "duplicatedTokens": 78,
            "percentage": 2.72,
            "percentageTokens": 3.44,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_hexio.c": {
            "lines": 464,
            "tokens": 4266,
            "sources": 1,
            "clones": 8,
            "duplicatedLines": 86,
            "duplicatedTokens": 1609,
            "percentage": 18.53,
            "percentageTokens": 37.72,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_func.c": {
            "lines": 951,
            "tokens": 6798,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 103,
            "duplicatedTokens": 975,
            "percentage": 10.83,
            "percentageTokens": 14.34,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_fs.c": {
            "lines": 916,
            "tokens": 5783,
            "sources": 1,
            "clones": 3,
            "duplicatedLines": 33,
            "duplicatedTokens": 323,
            "percentage": 3.6,
            "percentageTokens": 5.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_devsym.c": {
            "lines": 522,
            "tokens": 3427,
            "sources": 1,
            "clones": 6,
            "duplicatedLines": 94,
            "duplicatedTokens": 626,
            "percentage": 18.01,
            "percentageTokens": 18.27,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_demovfs.c": {
            "lines": 688,
            "tokens": 3274,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_delete.c": {
            "lines": 155,
            "tokens": 1014,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_config.c": {
            "lines": 824,
            "tokens": 5493,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_btree.c": {
            "lines": 65,
            "tokens": 356,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_blob.c": {
            "lines": 329,
            "tokens": 2184,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 6,
            "duplicatedTokens": 74,
            "percentage": 1.82,
            "percentageTokens": 3.39,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_bestindex.c": {
            "lines": 619,
            "tokens": 4338,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 72,
            "duplicatedTokens": 559,
            "percentage": 11.63,
            "percentageTokens": 12.89,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_backup.c": {
            "lines": 156,
            "tokens": 1087,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_autoext.c": {
            "lines": 227,
            "tokens": 1146,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_async.c": {
            "lines": 247,
            "tokens": 1495,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test9.c": {
            "lines": 203,
            "tokens": 1265,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 8,
            "duplicatedTokens": 91,
            "percentage": 3.94,
            "percentageTokens": 7.19,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test7.c": {
            "lines": 716,
            "tokens": 5291,
            "sources": 1,
            "clones": 50,
            "duplicatedLines": 713,
            "duplicatedTokens": 6257,
            "percentage": 99.58,
            "percentageTokens": 118.26,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test5.c": {
            "lines": 219,
            "tokens": 1412,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 6,
            "duplicatedTokens": 75,
            "percentage": 2.74,
            "percentageTokens": 5.31,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test4.c": {
            "lines": 725,
            "tokens": 5491,
            "sources": 1,
            "clones": 44,
            "duplicatedLines": 594,
            "duplicatedTokens": 5223,
            "percentage": 81.93,
            "percentageTokens": 95.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test3.c": {
            "lines": 689,
            "tokens": 5002,
            "sources": 1,
            "clones": 9,
            "duplicatedLines": 121,
            "duplicatedTokens": 901,
            "percentage": 17.56,
            "percentageTokens": 18.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test2.c": {
            "lines": 751,
            "tokens": 5561,
            "sources": 1,
            "clones": 17,
            "duplicatedLines": 206,
            "duplicatedTokens": 1799,
            "percentage": 27.43,
            "percentageTokens": 32.35,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/table.c": {
            "lines": 197,
            "tokens": 1445,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/status.c": {
            "lines": 392,
            "tokens": 2744,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 22,
            "duplicatedTokens": 302,
            "percentage": 5.61,
            "percentageTokens": 11.01,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/rowset.c": {
            "lines": 500,
            "tokens": 2869,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/random.c": {
            "lines": 133,
            "tokens": 681,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/pcache.c": {
            "lines": 880,
            "tokens": 5377,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/os.c": {
            "lines": 432,
            "tokens": 2826,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/notify.c": {
            "lines": 329,
            "tokens": 1582,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mutex_w32.c": {
            "lines": 397,
            "tokens": 1749,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 95,
            "percentage": 3.53,
            "percentageTokens": 5.43,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mutex_unix.c": {
            "lines": 392,
            "tokens": 1532,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 14,
            "duplicatedTokens": 95,
            "percentage": 3.57,
            "percentageTokens": 6.2,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mutex_noop.c": {
            "lines": 214,
            "tokens": 1026,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mutex.c": {
            "lines": 360,
            "tokens": 1905,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/memjournal.c": {
            "lines": 431,
            "tokens": 2602,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/memdb.c": {
            "lines": 634,
            "tokens": 4594,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 13,
            "duplicatedTokens": 74,
            "percentage": 2.05,
            "percentageTokens": 1.61,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mem5.c": {
            "lines": 575,
            "tokens": 3299,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 11,
            "duplicatedTokens": 85,
            "percentage": 1.91,
            "percentageTokens": 2.58,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mem3.c": {
            "lines": 686,
            "tokens": 5046,
            "sources": 1,
            "clones": 5,
            "duplicatedLines": 33,
            "duplicatedTokens": 417,
            "percentage": 4.81,
            "percentageTokens": 8.26,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mem2.c": {
            "lines": 527,
            "tokens": 3532,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 12,
            "duplicatedTokens": 176,
            "percentage": 2.28,
            "percentageTokens": 4.98,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mem1.c": {
            "lines": 289,
            "tokens": 975,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mem0.c": {
            "lines": 58,
            "tokens": 224,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/malloc.c": {
            "lines": 827,
            "tokens": 5646,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/loadext.c": {
            "lines": 852,
            "tokens": 3693,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/legacy.c": {
            "lines": 140,
            "tokens": 992,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/hash.c": {
            "lines": 268,
            "tokens": 1883,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 23,
            "duplicatedTokens": 237,
            "percentage": 8.58,
            "percentageTokens": 12.59,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/global.c": {
            "lines": 345,
            "tokens": 2830,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 64,
            "duplicatedTokens": 1513,
            "percentage": 18.55,
            "percentageTokens": 53.46,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/fault.c": {
            "lines": 85,
            "tokens": 215,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/delete.c": {
            "lines": 965,
            "tokens": 6695,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/dbstat.c": {
            "lines": 851,
            "tokens": 6616,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/dbpage.c": {
            "lines": 414,
            "tokens": 2852,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/ctime.c": {
            "lines": 764,
            "tokens": 1789,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/complete.c": {
            "lines": 289,
            "tokens": 1635,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/callback.c": {
            "lines": 535,
            "tokens": 3345,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/btmutex.c": {
            "lines": 307,
            "tokens": 1797,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/bitvec.c": {
            "lines": 409,
            "tokens": 2354,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/backup.c": {
            "lines": 770,
            "tokens": 4745,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/auth.c": {
            "lines": 267,
            "tokens": 1369,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/attach.c": {
            "lines": 590,
            "tokens": 4329,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 98127,
          "tokens": 764948,
          "sources": 243,
          "clones": 315,
          "duplicatedLines": 6014,
          "duplicatedTokens": 75865,
          "percentage": 6.13,
          "percentageTokens": 9.92,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "cpp": {
        "sources": {
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_tdb2.cc": {
            "lines": 361,
            "tokens": 3299,
            "sources": 1,
            "clones": 4,
            "duplicatedLines": 28,
            "duplicatedTokens": 346,
            "percentage": 7.76,
            "percentageTokens": 10.49,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/pch.cpp": {
            "lines": 3,
            "tokens": 6,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/MainPage.xaml.cpp": {
            "lines": 52,
            "tokens": 345,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 8,
            "duplicatedTokens": 97,
            "percentage": 15.38,
            "percentageTokens": 28.12,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/App.xaml.cpp": {
            "lines": 119,
            "tokens": 695,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 8,
            "duplicatedTokens": 97,
            "percentage": 6.72,
            "percentageTokens": 13.96,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 535,
          "tokens": 4345,
          "sources": 4,
          "clones": 3,
          "duplicatedLines": 22,
          "duplicatedTokens": 270,
          "percentage": 4.11,
          "percentageTokens": 6.21,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "c-header": {
        "sources": {
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest_tdb.h": {
            "lines": 169,
            "tokens": 672,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm-test/lsmtest.h": {
            "lines": 275,
            "tokens": 2929,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/userauth/sqlite3userauth.h": {
            "lines": 95,
            "tokens": 213,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rtree/sqlite3rtree.h": {
            "lines": 116,
            "tokens": 414,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rtree/rtree.h": {
            "lines": 29,
            "tokens": 35,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/rbu/sqlite3rbu.h": {
            "lines": 604,
            "tokens": 326,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/misc/carray.h": {
            "lines": 22,
            "tokens": 78,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsmInt.h": {
            "lines": 986,
            "tokens": 5921,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/lsm1/lsm.h": {
            "lines": 683,
            "tokens": 1732,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/icu/sqliteicu.h": {
            "lines": 25,
            "tokens": 31,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5Int.h": {
            "lines": 830,
            "tokens": 3723,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts5/fts5.h": {
            "lines": 574,
            "tokens": 1080,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_tokenizer.h": {
            "lines": 160,
            "tokens": 374,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3_hash.h": {
            "lines": 111,
            "tokens": 295,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3Int.h": {
            "lines": 649,
            "tokens": 2619,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts3/fts3.h": {
            "lines": 25,
            "tokens": 31,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_tokenizer.h": {
            "lines": 144,
            "tokens": 314,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2_hash.h": {
            "lines": 109,
            "tokens": 269,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts2/fts2.h": {
            "lines": 25,
            "tokens": 31,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/tokenizer.h": {
            "lines": 88,
            "tokens": 277,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 148,
            "percentage": 29.55,
            "percentageTokens": 53.43,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fulltext.h": {
            "lines": 7,
            "tokens": 26,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fts1_tokenizer.h": {
            "lines": 89,
            "tokens": 294,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 26,
            "duplicatedTokens": 148,
            "percentage": 29.21,
            "percentageTokens": 50.34,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fts1_hash.h": {
            "lines": 111,
            "tokens": 300,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/fts1.h": {
            "lines": 7,
            "tokens": 26,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/fts1/ft_hash.h": {
            "lines": 110,
            "tokens": 297,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/expert/sqlite3expert.h": {
            "lines": 167,
            "tokens": 183,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/ext/async/sqlite3async.h": {
            "lines": 217,
            "tokens": 103,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/pch.h": {
            "lines": 3,
            "tokens": 6,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/MainPage.xaml.h": {
            "lines": 21,
            "tokens": 66,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/vsixtest/App.xaml.h": {
            "lines": 26,
            "tokens": 149,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/whereInt.h": {
            "lines": 606,
            "tokens": 2187,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/wal.h": {
            "lines": 154,
            "tokens": 641,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vxworks.h": {
            "lines": 31,
            "tokens": 21,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vdbeInt.h": {
            "lines": 617,
            "tokens": 2980,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/vdbe.h": {
            "lines": 390,
            "tokens": 1866,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_windirent.h": {
            "lines": 158,
            "tokens": 317,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_quota.h": {
            "lines": 267,
            "tokens": 421,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_multiplex.h": {
            "lines": 98,
            "tokens": 66,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/test_intarray.h": {
            "lines": 134,
            "tokens": 124,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/sqliteLimit.h": {
            "lines": 206,
            "tokens": 111,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/sqlite3ext.h": {
            "lines": 661,
            "tokens": 5675,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/pragma.h": {
            "lines": 647,
            "tokens": 3622,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/pcache.h": {
            "lines": 189,
            "tokens": 742,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/pager.h": {
            "lines": 241,
            "tokens": 1182,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/os_win.h": {
            "lines": 86,
            "tokens": 51,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/os_setup.h": {
            "lines": 55,
            "tokens": 36,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/os_common.h": {
            "lines": 91,
            "tokens": 158,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/os.h": {
            "lines": 211,
            "tokens": 644,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/mutex.h": {
            "lines": 70,
            "tokens": 44,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/msvc.h": {
            "lines": 40,
            "tokens": 30,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/hwtime.h": {
            "lines": 82,
            "tokens": 280,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/hash.h": {
            "lines": 95,
            "tokens": 227,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/btreeInt.h": {
            "lines": 718,
            "tokens": 1254,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/src/btree.h": {
            "lines": 407,
            "tokens": 1633,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 12731,
          "tokens": 47126,
          "sources": 54,
          "clones": 1,
          "duplicatedLines": 26,
          "duplicatedTokens": 148,
          "percentage": 0.2,
          "percentageTokens": 0.31,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "bash": {
        "sources": {
          "/home/hata6502/sqlite/ext/fts3/tool/fts3cov.sh": {
            "lines": 14,
            "tokens": 88,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/warnings.sh": {
            "lines": 59,
            "tokens": 352,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/warnings-clang.sh": {
            "lines": 13,
            "tokens": 105,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/symbols.sh": {
            "lines": 35,
            "tokens": 223,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/symbols-mingw.sh": {
            "lines": 32,
            "tokens": 184,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/speed-check.sh": {
            "lines": 203,
            "tokens": 1261,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 102,
            "percentage": 8.87,
            "percentageTokens": 8.09,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/run-speed-test.sh": {
            "lines": 89,
            "tokens": 575,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 18,
            "duplicatedTokens": 102,
            "percentage": 20.22,
            "percentageTokens": 17.74,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/mkautoconfamal.sh": {
            "lines": 92,
            "tokens": 460,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/kvtest-speed.sh": {
            "lines": 34,
            "tokens": 233,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/build-shell.sh": {
            "lines": 21,
            "tokens": 96,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/time-wordcount.sh": {
            "lines": 33,
            "tokens": 266,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/test/run-wordcount.sh": {
            "lines": 77,
            "tokens": 592,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/mkso.sh": {
            "lines": 31,
            "tokens": 172,
            "sources": 1,
            "clones": 0,
            "duplicatedLines": 0,
            "duplicatedTokens": 0,
            "percentage": 0,
            "percentageTokens": 0,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 733,
          "tokens": 4607,
          "sources": 13,
          "clones": 1,
          "duplicatedLines": 18,
          "duplicatedTokens": 102,
          "percentage": 2.46,
          "percentageTokens": 2.21,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "css": {
        "sources": {
          "/home/hata6502/sqlite/ext/rtree/visual01.txt": {
            "lines": 222,
            "tokens": 1501,
            "sources": 1,
            "clones": 2,
            "duplicatedLines": 396,
            "duplicatedTokens": 2668,
            "percentage": 178.38,
            "percentageTokens": 177.75,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 222,
          "tokens": 1501,
          "sources": 1,
          "clones": 1,
          "duplicatedLines": 198,
          "duplicatedTokens": 1334,
          "percentage": 89.19,
          "percentageTokens": 88.87,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      },
      "csharp": {
        "sources": {
          "/home/hata6502/sqlite/tool/Replace.cs": {
            "lines": 222,
            "tokens": 982,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 136,
            "percentage": 9.91,
            "percentageTokens": 13.85,
            "newDuplicatedLines": 0,
            "newClones": 0
          },
          "/home/hata6502/sqlite/tool/GetFile.cs": {
            "lines": 470,
            "tokens": 2592,
            "sources": 1,
            "clones": 1,
            "duplicatedLines": 22,
            "duplicatedTokens": 136,
            "percentage": 4.68,
            "percentageTokens": 5.25,
            "newDuplicatedLines": 0,
            "newClones": 0
          }
        },
        "total": {
          "lines": 692,
          "tokens": 3574,
          "sources": 2,
          "clones": 1,
          "duplicatedLines": 22,
          "duplicatedTokens": 136,
          "percentage": 3.18,
          "percentageTokens": 3.81,
          "newDuplicatedLines": 0,
          "newClones": 0
        }
      }
    },
    "total": {
      "lines": 136775,
      "tokens": 1025980,
      "sources": 423,
      "clones": 380,
      "duplicatedLines": 7668,
      "duplicatedTokens": 90667,
      "percentage": 5.61,
      "percentageTokens": 8.84,
      "newDuplicatedLines": 0,
      "newClones": 0
    },
    "revision": "9af69ff547d76f1f8c7c4513fdb6c0ca1a32f9fc"
  },
  "duplicates": [
    {
      "format": "tcl",
      "lines": 6,
      "fragment": "{} {\n  set cx [expr {100+int(rand()*800)}]\n  set cy [expr {100+int(rand()*600)}]\n  set p1 [expr {rand()*0.1}]\n  set p2 [expr {rand()*0.5+0.5}]\n  set p3 [expr {rand()*10",
      "tokens": 0,
      "firstFile": {
        "name": "ext/rtree/util/randomshape.tcl",
        "start": 40,
        "end": 45,
        "startLoc": {
          "line": 40,
          "column": 2,
          "position": 407
        },
        "endLoc": {
          "line": 45,
          "column": 3,
          "position": 505
        }
      },
      "secondFile": {
        "name": "ext/rtree/util/randomshape.tcl",
        "start": 31,
        "end": 36,
        "startLoc": {
          "line": 31,
          "column": 2,
          "position": 255
        },
        "endLoc": {
          "line": 36,
          "column": 4,
          "position": 353
        }
      }
    },
    {
      "format": "cpp",
      "lines": 7,
      "fragment": ";\n    const char *pVal; size_t nVal;\n    pKey = pCur->get(&nKey, &pVal, &nVal);\n\n    if( bReverse==0 && pKey2 ){\n      res = memcmp(pKey, pKey2, MIN((size_t)nKey2, nKey));\n     ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest_tdb2.cc",
        "start": 178,
        "end": 184,
        "startLoc": {
          "line": 178,
          "column": 2,
          "position": 1577
        },
        "endLoc": {
          "line": 184,
          "column": 5,
          "position": 1654
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest_tdb2.cc",
        "start": 105,
        "end": 112,
        "startLoc": {
          "line": 105,
          "column": 2,
          "position": 908
        },
        "endLoc": {
          "line": 112,
          "column": 5,
          "position": 987
        }
      }
    },
    {
      "format": "cpp",
      "lines": 9,
      "fragment": "l = -1;\n    }else{\n      *ppVal = val.mv_data;\n      *pnVal = val.mv_size;\n    }\n    mdb_txn_commit(txn);\n  }\n\n  return rc;\n}\n\nint test_mdb_scan(\n  TestDb *pDb,                    /* Database handle */\n  void *pCtx,                     /* Context pointer to pass to xCallback */\n  int bReverse,                   /* True for a reverse order scan */\n  void *pKey1, int nKey1,         /* Start of search",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest_tdb2.cc",
        "start": 338,
        "end": 346,
        "startLoc": {
          "line": 338,
          "column": 14,
          "position": 2980
        },
        "endLoc": {
          "line": 346,
          "column": 6,
          "position": 3076
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest_tdb2.cc",
        "start": 147,
        "end": 155,
        "startLoc": {
          "line": 147,
          "column": 13,
          "position": 1237
        },
        "endLoc": {
          "line": 155,
          "column": 5,
          "position": 1333
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": " if( *pRc==0 ){\n    FILE *fd;\n    fd = fopen(zFile, \"r+b\");\n    if( fd==0 ){\n      *pRc = 1;\n    }else{\n      if( 0!=fseek(fd, iOff, SEEK_SET) ){\n        *pRc = 1;\n      }else{\n    ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest8.c",
        "start": 114,
        "end": 122,
        "startLoc": {
          "line": 114,
          "column": 6,
          "position": 909
        },
        "endLoc": {
          "line": 122,
          "column": 7,
          "position": 991
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest8.c",
        "start": 88,
        "end": 96,
        "startLoc": {
          "line": 88,
          "column": 5,
          "position": 703
        },
        "endLoc": {
          "line": 96,
          "column": 6,
          "position": 785
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "oid testOomWriteData(\n  OomTest *pOom,\n  lsm_db *pDb,\n  Datasource *pData,\n  int iKey,\n  int *pRc\n){\n  void *pKey; int nKey;\n  void *pVal; int nVal;\n  testDatasourceEntry(pData, iKey, &pKey, &nKey, &pVal, &n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest6.c",
        "start": 178,
        "end": 188,
        "startLoc": {
          "line": 178,
          "column": 17,
          "position": 1496
        },
        "endLoc": {
          "line": 188,
          "column": 13,
          "position": 1585
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest6.c",
        "start": 153,
        "end": 163,
        "startLoc": {
          "line": 153,
          "column": 17,
          "position": 1263
        },
        "endLoc": {
          "line": 163,
          "column": 13,
          "position": 1352
        }
      }
    },
    {
      "format": "c",
      "lines": 31,
      "fragment": "\n\n    *pRc = tdb_open(\"bt\", zFile, 0, &pDb);\n    testCksumDatabase(pDb, zCksum);\n    testClose(&pDb);\n\n    if( *pRc==0 ){\n      int r1 = 0;\n      int r2 = -1;\n\n      r1 = strcmp(zCksum, zExpect1);\n      if( zExpect2 ) r2 = strcmp(zCksum, zExpect2);\n      if( r1 && r2 ){\n        if( zExpect2 ){\n          testPrintError(\"testCompareCksumLsmdb: \\\"%s\\\" != (\\\"%s\\\" OR \\\"%s\\\")\",\n              zCksum, zExpect1, zExpect2\n          );\n        }else{\n          testPrintError(\"testCompareCksumLsmdb: \\\"%s\\\" != \\\"%s\\\"\",\n              zCksum, zExpect1\n          );\n        }\n        *pRc = 1;\n        test_failed();\n      }\n    }\n  }\n}\n#endif /* not used */\n\n/* Above this point are reusable test routines. Not clear that they\n** should really be in this file.\n*****************************************",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest2.c",
        "start": 256,
        "end": 286,
        "startLoc": {
          "line": 256,
          "column": 5,
          "position": 1598
        },
        "endLoc": {
          "line": 286,
          "column": 75,
          "position": 1793
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest2.c",
        "start": 218,
        "end": 246,
        "startLoc": {
          "line": 218,
          "column": 2,
          "position": 1314
        },
        "endLoc": {
          "line": 246,
          "column": 7,
          "position": 1509
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "1;       /* Start key */\n    void *pKey2; int nKey2;       /* Final key */\n\n    iKey1 = testPrngValue(iSeed) % nData;\n    iKey2 = testPrngValue(iSeed+1) % nData;\n    testDatasourceEntry(pData, iKey1, &pKey2, &nKey1, 0, 0)",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest1.c",
        "start": 403,
        "end": 409,
        "startLoc": {
          "line": 403,
          "column": 6,
          "position": 3158
        },
        "endLoc": {
          "line": 409,
          "column": 9,
          "position": 3240
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest1.c",
        "start": 186,
        "end": 192,
        "startLoc": {
          "line": 186,
          "column": 5,
          "position": 747
        },
        "endLoc": {
          "line": 192,
          "column": 5,
          "position": 829
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "00,  200,    50   },\n    { {DATA_RANDOM,     20,25,     100,200},   100,    10,     1000 },\n    { {DATA_RANDOM,     20,25,     100,200},   100,    200,    50   },\n  };\n\n  int i;\n  int bRecover;\n\n  for(bRecover=0; bRecov",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm-test/lsmtest1.c",
        "start": 508,
        "end": 517,
        "startLoc": {
          "line": 508,
          "column": 4,
          "position": 4418
        },
        "endLoc": {
          "line": 517,
          "column": 9,
          "position": 4519
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm-test/lsmtest1.c",
        "start": 362,
        "end": 371,
        "startLoc": {
          "line": 362,
          "column": 2,
          "position": 2769
        },
        "endLoc": {
          "line": 371,
          "column": 8,
          "position": 2870
        }
      }
    },
    {
      "format": "tcl",
      "lines": 12,
      "fragment": "{expr tbl {order ASC} {aDictVar \"\"}} {\n  set res [list]\n\n  if {$aDictVar!=\"\"} {\n    upvar $aDictVar aDict\n    set dict aDict\n  } else {\n    set dict \"\"\n  }\n\n  foreach {rowid poslist collist} [fts5_query_data $expr $tbl $order $dict] {\n    lappend res $rowid $collist",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts5/test/fts5_common.tcl",
        "start": 530,
        "end": 541,
        "startLoc": {
          "line": 530,
          "column": 2,
          "position": 4444
        },
        "endLoc": {
          "line": 541,
          "column": 8,
          "position": 4557
        }
      },
      "secondFile": {
        "name": "ext/fts5/test/fts5_common.tcl",
        "start": 514,
        "end": 525,
        "startLoc": {
          "line": 514,
          "column": 2,
          "position": 4314
        },
        "endLoc": {
          "line": 525,
          "column": 8,
          "position": 4427
        }
      }
    },
    {
      "format": "tcl",
      "lines": 29,
      "fragment": "set fd [open $zName]\n  set lField {\n    code\n    character_name\n    general_category\n    canonical_combining_classes\n    bidirectional_category\n    character_decomposition_mapping\n    decimal_digit_value\n    digit_value\n    numeric_value\n    mirrored\n    unicode_1_name\n    iso10646_comment_field\n    uppercase_mapping\n    lowercase_mapping\n    titlecase_mapping\n  }\n  set lRet [list]\n\n  while { ![eof $fd] } {\n    set line [gets $fd]\n    if {$line == \"\"} continue\n\n    set fields [split $line \";\"]\n    if {[llength $fields] != [llength $lField]} { error \"parse error: $line\" }\n    foreach $lField $fields {}\n\n    set",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/unicode/parseunicode.tcl",
        "start": 105,
        "end": 133,
        "startLoc": {
          "line": 105,
          "column": 3,
          "position": 624
        },
        "endLoc": {
          "line": 133,
          "column": 4,
          "position": 801
        }
      },
      "secondFile": {
        "name": "ext/fts3/unicode/parseunicode.tcl",
        "start": 31,
        "end": 58,
        "startLoc": {
          "line": 31,
          "column": 3,
          "position": 70
        },
        "endLoc": {
          "line": 58,
          "column": 3,
          "position": 246
        }
      }
    },
    {
      "format": "tcl",
      "lines": 30,
      "fragment": "{zName} {\n  set fd [open $zName]\n  set lField {\n    code\n    character_name\n    general_category\n    canonical_combining_classes\n    bidirectional_category\n    character_decomposition_mapping\n    decimal_digit_value\n    digit_value\n    numeric_value\n    mirrored\n    unicode_1_name\n    iso10646_comment_field\n    uppercase_mapping\n    lowercase_mapping\n    titlecase_mapping\n  }\n  set lRet [list]\n\n  while { ![eof $fd] } {\n    set line [gets $fd]\n    if {$line == \"\"} continue\n\n    set fields [split $line \";\"]\n    if {[llength $fields] != [llength $lField]} { error \"parse error: $line\" }\n    foreach $lField $fields {}\n\n    lappend",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/unicode/parseunicode.tcl",
        "start": 169,
        "end": 198,
        "startLoc": {
          "line": 169,
          "column": 2,
          "position": 1182
        },
        "endLoc": {
          "line": 198,
          "column": 8,
          "position": 1366
        }
      },
      "secondFile": {
        "name": "ext/fts3/unicode/parseunicode.tcl",
        "start": 104,
        "end": 58,
        "startLoc": {
          "line": 104,
          "column": 2,
          "position": 617
        },
        "endLoc": {
          "line": 58,
          "column": 3,
          "position": 246
        }
      }
    },
    {
      "format": "c",
      "lines": 24,
      "fragment": "Handle(pipeThreads[1]);\n\n    /*\n     * Look for the commandline warning code in both streams.\n     *  - in MSVC 6 & 7 we get D4002, in MSVC 8 we get D9002.\n     */\n\n    return !(strstr(Out.buffer, \"D4002\") != NULL\n             || strstr(Err.buffer, \"D4002\") != NULL\n             || strstr(Out.buffer, \"D9002\") != NULL\n             || strstr(Err.buffer, \"D9002\") != NULL\n             || strstr(Out.buffer, \"D2021\") != NULL\n             || strstr(Err.buffer, \"D2021\") != NULL);\n}\n\f\nstatic int\nCheckForLinkerFeature(\n    const char *option)\n{\n    STARTUPINFO si;\n    PROCESS_INFORMATION pi;\n    SECURITY_ATTRIBUTES sa;\n    DWORD",
      "tokens": 0,
      "firstFile": {
        "name": "autoconf/tea/win/nmakehlp.c",
        "start": 315,
        "end": 338,
        "startLoc": {
          "line": 315,
          "column": 22,
          "position": 1980
        },
        "endLoc": {
          "line": 338,
          "column": 5,
          "position": 2174
        }
      },
      "secondFile": {
        "name": "autoconf/tea/win/nmakehlp.c",
        "start": 181,
        "end": 204,
        "startLoc": {
          "line": 181,
          "column": 24,
          "position": 1110
        },
        "endLoc": {
          "line": 204,
          "column": 6,
          "position": 1304
        }
      }
    },
    {
      "format": "c",
      "lines": 28,
      "fragment": " threadID;\n    char msg[300];\n    BOOL ok;\n    HANDLE hProcess, h, pipeThreads[2];\n    char cmdline[100];\n\n    hProcess = GetCurrentProcess();\n\n    ZeroMemory(&pi, sizeof(PROCESS_INFORMATION));\n    ZeroMemory(&si, sizeof(STARTUPINFO));\n    si.cb = sizeof(STARTUPINFO);\n    si.dwFlags   = STARTF_USESTDHANDLES;\n    si.hStdInput = INVALID_HANDLE_VALUE;\n\n    ZeroMemory(&sa, sizeof(SECURITY_ATTRIBUTES));\n    sa.nLength = sizeof(SECURITY_ATTRIBUTES);\n    sa.lpSecurityDescriptor = NULL;\n    sa.bInheritHandle = TRUE;\n\n    /*\n     * Create a non-inheritible pipe.\n     */\n\n    CreatePipe(&Out.pipe, &h, &sa, 0);\n\n    /",
      "tokens": 0,
      "firstFile": {
        "name": "autoconf/tea/win/nmakehlp.c",
        "start": 338,
        "end": 365,
        "startLoc": {
          "line": 338,
          "column": 5,
          "position": 2175
        },
        "endLoc": {
          "line": 365,
          "column": 20,
          "position": 2311
        }
      },
      "secondFile": {
        "name": "autoconf/tea/win/nmakehlp.c",
        "start": 204,
        "end": 231,
        "startLoc": {
          "line": 204,
          "column": 6,
          "position": 1305
        },
        "endLoc": {
          "line": 231,
          "column": 48,
          "position": 1441
        }
      }
    },
    {
      "format": "c",
      "lines": 61,
      "fragment": "   DuplicateHandle(hProcess, h, hProcess, &si.hStdOutput, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Same as above, but for the error side.\n     */\n\n    CreatePipe(&Err.pipe, &h, &sa, 0);\n    DuplicateHandle(hProcess, h, hProcess, &si.hStdError, 0, TRUE,\n\t    DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE);\n\n    /*\n     * Base command line.\n     */\n\n    lstrcpy(cmdline, \"link.exe -nologo \");\n\n    /*\n     * Append our option for testing.\n     */\n\n    lstrcat(cmdline, option);\n\n    ok = CreateProcess(\n\t    NULL,\t    /* Module name. */\n\t    cmdline,\t    /* Command line. */\n\t    NULL,\t    /* Process handle not inheritable. */\n\t    NULL,\t    /* Thread handle not inheritable. */\n\t    TRUE,\t    /* yes, inherit handles. */\n\t    DETACHED_PROCESS, /* No console for you. */\n\t    NULL,\t    /* Use parent's environment block. */\n\t    NULL,\t    /* Use parent's starting directory. */\n\t    &si,\t    /* Pointer to STARTUPINFO structure. */\n\t    &pi);\t    /* Pointer to PROCESS_INFORMATION structure. */\n\n    if (!ok) {\n\tDWORD err = GetLastError();\n\tint chars = snprintf(msg, sizeof(msg) - 1,\n\t\t\"Tried to launch: \\\"%s\\\", but got error [%u]: \", cmdline, err);\n\n\tFormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\tFORMAT_MESSAGE_MAX_WIDTH_MASK, 0L, err, 0, (LPVOID)&msg[chars],\n\t\t(300-chars), 0);\n\tWriteFile(GetStdHandle(STD_ERROR_HANDLE), msg, lstrlen(msg), &err,NULL);\n\treturn 2;\n    }\n\n    /*\n     * Close our references to the write handles that have now been inherited.\n     */\n\n    CloseHandle(si.hStdOutput);\n    CloseHandle(si.hStdError);\n\n    WaitForInputIdle(pi.hProcess, 5000);\n    CloseHandle(pi.hThread);\n\n    /*\n     * Start the pipe reader threads.\n     */\n\n    pipeThreads[0] = CreateThread(NULL, 0, ReadFromPipe, &Out, 0, &threadID);\n",
      "tokens": 0,
      "firstFile": {
        "name": "autoconf/tea/win/nmakehlp.c",
        "start": 371,
        "end": 431,
        "startLoc": {
          "line": 371,
          "column": 7,
          "position": 2327
        },
        "endLoc": {
          "line": 431,
          "column": 8,
          "position": 2717
        }
      },
      "secondFile": {
        "name": "autoconf/tea/win/nmakehlp.c",
        "start": 243,
        "end": 304,
        "startLoc": {
          "line": 243,
          "column": 10,
          "position": 1472
        },
        "endLoc": {
          "line": 304,
          "column": 8,
          "position": 1862
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "\", \";\n              renderValue(pVal);\n            }\n          }\n          printf(\" WHERE\");\n          zSep = \" \";\n          for(i=0; i<nCol; i++){\n            sqlite3_value *pVal;\n            if( abPK[i]==0 ) continue;\n            printf(\"%sc%d=\", zSep, i+1);\n            zSep = \" AND \";\n            sqlite3changeset_old(pIter, i, &pVal);\n        ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/session/changeset.c",
        "start": 381,
        "end": 393,
        "startLoc": {
          "line": 381,
          "column": 4,
          "position": 3284
        },
        "endLoc": {
          "line": 393,
          "column": 14,
          "position": 3391
        }
      },
      "secondFile": {
        "name": "ext/session/changeset.c",
        "start": 353,
        "end": 365,
        "startLoc": {
          "line": 353,
          "column": 2,
          "position": 3016
        },
        "endLoc": {
          "line": 365,
          "column": 14,
          "position": 3123
        }
      }
    },
    {
      "format": "css",
      "lines": 199,
      "fragment": "rintf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE geopoly_overlap(_shape, poly);\n.print '</pre>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE geopoly_overlap(_shape, poly);\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\n.print '</svg>'\n\n.print '<h1>Overlap Query And Result Bounding Box</h1>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE geopoly_overlap(_shape, poly);\nSELECT geopoly_svg(geopoly_bbox(poly),\n         'style=\"fill:none;stroke:black;stroke-width:3\"'\n       )\n  FROM querypoly;\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\nSELECT geopoly_svg(geopoly_group_bbox(_shape),\n         'style=\"fill:none;stroke:red;stroke-width:3\"'\n       )\n  FROM geo1, querypoly\n WHERE geopoly_overlap(_shape, poly);\n.print '</svg>'\n\n.print '<h1>Bounding-Box Overlap Query</h1>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       ),\n       geopoly_svg(geopoly_bbox(_shape),\n         'style=\"fill:none;stroke:black;stroke-width:1\"'\n       )\n  FROM geo1, querypoly\n WHERE geopoly_overlap(geopoly_bbox(_shape), geopoly_bbox(poly));\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\nSELECT geopoly_svg(geopoly_bbox(poly),\n         'style=\"fill:none;stroke:black;stroke-width:3\"'\n       )\n  FROM querypoly;\n.print '</svg>'\n\n.print '<h1>Within Query</h1>'\n.print '<pre>'\n.print 'SELECT *'\n.print '  FROM geo1, querypoly'\n.print ' WHERE geopoly_within(_shape, poly);'\n.print \nEXPLAIN QUERY PLAN\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE geopoly_within(_shape, poly);\n.print '</pre>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE geopoly_within(_shape, poly);\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\n.print '</svg>'\n\n.print '<h1>Bounding-Box WITHIN Query</h1>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       ),\n       geopoly_svg(geopoly_bbox(_shape),\n         'style=\"fill:none;stroke:black;stroke-width:1\"'\n       )\n  FROM geo1, querypoly\n WHERE geopoly_within(geopoly_bbox(_shape), geopoly_bbox(poly));\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\nSELECT geopoly_svg(geopoly_bbox(poly),\n         'style=\"fill:none;stroke:black;stroke-width:3\"'\n       )\n  FROM querypoly;\n.print '</svg>'\n\n.print '<h1>Not Overlap Query</h1>'\n.print '<pre>'\n.print 'SELECT *'\n.print '  FROM geo1, querypoly'\n.print ' WHERE NOT geopoly_overlap(_shape, poly);'\n.print \nEXPLAIN QUERY PLAN\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE NOT geopoly_overlap(_shape, poly);\n.print '</pre>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE NOT geopoly_overlap(_shape, poly);\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\n.print '</svg>'\n\n.print '<h1>Not Within Query</h1>'\n.print '<pre>'\n.print 'SELECT *'\n.print '  FROM geo1, querypoly'\n.print ' WHERE NOT geopoly_within(_shape, poly);'\n.print \nEXPLAIN QUERY PLAN\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE NOT geopoly_within(_shape, poly);\n.print '</pre>'\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1, querypoly\n WHERE NOT geopoly_within(_shape, poly);\nSELECT geopoly_svg(poly, \n         printf('style=\"fill:%s;fill-opacity:0.5;\"',clr)\n       )\n  FROM querypoly;\n.print '</svg>'\n\n.print '<h1>Color-Change For Overlapping Elements</h1>'\nBEGIN;\nUPDATE geo1\n   SET clr=CASE WHEN rowid IN (SELECT geo1.rowid FROM geo1, querypoly\n                                WHERE geopoly_overlap(_shape,poly))\n           THEN 'red' ELSE 'blue' END;\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1;\nSELECT geopoly_svg(poly,'style=\"fill:none;stroke:black;stroke-width:2\"')\n  FROM querypoly;\nROLLBACK;\n.print '</svg>'\n\n.print '<h1>Color-Change And Move Overlapping Elements</h1>'\nBEGIN;\nUPDATE geo1\n   SET clr=CASE WHEN rowid IN (SELECT geo1.rowid FROM geo1, querypoly\n                                WHERE geopoly_overlap(_shape,poly))\n           THEN 'red' ELSE '#76ccff' END;\nUPDATE geo1\n   SET _shape=geopoly_xform(_shape,1,0,0,1,300,0)\n WHERE geopoly_overlap(_shape,(SELECT poly FROM querypoly));\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1;\nSELECT geopoly_svg(poly,'style=\"fill:none;stroke:black;stroke-width:2\"')\n  FROM querypoly;\n--ROLLBACK;\n.print '</svg>'\n\n\n.print '<h1>Overlap With Translated Query Polygon</h1>'\nUPDATE querypoly SET poly=geopoly_xform(poly,1,0,0,1,300,0);\n.print '<svg width=\"1000\" height=\"800\" style=\"border:1px solid black\">'\nSELECT geopoly_svg(_shape,\n         printf('style=\"fill:none;stroke:%s;stroke-width:1\"',geo1.clr)\n       )\n  FROM geo1\n WHERE geopoly_overlap(_shape,(SELECT poly FROM querypoly));\nSELECT geopoly_svg(",
      "tokens": 0,
      "firstFile": {
        "name": "ext/rtree/visual01.txt",
        "start": 391,
        "end": 589,
        "startLoc": {
          "line": 391,
          "column": 2,
          "position": 2961
        },
        "endLoc": {
          "line": 589,
          "column": 2,
          "position": 4295
        }
      },
      "secondFile": {
        "name": "ext/rtree/visual01.txt",
        "start": 367,
        "end": 528,
        "startLoc": {
          "line": 367,
          "column": 2,
          "position": 2794
        },
        "endLoc": {
          "line": 528,
          "column": 2,
          "position": 3913
        }
      }
    },
    {
      "format": "c",
      "lines": 25,
      "fragment": "(*pNew));\n  rc = pAux->pMod->xCreate(db, pAux->pChildAux, argc, argv,\n                           &pNew->pChild, pzErr);\n  if( rc ){\n    sqlite3_free(pNew);\n    *ppVtab = 0;\n    return rc;\n  }\n  pNew->pAux = pAux;\n  pNew->ppPrev = &pAux->pAllVtab;\n  pNew->pNext = pAux->pAllVtab;\n  if( pAux->pAllVtab ) pAux->pAllVtab->ppPrev = &pNew->pNext;\n  pAux->pAllVtab = pNew;\n  return rc;\n}\n\nstatic int vtshimConnect(\n  sqlite3 *db,\n  void *ppAux,\n  int argc,\n  const char *const*argv,\n  sqlite3_vtab **ppVtab,\n  char **pzErr\n){\n  vtshim_aux *pAux = (vtshim_aux*)ppAux;\n  vtshim_vtab *p",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/vtshim.c",
        "start": 104,
        "end": 128,
        "startLoc": {
          "line": 104,
          "column": 14,
          "position": 612
        },
        "endLoc": {
          "line": 128,
          "column": 9,
          "position": 826
        }
      },
      "secondFile": {
        "name": "ext/misc/vtshim.c",
        "start": 65,
        "end": 89,
        "startLoc": {
          "line": 65,
          "column": 13,
          "position": 254
        },
        "endLoc": {
          "line": 89,
          "column": 8,
          "position": 468
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "New;\n  int rc;\n\n  assert( db==pAux->db );\n  if( pAux->bDisposed ){\n    if( pzErr ){\n      *pzErr = sqlite3_mprintf(\"virtual table was disposed: \\\"%s\\\"\",\n                               pAux->zName);\n    }\n    return SQLITE_ERROR;\n  }\n  pNew = sqlite3_malloc( sizeof(*pNew) );\n  *ppVtab = (sqlite3_vtab*)pNew;\n  if( pNew==0 ) return SQLITE_NOMEM;\n  memset(pNew, 0, sizeof(*pN",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/vtshim.c",
        "start": 128,
        "end": 143,
        "startLoc": {
          "line": 128,
          "column": 9,
          "position": 827
        },
        "endLoc": {
          "line": 143,
          "column": 16,
          "position": 969
        }
      },
      "secondFile": {
        "name": "ext/misc/vtshim.c",
        "start": 89,
        "end": 104,
        "startLoc": {
          "line": 89,
          "column": 8,
          "position": 469
        },
        "endLoc": {
          "line": 104,
          "column": 14,
          "position": 611
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "t argc,\n  sqlite3_value **argv\n){\n  vtshim_cursor *pCur = (vtshim_cursor*)pX;\n  vtshim_vtab *pVtab = (vtshim_vtab*)pCur->base.pVtab;\n  vtshim_aux *pAux = pVtab->pAux;\n  int rc;\n  if( pAux->bDisposed ) return SQLITE_",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/vtshim.c",
        "start": 245,
        "end": 251,
        "startLoc": {
          "line": 245,
          "column": 3,
          "position": 1993
        },
        "endLoc": {
          "line": 251,
          "column": 6,
          "position": 2073
        }
      },
      "secondFile": {
        "name": "ext/misc/vtshim.c",
        "start": 232,
        "end": 238,
        "startLoc": {
          "line": 232,
          "column": 1,
          "position": 1854
        },
        "endLoc": {
          "line": 238,
          "column": 8,
          "position": 1934
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "MSG();\n  }\n  return rc;\n}\n\nstatic int vtshimEof(sqlite3_vtab_cursor *pX){\n  vtshim_cursor *pCur = (vtshim_cursor*)pX;\n  vtshim_vtab *pVtab = (vtshim_vtab*)pCur->base.pVtab;\n  vtshim_aux *pAux = pVtab->pAux;\n  int rc;\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/vtshim.c",
        "start": 269,
        "end": 275,
        "startLoc": {
          "line": 269,
          "column": 2,
          "position": 2244
        },
        "endLoc": {
          "line": 275,
          "column": 8,
          "position": 2324
        }
      },
      "secondFile": {
        "name": "ext/misc/vtshim.c",
        "start": 232,
        "end": 238,
        "startLoc": {
          "line": 232,
          "column": 1,
          "position": 1854
        },
        "endLoc": {
          "line": 238,
          "column": 8,
          "position": 1934
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "sqlite3_context *ctx, int i){\n  vtshim_cursor *pCur = (vtshim_cursor*)pX;\n  vtshim_vtab *pVtab = (vtshim_vtab*)pCur->base.pVtab;\n  vtshim_aux *pAux = pVtab->pAux;\n  int rc;\n  if( pAux->bDisposed ) return SQLITE_ERROR",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/vtshim.c",
        "start": 282,
        "end": 288,
        "startLoc": {
          "line": 282,
          "column": 7,
          "position": 2383
        },
        "endLoc": {
          "line": 288,
          "column": 7,
          "position": 2463
        }
      },
      "secondFile": {
        "name": "ext/misc/vtshim.c",
        "start": 232,
        "end": 238,
        "startLoc": {
          "line": 232,
          "column": 1,
          "position": 1854
        },
        "endLoc": {
          "line": 238,
          "column": 8,
          "position": 1934
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "g);\n  rc = p->pReal->pMethods->xWrite(p->pReal, z, iAmt, iOfst);\n  tElapse = vlog_time() - tStart;\n  vlogLogPrint(p->pLog, tStart, tElapse, \"WRITE\", iAmt, iOfst, zSig, rc);\n  if( rc==SQLITE_OK\n   && p->pLog\n   && p->pLog->zFilename\n   && iOfst<=24\n   && iOfst+iAmt>=28\n  ){\n    unsigned char *x = ((unsigned char*)z)+",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/vfslog.c",
        "start": 448,
        "end": 458,
        "startLoc": {
          "line": 448,
          "column": 2,
          "position": 3406
        },
        "endLoc": {
          "line": 458,
          "column": 16,
          "position": 3535
        }
      },
      "secondFile": {
        "name": "ext/misc/vfslog.c",
        "start": 408,
        "end": 418,
        "startLoc": {
          "line": 408,
          "column": 5,
          "position": 3006
        },
        "endLoc": {
          "line": 418,
          "column": 15,
          "position": 3135
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "to\n** the database for SCHEMA\n*/\nstatic void func_uri_boolean(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zSchema = (const char*)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zName = (const char*)sqlite3_value_text(argv[1]);\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 74,
        "end": 83,
        "startLoc": {
          "line": 74,
          "column": 17,
          "position": 279
        },
        "endLoc": {
          "line": 83,
          "column": 4,
          "position": 388
        }
      },
      "secondFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 55,
        "end": 64,
        "startLoc": {
          "line": 55,
          "column": 19,
          "position": 125
        },
        "endLoc": {
          "line": 64,
          "column": 6,
          "position": 234
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "r to\n** the database for SCHEMA\n*/\nstatic void func_uri_int64(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zSchema = (const char*)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zName = (const char*)sqlite3_value_text(argv[1]);\n  const ch",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 112,
        "end": 121,
        "startLoc": {
          "line": 112,
          "column": 15,
          "position": 587
        },
        "endLoc": {
          "line": 121,
          "column": 14,
          "position": 696
        }
      },
      "secondFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 55,
        "end": 64,
        "startLoc": {
          "line": 55,
          "column": 19,
          "position": 125
        },
        "endLoc": {
          "line": 64,
          "column": 6,
          "position": 234
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "ase filename for SCHEMA\n*/\nstatic void func_filename_database(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zSchema = (const char*)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 131,
        "end": 139,
        "startLoc": {
          "line": 131,
          "column": 23,
          "position": 750
        },
        "endLoc": {
          "line": 139,
          "column": 6,
          "position": 834
        }
      },
      "secondFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 39,
        "end": 47,
        "startLoc": {
          "line": 39,
          "column": 17,
          "position": 15
        },
        "endLoc": {
          "line": 47,
          "column": 20,
          "position": 99
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "rnal filename for SCHEMA\n*/\nstatic void func_filename_journal(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zSchema = (const char*)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zFile = sqlite3_db_filename(db, zS",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 148,
        "end": 156,
        "startLoc": {
          "line": 148,
          "column": 22,
          "position": 884
        },
        "endLoc": {
          "line": 156,
          "column": 25,
          "position": 981
        }
      },
      "secondFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 39,
        "end": 139,
        "startLoc": {
          "line": 39,
          "column": 17,
          "position": 15
        },
        "endLoc": {
          "line": 139,
          "column": 26,
          "position": 847
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": " the WAL filename for SCHEMA\n*/\nstatic void func_filename_wal(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zSchema = (const char*)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zFile = sqlite3_db_filename(db",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 165,
        "end": 173,
        "startLoc": {
          "line": 165,
          "column": 18,
          "position": 1018
        },
        "endLoc": {
          "line": 173,
          "column": 21,
          "position": 1115
        }
      },
      "secondFile": {
        "name": "ext/misc/urifuncs.c",
        "start": 39,
        "end": 139,
        "startLoc": {
          "line": 39,
          "column": 17,
          "position": 15
        },
        "endLoc": {
          "line": 139,
          "column": 26,
          "position": 847
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": ");\n      }\n      break;\n    }\n    case SQLITE_BLOB: {\n      const unsigned char *zBlob = sqlite3_value_blob(argv[0]);\n      if( zBlob ){\n        int nBlob = sqlite3_value_bytes(argv[0]);\n        if( nBlob==sizeof(double) ){\n          double",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/totype.c",
        "start": 463,
        "end": 472,
        "startLoc": {
          "line": 463,
          "column": 5,
          "position": 3116
        },
        "endLoc": {
          "line": 472,
          "column": 3,
          "position": 3203
        }
      },
      "secondFile": {
        "name": "ext/misc/totype.c",
        "start": 393,
        "end": 402,
        "startLoc": {
          "line": 393,
          "column": 5,
          "position": 2564
        },
        "endLoc": {
          "line": 402,
          "column": 2,
          "position": 2651
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "US_FULLSCAN_STEP */\n#define STMT_COLUMN_NSORT   5   /* SQLITE_STMTSTATUS_SORT */\n#define STMT_COLUMN_NAIDX   6   /* SQLITE_STMTSTATUS_AUTOINDEX */\n#define STMT_COLUMN_NSTEP   7   /* SQLITE_STM",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/stmt.c",
        "start": 93,
        "end": 99,
        "startLoc": {
          "line": 93,
          "column": 18,
          "position": 218
        },
        "endLoc": {
          "line": 99,
          "column": 3,
          "position": 297
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 203,
        "end": 209,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1283
        },
        "endLoc": {
          "line": 209,
          "column": 5,
          "position": 1362
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": ");\n    a31 =   b1 ^((~b2)&  b3 );\n    a42 =   b2 ^((~b3)&  b4 );\n    a03 =   b3 ^((~b4)&  b0 );\n    a14 =   b4 ^((~b0)&  b1 );\n\n    b4 = ROL64((a40^d0), 18);\n    b0 = ROL6",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/shathree.c",
        "start": 197,
        "end": 205,
        "startLoc": {
          "line": 197,
          "column": 4,
          "position": 1539
        },
        "endLoc": {
          "line": 205,
          "column": 4,
          "position": 1642
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 130,
        "end": 138,
        "startLoc": {
          "line": 130,
          "column": 4,
          "position": 417
        },
        "endLoc": {
          "line": 138,
          "column": 4,
          "position": 520
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": ");\n    a21 =   b1 ^((~b2)&  b3 );\n    a02 =   b2 ^((~b3)&  b4 );\n    a33 =   b3 ^((~b4)&  b0 );\n    a14 =   b4 ^((~b0)&  b1 );\n\n    b4 = ROL64((a30^d0), 18);\n    b0 = ROL6",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/shathree.c",
        "start": 264,
        "end": 272,
        "startLoc": {
          "line": 264,
          "column": 4,
          "position": 2663
        },
        "endLoc": {
          "line": 272,
          "column": 4,
          "position": 2766
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 130,
        "end": 138,
        "startLoc": {
          "line": 130,
          "column": 4,
          "position": 417
        },
        "endLoc": {
          "line": 138,
          "column": 4,
          "position": 520
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": ");\n    a01 =   b1 ^((~b2)&  b3 );\n    a22 =   b2 ^((~b3)&  b4 );\n    a43 =   b3 ^((~b4)&  b0 );\n    a14 =   b4 ^((~b0)&  b1 );\n\n    b4 = ROL64((a10^d0), 18);\n    b0 = ROL6",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/shathree.c",
        "start": 331,
        "end": 339,
        "startLoc": {
          "line": 331,
          "column": 4,
          "position": 3787
        },
        "endLoc": {
          "line": 339,
          "column": 4,
          "position": 3890
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 130,
        "end": 138,
        "startLoc": {
          "line": 130,
          "column": 4,
          "position": 417
        },
        "endLoc": {
          "line": 138,
          "column": 4,
          "position": 520
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "**       F<ieee-float>\n**       B<size>:<bytes>\n**       T<size>:<text>\n**\n** <sql> is the original SQL text for each statement run and <n> is\n** the size of that text.  The SQL text is UTF-8.  A single R character\n** occurs before the start of each row.  N means a NULL value.\n** I mean an 8-byte little-endian integer <int",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/shathree.c",
        "start": 590,
        "end": 603,
        "startLoc": {
          "line": 590,
          "column": 3,
          "position": 6127
        },
        "endLoc": {
          "line": 603,
          "column": 5,
          "position": 6234
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 505,
        "end": 517,
        "startLoc": {
          "line": 505,
          "column": 2,
          "position": 5669
        },
        "endLoc": {
          "line": 517,
          "column": 6,
          "position": 5775
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": " SHA1 context */\nstatic void hash_init(SHA1Context *p){\n  /* SHA1 initialization constants */\n  p->state[0] = 0x67452301;\n  p->state[1] = 0xEFCDAB89;\n  p->state[2] = 0x98BADCFE;\n  p->state[3] = 0x10325476;\n  p->state[4] = 0xC3D2E1F0;\n  p->count[0] = p-",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/sha1.c",
        "start": 171,
        "end": 182,
        "startLoc": {
          "line": 171,
          "column": 2,
          "position": 2300
        },
        "endLoc": {
          "line": 182,
          "column": 10,
          "position": 2392
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 531,
        "end": 542,
        "startLoc": {
          "line": 531,
          "column": 2,
          "position": 5891
        },
        "endLoc": {
          "line": 542,
          "column": 11,
          "position": 5983
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "The hash of a NULL\n** value is NULL.\n*/\nstatic void sha1Func(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  SHA1Context cx;\n  int eType = sqlite3_value_type(argv[0]);\n  int nByte = sqlite3_value_bytes(argv[0]);\n  char zOut[44];\n\n  assert( argc==1 );\n  if( eType==SQLITE_NULL ) return;\n  hash_init(&cx);\n  if( eType==SQLITE_BLOB ){\n    hash_step(&cx, sqlite3_",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/sha1.c",
        "start": 262,
        "end": 275,
        "startLoc": {
          "line": 262,
          "column": 14,
          "position": 3042
        },
        "endLoc": {
          "line": 275,
          "column": 12,
          "position": 3155
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 577,
        "end": 590,
        "startLoc": {
          "line": 577,
          "column": 14,
          "position": 6011
        },
        "endLoc": {
          "line": 590,
          "column": 12,
          "position": 6124
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "), nByte);\n  }\n  hash_finish(&cx, zOut);\n  sqlite3_result_text(context, zOut, 40, SQLITE_TRANSIENT);\n}\n\n/*\n** Implementation of the sha1_query(SQL) function.\n**\n** This function compiles and runs the SQL statement(s) given in the\n** argument. The results are hashed using SHA1 and that hash is returned.\n**\n** The original SQL text is included as part of the hash.\n**\n** The hash is not just a concatenation of the outputs.  Each query\n** is delimited and each row and value within the query is delimited,\n** with all values being marked with their datatypes.\n*/\nstatic void sha1QueryFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sql",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/sha1.c",
        "start": 280,
        "end": 300,
        "startLoc": {
          "line": 280,
          "column": 3,
          "position": 3199
        },
        "endLoc": {
          "line": 300,
          "column": 2,
          "position": 3399
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 604,
        "end": 624,
        "startLoc": {
          "line": 604,
          "column": 6,
          "position": 6251
        },
        "endLoc": {
          "line": 624,
          "column": 3,
          "position": 6451
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "  hash_init(&cx);\n  while( zSql[0] ){\n    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zSql);\n    if( rc ){\n      char *zMsg = sqlite3_mprintf(\"error SQL statement [%s]: %s\",\n                                   zSql, sqlite3_errmsg(db));\n      sqlite3_finalize(pStmt);\n      sqlite3_result_error(context, zMsg, -1);\n      sqlite3_free(zMsg);\n      return;\n    }\n    if( !sqlite3_stmt_readonly(pStmt) ){\n      char *zMs",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/sha1.c",
        "start": 310,
        "end": 324,
        "startLoc": {
          "line": 310,
          "column": 10,
          "position": 3522
        },
        "endLoc": {
          "line": 324,
          "column": 10,
          "position": 3665
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 636,
        "end": 650,
        "startLoc": {
          "line": 636,
          "column": 11,
          "position": 6586
        },
        "endLoc": {
          "line": 650,
          "column": 11,
          "position": 6729
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "g = sqlite3_mprintf(\"non-query: [%s]\", sqlite3_sql(pStmt));\n      sqlite3_finalize(pStmt);\n      sqlite3_result_error(context, zMsg, -1);\n      sqlite3_free(zMsg);\n      return;\n    }\n    nCol = sqlite3_column_count(pStmt);\n    z = sqlite3_sql(pStmt);\n    n = (int)strlen(z);\n    hash_step_vformat(&cx,\"S%d:\",n);\n    hash_step(&cx,(unsigned char*)z,n);\n\n    /* Compute a hash over the res",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/sha1.c",
        "start": 324,
        "end": 338,
        "startLoc": {
          "line": 324,
          "column": 10,
          "position": 3666
        },
        "endLoc": {
          "line": 338,
          "column": 10,
          "position": 3802
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 650,
        "end": 664,
        "startLoc": {
          "line": 650,
          "column": 11,
          "position": 6730
        },
        "endLoc": {
          "line": 664,
          "column": 11,
          "position": 6866
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "r\n){\n  prefixes_vtab *pNew;\n  int rc;\n\n  rc = sqlite3_declare_vtab(db,\n           \"CREATE TABLE prefixes(prefix TEXT, original_string TEXT HIDDEN)\"\n       );\n  if( rc==SQLITE_OK ){\n    pNew = sqlite3_mal",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/prefixes.c",
        "start": 76,
        "end": 82,
        "startLoc": {
          "line": 76,
          "column": 8,
          "position": 182
        },
        "endLoc": {
          "line": 82,
          "column": 20,
          "position": 259
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 203,
        "end": 209,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1283
        },
        "endLoc": {
          "line": 209,
          "column": 5,
          "position": 1360
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "olumn numbers */\n#define MSV_COLUMN_NAME    0   /* Name of quantity being measured */\n#define MSV_COLUMN_SCHEMA  1   /* schema name */\n#define MSV_COLUMN_VALUE   2   /* Current value */\n#define MSV_COLUMN_HIWTR   3   /* Highwater mark */\n\n  rc = sqlite3_declare_vtab(db,\"CREATE TABLE x",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/memstat.c",
        "start": 86,
        "end": 99,
        "startLoc": {
          "line": 86,
          "column": 42,
          "position": 226
        },
        "endLoc": {
          "line": 99,
          "column": 3,
          "position": 324
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 203,
        "end": 106,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1283
        },
        "endLoc": {
          "line": 106,
          "column": 3,
          "position": 316
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "R(argc);\n  if( sqlite3_value_type(argv[0])==SQLITE_BLOB\n   && sqlite3_value_bytes(argv[0])==sizeof(double)\n  ){\n    double r;\n    const unsigned char *x = sqlite3_value_blob(argv[0]);\n    unsigned int i;\n    sqlite3_uin",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/ieee754.c",
        "start": 223,
        "end": 230,
        "startLoc": {
          "line": 223,
          "column": 5,
          "position": 1120
        },
        "endLoc": {
          "line": 230,
          "column": 22,
          "position": 1220
        }
      },
      "secondFile": {
        "name": "ext/misc/ieee754.c",
        "start": 117,
        "end": 124,
        "startLoc": {
          "line": 117,
          "column": 7,
          "position": 145
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 245
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "perand 1 */\n#define EXPLN_COLUMN_P2       3   /* Operand 2 */\n#define EXPLN_COLUMN_P3       4   /* Operand 3 */\n#define EXPLN_COLUMN_P4       5   /* Operand 4 */\n#define EXPLN_COLUMN_P5       6   /* Operand 5 */\n#define EXPLN_COLUMN_COMMENT  7   /* Comment */\n#define EXPLN_COLUMN_SQL ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/explain.c",
        "start": 93,
        "end": 106,
        "startLoc": {
          "line": 93,
          "column": 64,
          "position": 219
        },
        "endLoc": {
          "line": 106,
          "column": 3,
          "position": 317
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 203,
        "end": 106,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1283
        },
        "endLoc": {
          "line": 106,
          "column": 3,
          "position": 316
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "row = 1;\n        }else{\n          pA->a[i] = x;\n          borrow = 0;\n        }\n      }\n    }\n  }\n}\n\n/*\n** Compare text in decimal order.\n*/\nstatic int decimalCollFunc(\n  void *notUsed,\n  int nKey1, const voi",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/decimal.c",
        "start": 413,
        "end": 420,
        "startLoc": {
          "line": 413,
          "column": 16,
          "position": 3390
        },
        "endLoc": {
          "line": 420,
          "column": 8,
          "position": 3476
        }
      },
      "secondFile": {
        "name": "ext/misc/uint.c",
        "start": 40,
        "end": 47,
        "startLoc": {
          "line": 40,
          "column": 13,
          "position": 16
        },
        "endLoc": {
          "line": 47,
          "column": 4,
          "position": 102
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "t, argv[1], 0, 0);\n  UNUSED_PARAMETER(argc);\n  decimal_add(pA, pB);\n  decimal_result(context, pA);\n  decimal_free(pA);\n  decimal_free(pB);\n}\nstatic void decimalSubFunc(\n  sqlite3_context *context,\n  int a",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/decimal.c",
        "start": 454,
        "end": 462,
        "startLoc": {
          "line": 454,
          "column": 15,
          "position": 3737
        },
        "endLoc": {
          "line": 462,
          "column": 3,
          "position": 3822
        }
      },
      "secondFile": {
        "name": "ext/misc/decimal.c",
        "start": 441,
        "end": 449,
        "startLoc": {
          "line": 441,
          "column": 15,
          "position": 3612
        },
        "endLoc": {
          "line": 449,
          "column": 12,
          "position": 3697
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "_value_type(argv[0])==SQLITE_NULL ) return;\n  pArg = decimal_new(context, argv[0], 0, 0);\n  decimal_add(p, pArg);\n  decimal_free(pArg);\n}\nstatic void decimalSumInverse(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/decimal.c",
        "start": 501,
        "end": 511,
        "startLoc": {
          "line": 501,
          "column": 18,
          "position": 4136
        },
        "endLoc": {
          "line": 511,
          "column": 19,
          "position": 4217
        }
      },
      "secondFile": {
        "name": "ext/misc/decimal.c",
        "start": 475,
        "end": 485,
        "startLoc": {
          "line": 475,
          "column": 15,
          "position": 3891
        },
        "endLoc": {
          "line": 485,
          "column": 2,
          "position": 3972
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "nt are omitted as long as\n** the number of digits after the decimal point is no less than\n** either the number of digits in either input.\n*/\nstatic void decimalMulFunc(\n  sqlite3_con",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/decimal.c",
        "start": 539,
        "end": 546,
        "startLoc": {
          "line": 539,
          "column": 15,
          "position": 4419
        },
        "endLoc": {
          "line": 546,
          "column": 7,
          "position": 4497
        }
      },
      "secondFile": {
        "name": "ext/misc/decimal.c",
        "start": 441,
        "end": 448,
        "startLoc": {
          "line": 441,
          "column": 15,
          "position": 3612
        },
        "endLoc": {
          "line": 448,
          "column": 17,
          "position": 3690
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "ge                     /* OUT: Size of (*ppPage) in bytes */\n){\n  int rc2;\n  int rc = SQLITE_OK;\n  sqlite3_stmt *pStmt = pCsr->pStmt;\n\n  *ppPage = 0;\n  *pnPage = 0;\n  sqlite3_bind_int64(pStmt, 2, pgno);\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    int nCopy = sqlite3_column_bytes(pStmt, 0);\n    if( nCopy>0 ){\n      ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/dbdata.c",
        "start": 348,
        "end": 363,
        "startLoc": {
          "line": 348,
          "column": 16,
          "position": 1884
        },
        "endLoc": {
          "line": 363,
          "column": 3,
          "position": 2036
        }
      },
      "secondFile": {
        "name": "ext/misc/scrub.c",
        "start": 278,
        "end": 292,
        "startLoc": {
          "line": 278,
          "column": 18,
          "position": 2045
        },
        "endLoc": {
          "line": 292,
          "column": 3,
          "position": 2197
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "\n** character, or to the zero terminator if the string has only whitespace */\nstatic const char *csv_skip_whitespace(const char *z){\n  while( isspace((unsigned char)z[0]) ) z++;\n  return z;\n}\n\n/* Remove trailing whitespace from the end of string z[] */\nstatic void csv_trim_whitespace(char *z){\n  size_t n = strlen(z);\n  while( n>0 && isspace((unsigned char)z[n]) ) n--;\n  z[n] = 0;\n}\n\n/* Dequote the string */\nstatic void csv_dequote(char *z){\n  int j;\n  char cQuote = z[0];\n  size_t i, n;\n\n  if( cQuote!='\\''",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/csv.c",
        "start": 360,
        "end": 379,
        "startLoc": {
          "line": 360,
          "column": 12,
          "position": 2440
        },
        "endLoc": {
          "line": 379,
          "column": 14,
          "position": 2628
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 72,
        "end": 91,
        "startLoc": {
          "line": 72,
          "column": 16,
          "position": 240
        },
        "endLoc": {
          "line": 91,
          "column": 18,
          "position": 428
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": "=0 ) return 0;\n  p->zErr[0] = 0;\n  if( *pzVal ){\n    csv_errmsg(p, \"more than one '%s' parameter\", zParam);\n    return 1;\n  }\n  *pzVal = sqlite3_mprintf(\"%s\", zValue);\n  if( *pzVal==0 ){\n    csv_errmsg(p, \"out of memory\");\n    return 1;\n  }\n  csv_trim_whitespace(*pzVal);\n  csv_dequote(*pzVal);\n  return 1;\n}\n\n\n/* Return 0 if the argument is false and 1 if it is true.  Return -1 if\n** we cannot really tell.\n*/\nstatic int csv_boolean(const char *z){\n  if( sqlite3_stricmp(\"yes\",z)==0\n   || sqlite3_stricmp(\"on\",z)==0\n   || sqlite3_stricmp(\"true\",z)==0\n   || (z[0]=='1' && z[1]==0)\n  ){\n    return 1;\n  }\n  if( ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/csv.c",
        "start": 421,
        "end": 443,
        "startLoc": {
          "line": 421,
          "column": 12,
          "position": 2953
        },
        "endLoc": {
          "line": 443,
          "column": 3,
          "position": 3115
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 130,
        "end": 161,
        "startLoc": {
          "line": 130,
          "column": 16,
          "position": 746
        },
        "endLoc": {
          "line": 161,
          "column": 3,
          "position": 909
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "  (void)(argv);    /* Unused parameter */\n  (void)(pzErr);   /* Unused parameter */\n\n/* Column numbers */\n#define COMPLETION_COLUMN_CANDIDATE 0  /* Suggested completion of the input */\n#define COMPLETION_COLUMN_PREFIX    1  /* Prefix of the word to be completed */\n#define COMPLETION_COLU",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/completion.c",
        "start": 128,
        "end": 141,
        "startLoc": {
          "line": 128,
          "column": 4,
          "position": 350
        },
        "endLoc": {
          "line": 141,
          "column": 3,
          "position": 448
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 203,
        "end": 106,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1283
        },
        "endLoc": {
          "line": 106,
          "column": 3,
          "position": 316
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "prepare_v2(pCur->db, \"PRAGMA database_list\", -1, &pS2, 0);\n          while( sqlite3_step(pS2)==SQLITE_ROW ){\n            const char *zDb = (const char*)sqlite3_column_text(pS2, 1);\n            zSql = sqlite3_mprintf(\n               \"%z%s\"\n               \"SELECT name FROM \\\"%w\\\".sqlite_schema\",\n               zSql, zSep, zDb\n            );\n            if( zSql==0 ) return SQLITE_NOMEM;\n            zSep = \" UNION \";\n          }\n          sql",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/completion.c",
        "start": 243,
        "end": 253,
        "startLoc": {
          "line": 243,
          "column": 19,
          "position": 1225
        },
        "endLoc": {
          "line": 253,
          "column": 50,
          "position": 1347
        }
      },
      "secondFile": {
        "name": "ext/misc/completion.c",
        "start": 219,
        "end": 229,
        "startLoc": {
          "line": 219,
          "column": 18,
          "position": 992
        },
        "endLoc": {
          "line": 229,
          "column": 40,
          "position": 1114
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "= 0;\n        eNextPhase = COMPLETION_COLUMNS;\n        break;\n      }\n      case COMPLETION_COLUMNS: {\n        if( pCur->pStmt==0 ){\n          sqlite3_stmt *pS2;\n          char *zSql = 0;\n          const char *zSep = \"\";\n          sqlite3_prepare_v2(pCur->db, \"PRAGMA database_list\", -1, &pS2, 0);\n      ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/completion.c",
        "start": 256,
        "end": 266,
        "startLoc": {
          "line": 256,
          "column": 4,
          "position": 1364
        },
        "endLoc": {
          "line": 266,
          "column": 15,
          "position": 1453
        }
      },
      "secondFile": {
        "name": "ext/misc/completion.c",
        "start": 230,
        "end": 240,
        "startLoc": {
          "line": 230,
          "column": 5,
          "position": 1122
        },
        "endLoc": {
          "line": 240,
          "column": 19,
          "position": 1211
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "2) */\n     && !p->inCkpt          /* (3) */\n    ){\n      u8 cksum[8];\n      cksmCompute((u8*)zBuf, iAmt-8, cksum);\n      if( memcmp((u8*)zBuf+iAmt-8, cksum, 8)!=0 ){\n        sqlite3_log(SQLITE_IOERR_DATA,\n           \"checksum fault offset %lld of \\\"%s\\\"\",\n           iOfst, p->zFName);\n        rc = SQLITE_IOERR_DATA;\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Write data to a cksm-file.\n*/\nstatic int cksmWrite(\n  sqlite3_file *pFile,\n  const void *zBuf,\n  int iAmt,\n  sqlite_int64 iOfst\n){\n  CksmFile *p = (CksmFile *)pFile;\n  pFile = ORIGFI",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/cksumvfs.c",
        "start": 474,
        "end": 486,
        "startLoc": {
          "line": 474,
          "column": 3,
          "position": 2352
        },
        "endLoc": {
          "line": 486,
          "column": 5,
          "position": 2446
        }
      },
      "secondFile": {
        "name": "ext/misc/cksumvfs.c",
        "start": 433,
        "end": 445,
        "startLoc": {
          "line": 433,
          "column": 5,
          "position": 2054
        },
        "endLoc": {
          "line": 445,
          "column": 7,
          "position": 2148
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "char *const*argv,\n  sqlite3_vtab **ppVtab,\n  char **pzErr\n){\n  sqlite3_vtab *pNew;\n  int rc;\n\n/* Column numbers */\n#define CARRAY_COLUMN_VALUE   0\n#define CARRAY_COLUMN_POINTER 1\n#define CARRAY_COLUMN_COUNT   2\n#define CARRAY_COLUMN_CTYPE  ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/carray.c",
        "start": 130,
        "end": 141,
        "startLoc": {
          "line": 130,
          "column": 65,
          "position": 269
        },
        "endLoc": {
          "line": 141,
          "column": 3,
          "position": 349
        }
      },
      "secondFile": {
        "name": "ext/misc/vfsstat.c",
        "start": 614,
        "end": 625,
        "startLoc": {
          "line": 614,
          "column": 34,
          "position": 4153
        },
        "endLoc": {
          "line": 625,
          "column": 3,
          "position": 4233
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "{\n  int i;                 /* Loop over constraints */\n  int ptrIdx = -1;       /* Index of the pointer= constraint, or -1 if none */\n  int cntIdx = -1;       /* Index of the count= constraint, or -1 if none */\n  int ctypeIdx = -1;     /* Index of the ctype= constraint",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/carray.c",
        "start": 321,
        "end": 326,
        "startLoc": {
          "line": 321,
          "column": 3,
          "position": 1593
        },
        "endLoc": {
          "line": 326,
          "column": 22,
          "position": 1670
        }
      },
      "secondFile": {
        "name": "ext/misc/completion.c",
        "start": 416,
        "end": 421,
        "startLoc": {
          "line": 416,
          "column": 3,
          "position": 2566
        },
        "endLoc": {
          "line": 421,
          "column": 25,
          "position": 2643
        }
      }
    },
    {
      "format": "c",
      "lines": 30,
      "fragment": "a, nData, sqlite3_free);\n  }\n}    \n\nstatic void writeblobFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3_blob *pBlob = 0;\n  const char *zSchema;\n  const char *zTable;\n  const char *zColumn;\n  sqlite3_int64 iRowid;\n  int iOfst;\n  unsigned char *aData;\n  int nData;\n  sqlite3 *db;\n  int rc;\n\n  zSchema = (const char*)sqlite3_value_text(argv[0]);\n  zTable = (const char*)sqlite3_value_text(argv[1]);\n  if( zTable==0 ){\n    sqlite3_result_error(context, \"bad table name\", -1);\n    return;\n  }\n  zColumn = (const char*)sqlite3_value_text(argv[2]);\n  if( zTable==0 ){\n    sqlite3_result_error(context, \"bad column name\", -1);\n    return;\n  }\n  iRowid = sqlite3_val",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/blobio.c",
        "start": 85,
        "end": 114,
        "startLoc": {
          "line": 85,
          "column": 14,
          "position": 504
        },
        "endLoc": {
          "line": 114,
          "column": 3,
          "position": 761
        }
      },
      "secondFile": {
        "name": "ext/misc/blobio.c",
        "start": 32,
        "end": 61,
        "startLoc": {
          "line": 32,
          "column": 13,
          "position": 13
        },
        "endLoc": {
          "line": 61,
          "column": 6,
          "position": 270
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "E ){\n    *(char**)pArg = sqlite3_mprintf(\"apnd(%lld)/%z\", paf->iPgOne,*(char**)pArg);\n  }\n  return rc;\n}\n\n/*\n** Return the sector-size in bytes for an apnd-file.\n*/\nstatic int apndSectorSize(sqlite3_file *pFile){\n  pFile = ORIGFILE(pFile);\n  return p",
      "tokens": 0,
      "firstFile": {
        "name": "ext/misc/appendvfs.c",
        "start": 381,
        "end": 393,
        "startLoc": {
          "line": 381,
          "column": 11,
          "position": 2239
        },
        "endLoc": {
          "line": 393,
          "column": 12,
          "position": 2319
        }
      },
      "secondFile": {
        "name": "ext/misc/cksumvfs.c",
        "start": 604,
        "end": 616,
        "startLoc": {
          "line": 604,
          "column": 11,
          "position": 3414
        },
        "endLoc": {
          "line": 616,
          "column": 12,
          "position": 3494
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "\n  prc = fstat(p->fd, &sStat);\n  if( prc==0 && sStat.st_size>nSize ){\n    prc = ftruncate(p->fd, (off_t)nSize);\n  }\n  if( prc<0 ) rc = LSM_IOERR_BKPT;\n\n  return rc;\n}\n\nstatic int lsmPosixOsRead(\n  lsm_f",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm_unix.c",
        "start": 153,
        "end": 162,
        "startLoc": {
          "line": 153,
          "column": 1,
          "position": 911
        },
        "endLoc": {
          "line": 162,
          "column": 5,
          "position": 1000
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm_unix.c",
        "start": 114,
        "end": 123,
        "startLoc": {
          "line": 114,
          "column": 1,
          "position": 576
        },
        "endLoc": {
          "line": 123,
          "column": 6,
          "position": 665
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "tart = (4096-iLock);\n\n  if( fcntl(p->fd, F_SETLK, &lock) ){\n    int e = errno;\n    if( e==EACCES || e==EAGAIN ){\n      rc = LSM_BUSY;\n    }else{\n      rc = LSM_IOERR_BKPT;\n    }\n  }\n\n  return rc;\n}\n\nstatic int lsmPosixOsTestLock(lsm_file *pFile, int iLock, ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/lsm1/lsm_unix.c",
        "start": 352,
        "end": 360,
        "startLoc": {
          "line": 352,
          "column": 2,
          "position": 2817
        },
        "endLoc": {
          "line": 360,
          "column": 6,
          "position": 2920
        }
      },
      "secondFile": {
        "name": "ext/lsm1/lsm_unix.c",
        "start": 322,
        "end": 330,
        "startLoc": {
          "line": 322,
          "column": 2,
          "position": 2494
        },
        "endLoc": {
          "line": 330,
          "column": 2,
          "position": 2597
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "bytes) of the pattern in a LIKE or GLOB\n** operator.\n*/\n#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH\n# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000\n#endif\n\n/*\n** Version of sqlite3_free() that is always a function, never a macro.\n*/\nstatic void xFree(void *p){\n  sqlite3_free(p);\n}\n\n/*\n** This lookup table is used to help decode the first byte of\n** a multi-byte UTF8 character. It is copied here from SQLite source\n** code file utf8.c.\n*/\nstatic const unsigned char icuUtf8Trans1[] = {\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x",
      "tokens": 0,
      "firstFile": {
        "name": "ext/icu/icu.c",
        "start": 88,
        "end": 108,
        "startLoc": {
          "line": 88,
          "column": 14,
          "position": 167
        },
        "endLoc": {
          "line": 108,
          "column": 3,
          "position": 383
        }
      },
      "secondFile": {
        "name": "ext/misc/nextchar.c",
        "start": 132,
        "end": 142,
        "startLoc": {
          "line": 132,
          "column": 10,
          "position": 721
        },
        "endLoc": {
          "line": 142,
          "column": 9,
          "position": 933
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": "umber of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */\n  char **pzErr                    /* OUT: sqlite3_malloc'd error message */\n){\n  return fts5VocabInitVtab(db, pAux, argc, argv, ppVtab, pzErr);\n}\nstatic int fts5VocabCreateMethod(\n  sqlite3 *db,                    /* Database connection */\n  void *pAux,                     /* Pointer to tokenizer hash table */\n  int argc,                       /* Number of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */\n  char **pzErr                    /* OUT: sqlite3_malloc'd error ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts5/fts5_vocab.c",
        "start": 240,
        "end": 262,
        "startLoc": {
          "line": 240,
          "column": 22,
          "position": 1283
        },
        "endLoc": {
          "line": 262,
          "column": 3,
          "position": 1375
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_vocab.c",
        "start": 230,
        "end": 240,
        "startLoc": {
          "line": 230,
          "column": 23,
          "position": 1187
        },
        "endLoc": {
          "line": 240,
          "column": 7,
          "position": 1278
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "pCsr->iCol++; pCsr->iCol<nCol; pCsr->iCol++){\n      if( pCsr->aDoc[pCsr->iCol] ) break;\n    }\n  }\n\n  if( pTab->eType!=FTS5_VOCAB_COL || pCsr->iCol>=nCol ){\n    if( sqlite3Fts5IterEof(pCsr->pIter) ){\n      pCsr->bEof = 1;\n    }else{\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts5/fts5_vocab.c",
        "start": 496,
        "end": 502,
        "startLoc": {
          "line": 496,
          "column": 2,
          "position": 3411
        },
        "endLoc": {
          "line": 502,
          "column": 7,
          "position": 3504
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_vocab.c",
        "start": 424,
        "end": 430,
        "startLoc": {
          "line": 424,
          "column": 6,
          "position": 2754
        },
        "endLoc": {
          "line": 430,
          "column": 2,
          "position": 2847
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "rn (h % nSlot);\n}\n\nstatic unsigned int fts5HashKey2(int nSlot, u8 b, const u8 *p, int n){\n  int i;\n  unsigned int h ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts5/fts5_hash.c",
        "start": 149,
        "end": 155,
        "startLoc": {
          "line": 149,
          "column": 2,
          "position": 760
        },
        "endLoc": {
          "line": 155,
          "column": 2,
          "position": 843
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_hash.c",
        "start": 140,
        "end": 146,
        "startLoc": {
          "line": 140,
          "column": 6,
          "position": 647
        },
        "endLoc": {
          "line": 146,
          "column": 7,
          "position": 730
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "ned, the buffer is left in an \n** undefined state.\n*/\nstatic int fts5Dequote(char *z){\n  char q;\n  int iIn = 1;\n  int iOut = 0;\n  q = z[0];\n\n  /* Set stack variable q to the close-quote character */\n  assert( q=='[' || q=='\\'' || q=='\"' || q=='`' );\n  if( q=='[' ) q = ']';  \n\n  while( z[iIn] ){\n    if( z[iIn]==q ){\n      if( z[iIn+1]!=q ){\n        /* Character iIn ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts5/fts5_config.c",
        "start": 150,
        "end": 162,
        "startLoc": {
          "line": 150,
          "column": 2,
          "position": 841
        },
        "endLoc": {
          "line": 162,
          "column": 36,
          "position": 922
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_test_tok.c",
        "start": 86,
        "end": 98,
        "startLoc": {
          "line": 86,
          "column": 2,
          "position": 238
        },
        "endLoc": {
          "line": 98,
          "column": 38,
          "position": 319
        }
      }
    },
    {
      "format": "c",
      "lines": 68,
      "fragment": "suls of passing a codepoint that corresponds to an\n** uppercase letter are undefined.\n*/\nstatic int remove_diacritic(int c, int bComplex){\n  unsigned short aDia[] = {\n        0,  1797,  1848,  1859,  1891,  1928,  1940,  1995, \n     2024,  2040,  2060,  2110,  2168,  2206,  2264,  2286, \n     2344,  2383,  2472,  2488,  2516,  2596,  2668,  2732, \n     2782,  2842,  2894,  2954,  2984,  3000,  3028,  3336, \n     3456,  3696,  3712,  3728,  3744,  3766,  3832,  3896, \n     3912,  3928,  3944,  3968,  4008,  4040,  4056,  4106, \n     4138,  4170,  4202,  4234,  4266,  4296,  4312,  4344, \n     4408,  4424,  4442,  4472,  4488,  4504,  6148,  6198, \n     6264,  6280,  6360,  6429,  6505,  6529, 61448, 61468, \n    61512, 61534, 61592, 61610, 61642, 61672, 61688, 61704, \n    61726, 61784, 61800, 61816, 61836, 61880, 61896, 61914, \n    61948, 61998, 62062, 62122, 62154, 62184, 62200, 62218, \n    62252, 62302, 62364, 62410, 62442, 62478, 62536, 62554, \n    62584, 62604, 62640, 62648, 62656, 62664, 62730, 62766, \n    62830, 62890, 62924, 62974, 63032, 63050, 63082, 63118, \n    63182, 63242, 63274, 63310, 63368, 63390, \n  };\n#define HIBIT ((unsigned char)0x80)\n  unsigned char aChar[] = {\n    '\\0',      'a',       'c',       'e',       'i',       'n',       \n    'o',       'u',       'y',       'y',       'a',       'c',       \n    'd',       'e',       'e',       'g',       'h',       'i',       \n    'j',       'k',       'l',       'n',       'o',       'r',       \n    's',       't',       'u',       'u',       'w',       'y',       \n    'z',       'o',       'u',       'a',       'i',       'o',       \n    'u',       'u'|HIBIT, 'a'|HIBIT, 'g',       'k',       'o',       \n    'o'|HIBIT, 'j',       'g',       'n',       'a'|HIBIT, 'a',       \n    'e',       'i',       'o',       'r',       'u',       's',       \n    't',       'h',       'a',       'e',       'o'|HIBIT, 'o',       \n    'o'|HIBIT, 'y',       '\\0',      '\\0',      '\\0',      '\\0',      \n    '\\0',      '\\0',      '\\0',      '\\0',      'a',       'b',       \n    'c'|HIBIT, 'd',       'd',       'e'|HIBIT, 'e',       'e'|HIBIT, \n    'f',       'g',       'h',       'h',       'i',       'i'|HIBIT, \n    'k',       'l',       'l'|HIBIT, 'l',       'm',       'n',       \n    'o'|HIBIT, 'p',       'r',       'r'|HIBIT, 'r',       's',       \n    's'|HIBIT, 't',       'u',       'u'|HIBIT, 'v',       'w',       \n    'w',       'x',       'y',       'z',       'h',       't',       \n    'w',       'y',       'a',       'a'|HIBIT, 'a'|HIBIT, 'a'|HIBIT, \n    'e',       'e'|HIBIT, 'e'|HIBIT, 'i',       'o',       'o'|HIBIT, \n    'o'|HIBIT, 'o'|HIBIT, 'u',       'u'|HIBIT, 'u'|HIBIT, 'y',       \n  };\n\n  unsigned int key = (((unsigned int)c)<<3) | 0x00000007;\n  int iRes = 0;\n  int iHi = sizeof(aDia)/sizeof(aDia[0]) - 1;\n  int iLo = 0;\n  while( iHi>=iLo ){\n    int iTest = (iHi + iLo) / 2;\n    if( key >= aDia[iTest] ){\n      iRes = iTest;\n      iLo = iTest+1;\n    }else{\n      iHi = iTest-1;\n    }\n  }\n  assert( key>=aDia[iRes] );\n  if( bComplex==0 && (aChar[iRes] & 0x80) ) return c;\n  return (c > (aDia[iRes]>>3) + (aDia[iRes]&0x07)) ? c : ((int)aChar[iRes] & 0x7F",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_unicode2.c",
        "start": 162,
        "end": 229,
        "startLoc": {
          "line": 162,
          "column": 17,
          "position": 1709
        },
        "endLoc": {
          "line": 229,
          "column": 29,
          "position": 2895
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_unicode2.c",
        "start": 31,
        "end": 98,
        "startLoc": {
          "line": 31,
          "column": 22,
          "position": 18
        },
        "endLoc": {
          "line": 98,
          "column": 30,
          "position": 1204
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": ");\n}\n\n\n/*\n** Return true if the argument interpreted as a unicode codepoint\n** is a diacritical modifier character.\n*/\nint sqlite3FtsUnicodeIsdiacritic(int c){\n  unsigned int mask0 = 0x08029FDF;\n  unsigned int mask1 = 0x000361F8;\n  if( c<768 || c>817 ) return 0;\n  return (c < 768+32) ?\n      (mask0 & ((unsigned int)1 << (c-768))) :\n      (mask1 & ((unsigned int)1 << (c-768-32)));\n}\n\n\n/*\n** Interpret the argument as a unicode codepoint. If the codepoint\n** is an upper case character that has a lower case equivalent,\n** return the codepoint corresponding to the lower case version.\n** Otherwise,",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_unicode2.c",
        "start": 229,
        "end": 248,
        "startLoc": {
          "line": 229,
          "column": 29,
          "position": 2896
        },
        "endLoc": {
          "line": 248,
          "column": 22,
          "position": 3024
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_unicode2.c",
        "start": 98,
        "end": 117,
        "startLoc": {
          "line": 98,
          "column": 30,
          "position": 1205
        },
        "endLoc": {
          "line": 117,
          "column": 23,
          "position": 1333
        }
      }
    },
    {
      "format": "c",
      "lines": 125,
      "fragment": " return a copy of the argument.\n**\n** The results are undefined if the value passed to this function\n** is less than zero.\n*/\nint sqlite3FtsUnicodeFold(int c, int eRemoveDiacritic){\n  /* Each entry in the following array defines a rule for folding a range\n  ** of codepoints to lower case. The rule applies to a range of nRange\n  ** codepoints starting at codepoint iCode.\n  **\n  ** If the least significant bit in flags is clear, then the rule applies\n  ** to all nRange codepoints (i.e. all nRange codepoints are upper case and\n  ** need to be folded). Or, if it is set, then the rule only applies to\n  ** every second codepoint in the range, starting with codepoint C.\n  **\n  ** The 7 most significant bits in flags are an index into the aiOff[]\n  ** array. If a specific codepoint C does require folding, then its lower\n  ** case equivalent is ((C + aiOff[flags>>1]) & 0xFFFF).\n  **\n  ** The contents of this array are generated by parsing the CaseFolding.txt\n  ** file distributed as part of the \"Unicode Character Database\". See\n  ** http://www.unicode.org for details.\n  */\n  static const struct TableEntry {\n    unsigned short iCode;\n    unsigned char flags;\n    unsigned char nRange;\n  } aEntry[] = {\n    {65, 14, 26},          {181, 64, 1},          {192, 14, 23},\n    {216, 14, 7},          {256, 1, 48},          {306, 1, 6},\n    {313, 1, 16},          {330, 1, 46},          {376, 116, 1},\n    {377, 1, 6},           {383, 104, 1},         {385, 50, 1},\n    {386, 1, 4},           {390, 44, 1},          {391, 0, 1},\n    {393, 42, 2},          {395, 0, 1},           {398, 32, 1},\n    {399, 38, 1},          {400, 40, 1},          {401, 0, 1},\n    {403, 42, 1},          {404, 46, 1},          {406, 52, 1},\n    {407, 48, 1},          {408, 0, 1},           {412, 52, 1},\n    {413, 54, 1},          {415, 56, 1},          {416, 1, 6},\n    {422, 60, 1},          {423, 0, 1},           {425, 60, 1},\n    {428, 0, 1},           {430, 60, 1},          {431, 0, 1},\n    {433, 58, 2},          {435, 1, 4},           {439, 62, 1},\n    {440, 0, 1},           {444, 0, 1},           {452, 2, 1},\n    {453, 0, 1},           {455, 2, 1},           {456, 0, 1},\n    {458, 2, 1},           {459, 1, 18},          {478, 1, 18},\n    {497, 2, 1},           {498, 1, 4},           {502, 122, 1},\n    {503, 134, 1},         {504, 1, 40},          {544, 110, 1},\n    {546, 1, 18},          {570, 70, 1},          {571, 0, 1},\n    {573, 108, 1},         {574, 68, 1},          {577, 0, 1},\n    {579, 106, 1},         {580, 28, 1},          {581, 30, 1},\n    {582, 1, 10},          {837, 36, 1},          {880, 1, 4},\n    {886, 0, 1},           {902, 18, 1},          {904, 16, 3},\n    {908, 26, 1},          {910, 24, 2},          {913, 14, 17},\n    {931, 14, 9},          {962, 0, 1},           {975, 4, 1},\n    {976, 140, 1},         {977, 142, 1},         {981, 146, 1},\n    {982, 144, 1},         {984, 1, 24},          {1008, 136, 1},\n    {1009, 138, 1},        {1012, 130, 1},        {1013, 128, 1},\n    {1015, 0, 1},          {1017, 152, 1},        {1018, 0, 1},\n    {1021, 110, 3},        {1024, 34, 16},        {1040, 14, 32},\n    {1120, 1, 34},         {1162, 1, 54},         {1216, 6, 1},\n    {1217, 1, 14},         {1232, 1, 88},         {1329, 22, 38},\n    {4256, 66, 38},        {4295, 66, 1},         {4301, 66, 1},\n    {7680, 1, 150},        {7835, 132, 1},        {7838, 96, 1},\n    {7840, 1, 96},         {7944, 150, 8},        {7960, 150, 6},\n    {7976, 150, 8},        {7992, 150, 8},        {8008, 150, 6},\n    {8025, 151, 8},        {8040, 150, 8},        {8072, 150, 8},\n    {8088, 150, 8},        {8104, 150, 8},        {8120, 150, 2},\n    {8122, 126, 2},        {8124, 148, 1},        {8126, 100, 1},\n    {8136, 124, 4},        {8140, 148, 1},        {8152, 150, 2},\n    {8154, 120, 2},        {8168, 150, 2},        {8170, 118, 2},\n    {8172, 152, 1},        {8184, 112, 2},        {8186, 114, 2},\n    {8188, 148, 1},        {8486, 98, 1},         {8490, 92, 1},\n    {8491, 94, 1},         {8498, 12, 1},         {8544, 8, 16},\n    {8579, 0, 1},          {9398, 10, 26},        {11264, 22, 47},\n    {11360, 0, 1},         {11362, 88, 1},        {11363, 102, 1},\n    {11364, 90, 1},        {11367, 1, 6},         {11373, 84, 1},\n    {11374, 86, 1},        {11375, 80, 1},        {11376, 82, 1},\n    {11378, 0, 1},         {11381, 0, 1},         {11390, 78, 2},\n    {11392, 1, 100},       {11499, 1, 4},         {11506, 0, 1},\n    {42560, 1, 46},        {42624, 1, 24},        {42786, 1, 14},\n    {42802, 1, 62},        {42873, 1, 4},         {42877, 76, 1},\n    {42878, 1, 10},        {42891, 0, 1},         {42893, 74, 1},\n    {42896, 1, 4},         {42912, 1, 10},        {42922, 72, 1},\n    {65313, 14, 26},       \n  };\n  static const unsigned short aiOff[] = {\n   1,     2,     8,     15,    16,    26,    28,    32,    \n   37,    38,    40,    48,    63,    64,    69,    71,    \n   79,    80,    116,   202,   203,   205,   206,   207,   \n   209,   210,   211,   213,   214,   217,   218,   219,   \n   775,   7264,  10792, 10795, 23228, 23256, 30204, 54721, \n   54753, 54754, 54756, 54787, 54793, 54809, 57153, 57274, \n   57921, 58019, 58363, 61722, 65268, 65341, 65373, 65406, \n   65408, 65410, 65415, 65424, 65436, 65439, 65450, 65462, \n   65472, 65476, 65478, 65480, 65482, 65488, 65506, 65511, \n   65514, 65521, 65527, 65528, 65529, \n  };\n\n  int ret = c;\n\n  assert( sizeof(unsigned short)==2 && sizeof(unsigned char)==1 );\n\n  if( c<128 ){\n    if( c>='A' && c<='Z' ) ret = c + ('a' - 'A');\n  }else if( c<65536 ){\n    const struct TableEntry *p;\n    int iHi = sizeof(aEntry)/sizeof(aEntry[0]) - 1;\n    int iLo = 0;\n    int iRes = -1;\n\n    assert( c>aEntry[0].iCode );\n    while( iHi>=iLo ){\n      int iTest = (iHi + iLo) / 2;\n      int cmp = (c - aEntry[iTest].iCode);\n      if( cmp>=0 ){\n        iRes = iTest;\n        iLo = iTest+1;\n      }else{\n        iHi = iTest-1;\n      }\n    }\n\n    assert( iRes>=0 && c>=aEntry[iRes].iCode );\n    p = &aEntry[iRes];\n    if( c<(p->iCode + p->nRange) && 0==(0x01 & p->flags & (p->iCo",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_unicode2.c",
        "start": 248,
        "end": 372,
        "startLoc": {
          "line": 248,
          "column": 22,
          "position": 3025
        },
        "endLoc": {
          "line": 372,
          "column": 17,
          "position": 5623
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_unicode2.c",
        "start": 117,
        "end": 241,
        "startLoc": {
          "line": 117,
          "column": 23,
          "position": 1334
        },
        "endLoc": {
          "line": 241,
          "column": 22,
          "position": 3932
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": " READ_UTF8 and WRITE_UTF8 - have been copied\n** from the sqlite3 source file utf.c. If this file is compiled as part\n** of the amalgamation, they are not required.\n*/\n#ifndef SQLITE_AMALGAMATION\n\nstatic const unsigned char sqlite3Utf8Trans1[] = {\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_unicode.c",
        "start": 35,
        "end": 50,
        "startLoc": {
          "line": 35,
          "column": 18,
          "position": 28
        },
        "endLoc": {
          "line": 50,
          "column": 33,
          "position": 243
        }
      },
      "secondFile": {
        "name": "ext/misc/nextchar.c",
        "start": 132,
        "end": 142,
        "startLoc": {
          "line": 132,
          "column": 10,
          "position": 721
        },
        "endLoc": {
          "line": 142,
          "column": 9,
          "position": 933
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": "r code is returned.\n** The final value of *pazDequote is undefined in this case.\n*/\nstatic int fts3tokDequoteArray(\n  int argc,                       /* Number of elements in argv[] */\n  const char * const *argv,       /* Input array */\n  char ***pazDequote              /* Output array */\n){\n  int rc = SQLITE_OK;             /* Return code */\n  if( argc==0 ){\n    *pazDequote = 0;\n  }else{\n    int i;\n    int nByte = 0;\n    char **azDequote;\n\n    for(i=0; i<argc; i++){\n      nByte += (int)(strlen(argv[i]) + 1);\n    }\n\n    *pazDequote = azDequote = sqlite3_malloc64(sizeof(char *)*argc + nByte);\n    if( azDequote==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      char *pSpace = (char *)&azDequote[argc];\n      for(i=0; i<argc; i++){\n        int n = (in",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_tokenize_vtab.c",
        "start": 108,
        "end": 134,
        "startLoc": {
          "line": 108,
          "column": 20,
          "position": 303
        },
        "endLoc": {
          "line": 134,
          "column": 19,
          "position": 587
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_test_tok.c",
        "start": 123,
        "end": 149,
        "startLoc": {
          "line": 123,
          "column": 20,
          "position": 397
        },
        "endLoc": {
          "line": 149,
          "column": 15,
          "position": 681
        }
      }
    },
    {
      "format": "c",
      "lines": 25,
      "fragment": "OK;\n}\n\n/*\n** xBestIndex - Analyze a WHERE and ORDER BY clause.\n*/\nstatic int fts3tokBestIndexMethod(\n  sqlite3_vtab *pVTab, \n  sqlite3_index_info *pInfo\n){\n  int i;\n  UNUSED_PARAMETER(pVTab);\n\n  for(i=0; i<pInfo->nConstraint; i++){\n    if( pInfo->aConstraint[i].usable \n     && pInfo->aConstraint[i].iColumn==0 \n     && pInfo->aConstraint[i].op==SQLITE_INDEX_CONSTRAINT_EQ \n    ){\n      pInfo->idxNum = 1;\n      pInfo->aConstraintUsage[i].argvIndex = 1;\n      pInfo->aConstraintUsage[i].omit = 1;\n      pInfo->estimatedCost",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_tokenize_vtab.c",
        "start": 239,
        "end": 263,
        "startLoc": {
          "line": 239,
          "column": 2,
          "position": 1287
        },
        "endLoc": {
          "line": 263,
          "column": 18,
          "position": 1460
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_test_tok.c",
        "start": 251,
        "end": 275,
        "startLoc": {
          "line": 251,
          "column": 2,
          "position": 1347
        },
        "endLoc": {
          "line": 275,
          "column": 18,
          "position": 1520
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "okResetCursor(pCsr);\n  if( idxNum==1 ){\n    const char *zByte = (const char *)sqlite3_value_text(apVal[0]);\n    int nByte = sqlite3_value_bytes(apVal[0]);\n    pCsr->zInput = sqlite3_",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_tokenize_vtab.c",
        "start": 350,
        "end": 356,
        "startLoc": {
          "line": 350,
          "column": 17,
          "position": 2134
        },
        "endLoc": {
          "line": 356,
          "column": 5,
          "position": 2211
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_test_tok.c",
        "start": 377,
        "end": 383,
        "startLoc": {
          "line": 377,
          "column": 15,
          "position": 2402
        },
        "endLoc": {
          "line": 383,
          "column": 4,
          "position": 2479
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return j;\n  return z[1",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 159,
        "end": 165,
        "startLoc": {
          "line": 159,
          "column": 8,
          "position": 814
        },
        "endLoc": {
          "line": 165,
          "column": 2,
          "position": 898
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 150,
        "end": 156,
        "startLoc": {
          "line": 150,
          "column": 12,
          "position": 698
        },
        "endLoc": {
          "line": 156,
          "column": 2,
          "position": 782
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": " }\n  if( *z==0 ) return 1;\n  while( isConsonant(z) ){ z++; }\n  return *z==0;\n}\n\n/* Like mgt0 above except we are looking for a value of m>1 instead\n** or m>0\n*/\nstatic int m_gt_1(co",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 212,
        "end": 218,
        "startLoc": {
          "line": 212,
          "column": 7,
          "position": 1156
        },
        "endLoc": {
          "line": 218,
          "column": 2,
          "position": 1265
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 198,
        "end": 204,
        "startLoc": {
          "line": 198,
          "column": 7,
          "position": 1007
        },
        "endLoc": {
          "line": 204,
          "column": 2,
          "position": 1116
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": " a token.  In other words, delimiters all must have\n** values of 0x7f or lower.\n*/\nstatic const char porterIdChar[] = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 4x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  /* 5x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 6x */\n    1, 1, 1, 1, 1,",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 582,
        "end": 593,
        "startLoc": {
          "line": 582,
          "column": 5,
          "position": 4291
        },
        "endLoc": {
          "line": 593,
          "column": 3,
          "position": 4550
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer.c",
        "start": 119,
        "end": 125,
        "startLoc": {
          "line": 119,
          "column": 7,
          "position": 729
        },
        "endLoc": {
          "line": 125,
          "column": 7,
          "position": 988
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "of their own, so xConnect\n** and xCreate are identical operations.\n*/\nstatic int fts3auxConnectMethod(\n  sqlite3 *db,                    /* Database connection */\n  void *pUnused,                  /* Unused */\n  int argc,                       /* Number of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */\n  char **pzErr                    /* OUT: sqlite3_malloc'd error message */\n){\n  char const *zDb;                /* Name of database (e.g. \"main\") */\n  char const *zFts3;              /* Name of fts3 table */\n  int nDb;                        /* Result of strlen(zDb) */\n  int nFts3",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_aux.c",
        "start": 59,
        "end": 70,
        "startLoc": {
          "line": 59,
          "column": 3,
          "position": 202
        },
        "endLoc": {
          "line": 70,
          "column": 13,
          "position": 301
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_term.c",
        "start": 62,
        "end": 73,
        "startLoc": {
          "line": 62,
          "column": 3,
          "position": 176
        },
        "endLoc": {
          "line": 73,
          "column": 14,
          "position": 275
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "_AUX_SCHEMA);\n  if( rc!=SQLITE_OK ) return rc;\n\n  nByte = sizeof(Fts3auxTable) + sizeof(Fts3Table) + nDb + nFts3 + 2;\n  p = (Fts3auxTable *)sqlite3_malloc64(nByte);\n  if( !p ) return SQLITE",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_aux.c",
        "start": 102,
        "end": 108,
        "startLoc": {
          "line": 102,
          "column": 2,
          "position": 590
        },
        "endLoc": {
          "line": 108,
          "column": 2,
          "position": 680
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_term.c",
        "start": 101,
        "end": 107,
        "startLoc": {
          "line": 101,
          "column": 2,
          "position": 526
        },
        "endLoc": {
          "line": 107,
          "column": 7,
          "position": 616
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "_NOMEM;\n  memset(p, 0, nByte);\n\n  p->pFts3Tab = (Fts3Table *)&p[1];\n  p->pFts3Tab->zDb = (char *)&p->pFts3Tab[1];\n  p->pFts3Tab->zName = &p->pFts3Tab->zDb[nDb+1];\n  p->pFts3Tab->db = db;\n  p->pFts3Tab->nIndex = 1;",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_aux.c",
        "start": 108,
        "end": 117,
        "startLoc": {
          "line": 108,
          "column": 2,
          "position": 681
        },
        "endLoc": {
          "line": 117,
          "column": 9,
          "position": 767
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_term.c",
        "start": 108,
        "end": 116,
        "startLoc": {
          "line": 108,
          "column": 7,
          "position": 629
        },
        "endLoc": {
          "line": 116,
          "column": 2,
          "position": 713
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "These tables have no persistent representation of their own, so xDisconnect\n** and xDestroy are identical operations.\n*/\nstatic int fts3auxDisconnectMethod(sqlite3_vtab *pVtab){\n  Fts3auxTable *p = (Fts3auxTable *)pVtab;\n  Fts3Table *pFts3 = p->pFts3Tab;\n  int i;\n\n  /* Free any prepared statements held */\n  for(i=0; i<SizeofArray(pFts3->aStmt); i++){\n    sq",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts3/fts3_aux.c",
        "start": 128,
        "end": 148,
        "startLoc": {
          "line": 128,
          "column": 2,
          "position": 815
        },
        "endLoc": {
          "line": 148,
          "column": 23,
          "position": 916
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_term.c",
        "start": 124,
        "end": 144,
        "startLoc": {
          "line": 124,
          "column": 2,
          "position": 742
        },
        "endLoc": {
          "line": 144,
          "column": 24,
          "position": 843
        }
      }
    },
    {
      "format": "tcl",
      "lines": 6,
      "fragment": "w]\nset today [clock format [clock seconds] -format \"%Y-%m-%d %H:%M:%S UTC\" -gmt 1]\nputs $out [subst \\\n{/******************************************************************************\n** This file is an amalgamation of separate C source files from the SQLite\n** Full Text Search extension 2 (fts2",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/mkfts2amal.tcl",
        "start": 24,
        "end": 29,
        "startLoc": {
          "line": 24,
          "column": 2,
          "position": 54
        },
        "endLoc": {
          "line": 29,
          "column": 5,
          "position": 176
        }
      },
      "secondFile": {
        "name": "ext/fts3/mkfts3amal.tcl",
        "start": 24,
        "end": 29,
        "startLoc": {
          "line": 24,
          "column": 2,
          "position": 54
        },
        "endLoc": {
          "line": 29,
          "column": 5,
          "position": 176
        }
      }
    },
    {
      "format": "tcl",
      "lines": 10,
      "fragment": ").  By combining all the individual C \n** code  files into this single large file, the entire code can be compiled \n** as a one translation unit.  This allows many compilers to do optimizations\n** that would not be possible if the files were compiled separately.  It also\n** makes the code easier to import into other projects.\n**\n** This amalgamation was generated on $today.\n*/}]\n\n# These are the header files used by FTS2.  The first time any of these ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/mkfts2amal.tcl",
        "start": 29,
        "end": 38,
        "startLoc": {
          "line": 29,
          "column": 5,
          "position": 177
        },
        "endLoc": {
          "line": 38,
          "column": 73,
          "position": 320
        }
      },
      "secondFile": {
        "name": "ext/fts3/mkfts3amal.tcl",
        "start": 29,
        "end": 38,
        "startLoc": {
          "line": 29,
          "column": 5,
          "position": 177
        },
        "endLoc": {
          "line": 38,
          "column": 73,
          "position": 320
        }
      }
    },
    {
      "format": "tcl",
      "lines": 61,
      "fragment": "sqlite3.h\n   sqlite3ext.h\n} {\n  set available_hdr($hdr) 1\n}\n\n# 78 stars used for comment formatting.\nset s78 \\\n{*****************************************************************************}\n\n# Insert a comment into the code\n#\nproc section_comment {text} {\n  global out s78\n  set n [string length $text]\n  set nstar [expr {60 - $n}]\n  set stars [string range $s78 0 $nstar]\n  puts $out \"/************** $text $stars/\"\n}\n\n# Read the source file named $filename and write it into the\n# sqlite3.c output file.  If any #include statements are seen,\n# process them approprately.\n#\nproc copy_file {filename} {\n  global seen_hdr available_hdr out\n  set tail [file tail $filename]\n  section_comment \"Begin file $tail\"\n  set in [open $filename r]\n  while {![eof $in]} {\n    set line [gets $in]\n    if {[regexp {^#\\s*include\\s+[\"<]([^\">]+)[\">]} $line all hdr]} {\n      if {[info exists available_hdr($hdr)]} {\n        if {$available_hdr($hdr)} {\n          section_comment \"Include $hdr in the middle of $tail\"\n          copy_file tsrc/$hdr\n          section_comment \"Continuing where we left off in $tail\"\n        }\n      } elseif {![info exists seen_hdr($hdr)]} {\n        set seen_hdr($hdr) 1\n        puts $out $line\n      }\n    } elseif {[regexp {^#ifdef __cplusplus} $line]} {\n      puts $out \"#if 0\"\n    } elseif {[regexp {^#line} $line]} {\n      # Skip #line directives.\n    } else {\n      puts $out $line\n    }\n  }\n  close $in\n  section_comment \"End of $tail\"\n}\n\n\n# Process the source files.  Process files containing commonly\n# used subroutines first in order to help the compiler find\n# inlining opportunities.\n#\nforeach file {\n   fts2.c",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/mkfts2amal.tcl",
        "start": 46,
        "end": 106,
        "startLoc": {
          "line": 46,
          "column": 4,
          "position": 344
        },
        "endLoc": {
          "line": 106,
          "column": 7,
          "position": 787
        }
      },
      "secondFile": {
        "name": "ext/fts3/mkfts3amal.tcl",
        "start": 46,
        "end": 106,
        "startLoc": {
          "line": 46,
          "column": 4,
          "position": 344
        },
        "endLoc": {
          "line": 106,
          "column": 7,
          "position": 787
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "d(SQLITE_ENABLE_FTS2)\n\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include \"sqlite3.h\"\n#include \"sqlite3ext.h\"\nSQLITE_EXTENSION_INIT3\n#include \"fts2_tokenizer.h\"\n\ntypedef struct simple_tokenizer {\n  sqlite3_tokenizer base;\n  char delim[128];             /* flag ASCII delimiters */\n} simple_tokenizer;\n\ntypedef struct simple_tokenizer_cursor {\n  sqlite3_tokenizer_cursor base;\n  const char *pInput;          /* input we are tokenizing */\n  int nBytes;                  /* size of the input */\n  int iOffset;                 /* current position in pInput */\n  int iToken;                  /* index of next token to b",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 38,
        "end": 54,
        "startLoc": {
          "line": 38,
          "column": 1,
          "position": 19
        },
        "endLoc": {
          "line": 54,
          "column": 26,
          "position": 123
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 35,
        "end": 51,
        "startLoc": {
          "line": 35,
          "column": 1,
          "position": 15
        },
        "endLoc": {
          "line": 51,
          "column": 7,
          "position": 119
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": "_tokenizer_cursor;\n\n\n/* Forward declaration */\nstatic const sqlite3_tokenizer_module simpleTokenizerModule;\n\nstatic int simpleDelim(simple_tokenizer *t, unsigned char c){\n  return c<0x80 && t->delim[c];\n}\n\n/*\n** Create a new tokenizer instance.\n*/\nstatic int simpleCreate(\n  int argc, const char * const *argv,\n  sqlite3_tokenizer **ppTokenizer\n){\n  simple_tokenizer *t;\n\n  t = (simple_tokenizer *) sqlite3_malloc(sizeof(*t));\n  if( t==NULL ) return SQLITE_NOMEM;\n  memset(t, 0, sizeof(*t));\n\n  /* TODO(shess) Delimiters need to remain the same from run to run,\n  ** else we need to",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 58,
        "end": 80,
        "startLoc": {
          "line": 58,
          "column": 2,
          "position": 170
        },
        "endLoc": {
          "line": 80,
          "column": 7,
          "position": 298
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 55,
        "end": 77,
        "startLoc": {
          "line": 55,
          "column": 2,
          "position": 212
        },
        "endLoc": {
          "line": 77,
          "column": 2,
          "position": 340
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "eed to reindex.  One solution would be a meta-table to\n  ** track such information in the database, then we'd only want this\n  ** information on the initial create.\n  */\n  if( argc>1 ){\n    int i, n = strlen(argv[1]);\n    for(i=0; i<n; i++){\n      unsigned char ch = argv[1][i];\n      /* We explicitly don't support UTF-8 delimiters for now. */\n      if( ch>=0x80 ){\n        sqlite3_free(t);\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 80,
        "end": 94,
        "startLoc": {
          "line": 80,
          "column": 2,
          "position": 298
        },
        "endLoc": {
          "line": 94,
          "column": 2,
          "position": 434
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 77,
        "end": 91,
        "startLoc": {
          "line": 77,
          "column": 2,
          "position": 343
        },
        "endLoc": {
          "line": 91,
          "column": 13,
          "position": 479
        }
      }
    },
    {
      "format": "c",
      "lines": 30,
      "fragment": "Mark non-alphanumeric ASCII characters as delimiters */\n    int i;\n    for(i=1; i<0x80; i++){\n      t->delim[i] = !((i>='0' && i<='9') || (i>='A' && i<='Z') ||\n                      (i>='a' && i<='z'));\n    }\n  }\n\n  *ppTokenizer = &t->base;\n  return SQLITE_OK;\n}\n\n/*\n** Destroy a tokenizer\n*/\nstatic int simpleDestroy(sqlite3_tokenizer *pTokenizer){\n  sqlite3_free(pTokenizer);\n  return SQLITE_OK;\n}\n\n/*\n** Prepare to begin tokenizing a particular string.  The input\n** string to be tokenized is pInput[0..nBytes-1].  A cursor\n** used to incrementally tokenize this string is returned in \n** *ppCursor.\n*/\nstatic int simpleOpen(\n  sqlite3_tokenizer *pTokenizer,       ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 95,
        "end": 124,
        "startLoc": {
          "line": 95,
          "column": 2,
          "position": 476
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 592
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 91,
        "end": 120,
        "startLoc": {
          "line": 91,
          "column": 2,
          "position": 492
        },
        "endLoc": {
          "line": 120,
          "column": 17,
          "position": 608
        }
      }
    },
    {
      "format": "c",
      "lines": 67,
      "fragment": "        /* The tokenizer */\n  const char *pInput, int nBytes,        /* String to be tokenized */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  simple_tokenizer_cursor *c;\n\n  c = (simple_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));\n  if( c==NULL ) return SQLITE_NOMEM;\n\n  c->pInput = pInput;\n  if( pInput==0 ){\n    c->nBytes = 0;\n  }else if( nBytes<0 ){\n    c->nBytes = (int)strlen(pInput);\n  }else{\n    c->nBytes = nBytes;\n  }\n  c->iOffset = 0;                 /* start tokenizing at the beginning */\n  c->iToken = 0;\n  c->pToken = NULL;               /* no space allocated, yet. */\n  c->nTokenAllocated = 0;\n\n  *ppCursor = &c->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously opened by a call to\n** simpleOpen() above.\n*/\nstatic int simpleClose(sqlite3_tokenizer_cursor *pCursor){\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  sqlite3_free(c->pToken);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}\n\n/*\n** Extract the next token from a tokenization cursor.  The cursor must\n** have been opened by a prior call to simpleOpen().\n*/\nstatic int simpleNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by simpleOpen */\n  const char **ppToken,               /* OUT: *ppToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;\n  unsigned char *p = (unsigned char *)c->pInput;\n\n  while( c->iOffset<c->nBytes ){\n    int iStartOffset;\n\n    /* Scan past delimiter characters */\n    while( c->iOffset<c->nBytes && simpleDelim(t, p[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    /* Count non-delimiter characters. */\n    iStartOffset = c->iOffset;\n    while( c->i",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 122,
        "end": 188,
        "startLoc": {
          "line": 122,
          "column": 2,
          "position": 588
        },
        "endLoc": {
          "line": 188,
          "column": 2,
          "position": 1122
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 120,
        "end": 186,
        "startLoc": {
          "line": 120,
          "column": 2,
          "position": 612
        },
        "endLoc": {
          "line": 186,
          "column": 5,
          "position": 1146
        }
      }
    },
    {
      "format": "c",
      "lines": 25,
      "fragment": "O(shess) This needs expansion to handle UTF-8\n        ** case-insensitivity.\n        */\n        unsigned char ch = p[iStartOffset+i];\n        c->pToken[i] = (ch>='A' && ch<='Z') ? (ch - 'A' + 'a') : ch;\n      }\n      *ppToken = c->pToken;\n      *pnBytes = n;\n      *piStartOffset = iStartOffset;\n      *piEndOffset = c->iOffset;\n      *piPosition = c->iToken++;\n\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_DONE;\n}\n\n/*\n** The ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 197,
        "end": 221,
        "startLoc": {
          "line": 197,
          "column": 3,
          "position": 1250
        },
        "endLoc": {
          "line": 221,
          "column": 2,
          "position": 1367
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 197,
        "end": 221,
        "startLoc": {
          "line": 197,
          "column": 2,
          "position": 1285
        },
        "endLoc": {
          "line": 221,
          "column": 2,
          "position": 1403
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "0;\n  sqlite3_tokenizer_cursor *pCsr = 0;\n\n  const char *zErr = 0;\n\n  const char *zName;\n  int nName;\n  const char *zInput;\n  int nInput;\n\n  const char *zArg = 0;\n\n  const char *zToken;\n  int nToken;\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer.c",
        "start": 164,
        "end": 169,
        "startLoc": {
          "line": 164,
          "column": 3,
          "position": 605
        },
        "endLoc": {
          "line": 169,
          "column": 3,
          "position": 680
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer.c",
        "start": 294,
        "end": 299,
        "startLoc": {
          "line": 294,
          "column": 3,
          "position": 2173
        },
        "endLoc": {
          "line": 299,
          "column": 6,
          "position": 2248
        }
      }
    },
    {
      "format": "c",
      "lines": 35,
      "fragment": "QLITE_OK!=p->xCreate(zArg ? 1 : 0, &zArg, &pTokenizer) ){\n    zErr = \"error in xCreate()\";\n    goto finish;\n  }\n  pTokenizer->pModule = p;\n  if( SQLITE_OK!=p->xOpen(pTokenizer, zInput, nInput, &pCsr) ){\n    zErr = \"error in xOpen()\";\n    goto finish;\n  }\n  pCsr->pTokenizer = pTokenizer;\n\n  while( SQLITE_OK==p->xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos) ){\n    Tcl_ListObjAppendElement(0, pRet, Tcl_NewIntObj(iPos));\n    Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));\n    zToken = &zInput[iStart];\n    nToken = iEnd-iStart;\n    Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));\n  }\n\n  if( SQLITE_OK!=p->xClose(pCsr) ){\n    zErr = \"error in xClose()\";\n    goto finish;\n  }\n  if( SQLITE_OK!=p->xDestroy(pTokenizer) ){\n    zErr = \"error in xDestroy()\";\n    goto finish;\n  }\n\nfinish:\n  if( zErr ){\n    sqlite3_result_error(context, zErr, -1);\n  }else{\n    ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer.c",
        "start": 197,
        "end": 231,
        "startLoc": {
          "line": 197,
          "column": 3,
          "position": 944
        },
        "endLoc": {
          "line": 231,
          "column": 30,
          "position": 1248
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer.c",
        "start": 326,
        "end": 360,
        "startLoc": {
          "line": 326,
          "column": 3,
          "position": 2508
        },
        "endLoc": {
          "line": 360,
          "column": 30,
          "position": 2812
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "sqlite3_result_text(context, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT);\n  }\n  Tcl_DecrRefCount(pRet);\n}\n\nstatic\nint registerTokenizer(\n  sqlite3 *db, \n  char *zName, \n  const sqlite3_tokenizer_module *p\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char zSql[] = \"SELECT fts2_tokenizer(?, ?)\";\n\n  rc = sqlit",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer.c",
        "start": 231,
        "end": 246,
        "startLoc": {
          "line": 231,
          "column": 30,
          "position": 1249
        },
        "endLoc": {
          "line": 246,
          "column": 19,
          "position": 1365
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer.c",
        "start": 360,
        "end": 376,
        "startLoc": {
          "line": 360,
          "column": 30,
          "position": 2813
        },
        "endLoc": {
          "line": 376,
          "column": 15,
          "position": 2930
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "ob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC);\n  sqlite3_step(pStmt);\n\n  return sqlite3_finalize(pStmt);\n}\n\nstatic\nint queryFts2Tokenizer(\n  sqlite3 *db, \n  char *zName,  \n  const sqlite3_tokenizer_module **pp\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char zSq",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer.c",
        "start": 253,
        "end": 263,
        "startLoc": {
          "line": 253,
          "column": 27,
          "position": 1421
        },
        "endLoc": {
          "line": 263,
          "column": 2,
          "position": 1527
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer.c",
        "start": 383,
        "end": 394,
        "startLoc": {
          "line": 383,
          "column": 27,
          "position": 2986
        },
        "endLoc": {
          "line": 394,
          "column": 3,
          "position": 3093
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "**\n** The third argument to this function, zName, is used as the name\n** of both the scalar and, if created, the virtual table.\n*/\nint sqlite3Fts2InitHashTable(\n  sqlite3 *db, \n  fts2Hash *pHash, \n  const char *zName\n){\n  int rc = SQ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_tokenizer.c",
        "start": 347,
        "end": 360,
        "startLoc": {
          "line": 347,
          "column": 11,
          "position": 1938
        },
        "endLoc": {
          "line": 360,
          "column": 3,
          "position": 2040
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer.c",
        "start": 484,
        "end": 497,
        "startLoc": {
          "line": 484,
          "column": 18,
          "position": 3558
        },
        "endLoc": {
          "line": 497,
          "column": 10,
          "position": 3660
        }
      }
    },
    {
      "format": "c",
      "lines": 30,
      "fragment": "nizer_module porterTokenizerModule;\n\n\n/*\n** Create a new tokenizer instance.\n*/\nstatic int porterCreate(\n  int argc, const char * const *argv,\n  sqlite3_tokenizer **ppTokenizer\n){\n  porter_tokenizer *t;\n  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));\n  if( t==NULL ) return SQLITE_NOMEM;\n  memset(t, 0, sizeof(*t));\n  *ppTokenizer = &t->base;\n  return SQLITE_OK;\n}\n\n/*\n** Destroy a tokenizer\n*/\nstatic int porterDestroy(sqlite3_tokenizer *pTokenizer){\n  sqlite3_free(pTokenizer);\n  return SQLITE_OK;\n}\n\n/*\n** Prepare to begin tokenizing a particular string.  The input\n** string to be tokenized is zInput[0..nInput-1].  A cursor\n** used to incrementally tokenize this string is returned in \n** *ppCursor.\n*/\nstatic int porterOpen(\n  sqlite3_tokenizer *pTokenizer,       ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 70,
        "end": 99,
        "startLoc": {
          "line": 70,
          "column": 2,
          "position": 173
        },
        "endLoc": {
          "line": 99,
          "column": 2,
          "position": 335
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 66,
        "end": 96,
        "startLoc": {
          "line": 66,
          "column": 2,
          "position": 171
        },
        "endLoc": {
          "line": 96,
          "column": 17,
          "position": 334
        }
      }
    },
    {
      "format": "c",
      "lines": 92,
      "fragment": "        /* The tokenizer */\n  const char *zInput, int nInput,        /* String to be tokenized */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  porter_tokenizer_cursor *c;\n\n  c = (porter_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));\n  if( c==NULL ) return SQLITE_NOMEM;\n\n  c->zInput = zInput;\n  if( zInput==0 ){\n    c->nInput = 0;\n  }else if( nInput<0 ){\n    c->nInput = (int)strlen(zInput);\n  }else{\n    c->nInput = nInput;\n  }\n  c->iOffset = 0;                 /* start tokenizing at the beginning */\n  c->iToken = 0;\n  c->zToken = NULL;               /* no space allocated, yet. */\n  c->nAllocated = 0;\n\n  *ppCursor = &c->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously opened by a call to\n** porterOpen() above.\n*/\nstatic int porterClose(sqlite3_tokenizer_cursor *pCursor){\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  sqlite3_free(c->zToken);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}\n/*\n** Vowel or consonant\n*/\nstatic const char cType[] = {\n   0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,\n   1, 1, 1, 2, 1\n};\n\n/*\n** isConsonant() and isVowel() determine if their first character in\n** the string they point to is a consonant or a vowel, according\n** to Porter ruls.  \n**\n** A consonate is any letter other than 'a', 'e', 'i', 'o', or 'u'.\n** 'Y' is a consonant unless it follows another consonant,\n** in which case it is a vowel.\n**\n** In these routine, the letters are in reverse order.  So the 'y' rule\n** is that 'y' is a consonant unless it is followed by another\n** consonent.\n*/\nstatic int isVowel(const char*);\nstatic int isConsonant(const char *z){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return j;\n  return z[1]==0 || isVowel(z + 1);\n}\nstatic int isVowel(const char *z){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return 1-j;\n  return isConsonant(z + 1);\n}\n\n/*\n** Let any sequence of one or more vowels be represented by V and let\n** C be sequence of one or more consonants.  Then every word can be\n** represented as:\n**\n**           [C] (VC){m} [V]\n**\n** In prose:  A word is an optional consonant followed by zero or\n** vowel-consonant pairs followed by an optional vowel.  \"m\" is the\n** number of vowel consonant pairs.  This routine computes the value\n** of m for the first i bytes of a word.\n**\n** Return true if the m-value for z is 1 or more.  In other words,\n** return true i",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 97,
        "end": 188,
        "startLoc": {
          "line": 97,
          "column": 2,
          "position": 331
        },
        "endLoc": {
          "line": 188,
          "column": 3,
          "position": 912
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 96,
        "end": 187,
        "startLoc": {
          "line": 96,
          "column": 2,
          "position": 338
        },
        "endLoc": {
          "line": 187,
          "column": 3,
          "position": 919
        }
      }
    },
    {
      "format": "c",
      "lines": 51,
      "fragment": " z contains at least one vowel that is followed\n** by a consonant.\n**\n** In this routine z[] is in reverse order.  So we are really looking\n** for an instance of of a consonant followed by a vowel.\n*/\nstatic int m_gt_0(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/* Like mgt0 above except we are looking for a value of m which is\n** exactly 1\n*/\nstatic int m_eq_1(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 1;\n  while( isConsonant(z) ){ z++; }\n  return *z==0;\n}\n\n/* Like mgt0 above except we are looking for a value of m>1 instead\n** or m>0\n*/\nstatic int m_gt_1(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/*\n** Return TRUE if there is a vowel anywhere within z[0..n-1]\n*/\nstatic int hasVowel(const char *z){\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/*\n** Return TRUE if the word ends in a ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 189,
        "end": 239,
        "startLoc": {
          "line": 189,
          "column": 1,
          "position": 914
        },
        "endLoc": {
          "line": 239,
          "column": 3,
          "position": 1375
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 188,
        "end": 238,
        "startLoc": {
          "line": 188,
          "column": 1,
          "position": 921
        },
        "endLoc": {
          "line": 238,
          "column": 2,
          "position": 1381
        }
      }
    },
    {
      "format": "c",
      "lines": 45,
      "fragment": " the first one cannot be in [wxy].\n*/\nstatic int star_oh(const char *z){\n  return\n    z[0]!=0 && isConsonant(z) &&\n    z[0]!='w' && z[0]!='x' && z[0]!='y' &&\n    z[1]!=0 && isVowel(z+1) &&\n    z[2]!=0 && isConsonant(z+2);\n}\n\n/*\n** If the word ends with zFrom and xCond() is true for the stem\n** of the word that preceeds the zFrom ending, then change the \n** ending to zTo.\n**\n** The input word *pz and zFrom are both in reverse order.  zTo\n** is in normal order. \n**\n** Return TRUE if zFrom matches.  Return FALSE if zFrom does not\n** match.  Not that TRUE is returned even if xCond() fails and\n** no substitution occurs.\n*/\nstatic int stem(\n  char **pz,             /* The word being stemmed (Reversed) */\n  const char *zFrom,     /* If the ending matches this... (Reversed) */\n  const char *zTo,       /* ... change the ending to this (not reversed) */\n  int (*xCond)(const char*)   /* Condition that must be true */\n){\n  char *z = *pz;\n  while( *zFrom && *zFrom==*z ){ z++; zFrom++; }\n  if( *zFrom!=0 ) return 0;\n  if( xCond && !xCond(z) ) return 1;\n  while( *zTo ){\n    *(--z) = *(zTo++);\n  }\n  *pz = z;\n  return 1;\n}\n\n/*\n** This is the fallback stemmer used when the porter stemmer is\n** inappropriate.  The input word is copied into the output with\n** US-ASCII case folding.  If the input word is too long (more\n** than 20 bytes if it contains no digits or more than 6 bytes if\n** it contains digits) then word is truncated to 20 or 6 bytes\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 255,
        "end": 299,
        "startLoc": {
          "line": 255,
          "column": 2,
          "position": 1480
        },
        "endLoc": {
          "line": 299,
          "column": 4,
          "position": 1752
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 253,
        "end": 298,
        "startLoc": {
          "line": 253,
          "column": 2,
          "position": 1450
        },
        "endLoc": {
          "line": 298,
          "column": 5,
          "position": 1723
        }
      }
    },
    {
      "format": "c",
      "lines": 45,
      "fragment": "* by taking 10 or 3 bytes from the beginning and end.\n*/\nstatic void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){\n  int i, mx, j;\n  int hasDigit = 0;\n  for(i=0; i<nIn; i++){\n    int c = zIn[i];\n    if( c>='A' && c<='Z' ){\n      zOut[i] = c - 'A' + 'a';\n    }else{\n      if( c>='0' && c<='9' ) hasDigit = 1;\n      zOut[i] = c;\n    }\n  }\n  mx = hasDigit ? 3 : 10;\n  if( nIn>mx*2 ){\n    for(j=mx, i=nIn-mx; i<nIn; i++, j++){\n      zOut[j] = zOut[i];\n    }\n    i = j;\n  }\n  zOut[i] = 0;\n  *pnOut = i;\n}\n\n\n/*\n** Stem the input word zIn[0..nIn-1].  Store the output in zOut.\n** zOut is at least big enough to hold nIn bytes.  Write the actual\n** size of the output word (exclusive of the '\\0' terminator) into *pnOut.\n**\n** Any upper-case characters in the US-ASCII character set ([A-Z])\n** are converted to lower case.  Upper-case UTF characters are\n** unchanged.\n**\n** Words that are longer than about 20 bytes are stemmed by retaining\n** a few bytes from the beginning and the end of the word.  If the\n** word contains digits, 3 bytes are taken from the beginning and\n** 3 bytes from the end.  For long words without digits, 10 bytes\n** are taken from each end.  US-ASCII case folding still applies.\n** \n** If the input word contains not digits but does characters not \n** in [a-zA-Z] then no stemming is attempted and this routine just \n** copies the input into the input into the output with US-ASCII\n** case folding.\n**\n*",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 299,
        "end": 343,
        "startLoc": {
          "line": 299,
          "column": 2,
          "position": 1754
        },
        "endLoc": {
          "line": 343,
          "column": 2,
          "position": 1996
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 298,
        "end": 342,
        "startLoc": {
          "line": 298,
          "column": 2,
          "position": 1725
        },
        "endLoc": {
          "line": 342,
          "column": 2,
          "position": 1967
        }
      }
    },
    {
      "format": "c",
      "lines": 55,
      "fragment": "d is too big or too small for the porter stemmer.\n    ** Fallback to the copy stemmer */\n    copy_stemmer(zIn, nIn, zOut, pnOut);\n    return;\n  }\n  for(i=0, j=sizeof(zReverse)-6; i<nIn; i++, j--){\n    c = zIn[i];\n    if( c>='A' && c<='Z' ){\n      zReverse[j] = c + 'a' - 'A';\n    }else if( c>='a' && c<='z' ){\n      zReverse[j] = c;\n    }else{\n      /* The use of a character not in [a-zA-Z] means that we fallback\n      ** to the copy stemmer */\n      copy_stemmer(zIn, nIn, zOut, pnOut);\n      return;\n    }\n  }\n  memset(&zReverse[sizeof(zReverse)-5], 0, 5);\n  z = &zReverse[j+1];\n\n\n  /* Step 1a */\n  if( z[0]=='s' ){\n    if(\n     !stem(&z, \"sess\", \"ss\", 0) &&\n     !stem(&z, \"sei\", \"i\", 0)  &&\n     !stem(&z, \"ss\", \"ss\", 0)\n    ){\n      z++;\n    }\n  }\n\n  /* Step 1b */  \n  z2 = z;\n  if( stem(&z, \"dee\", \"ee\", m_gt_0) ){\n    /* Do nothing.  The work was all in the test */\n  }else if( \n     (stem(&z, \"gni\", \"\", hasVowel) || stem(&z, \"de\", \"\", hasVowel))\n      && z!=z2\n  ){\n     if( stem(&z, \"ta\", \"ate\", 0) ||\n         stem(&z, \"lb\", \"ble\", 0) ||\n         stem(&z, \"zi\", \"ize\", 0) ){\n       /* Do nothing.  The work was all in the test */\n     }else if( doubleConsonant(z) && (*z!='l' && *z!='s' && *z!='z') ){\n       z++;\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 353,
        "end": 407,
        "startLoc": {
          "line": 353,
          "column": 5,
          "position": 2102
        },
        "endLoc": {
          "line": 407,
          "column": 5,
          "position": 2642
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 352,
        "end": 406,
        "startLoc": {
          "line": 352,
          "column": 2,
          "position": 2075
        },
        "endLoc": {
          "line": 406,
          "column": 3,
          "position": 2615
        }
      }
    },
    {
      "format": "c",
      "lines": 41,
      "fragment": "  stem(&z, \"ezila\", \"al\", m_gt_0);\n     break;\n   case 'i':\n     stem(&z, \"itici\", \"ic\", m_gt_0);\n     break;\n   case 'l':\n     stem(&z, \"laci\", \"ic\", m_gt_0) ||\n     stem(&z, \"luf\", \"\", m_gt_0);\n     break;\n   case 's':\n     stem(&z, \"ssen\", \"\", m_gt_0);\n     break;\n  }\n\n  /* Step 4 */\n  switch( z[1] ){\n   case 'a':\n     if( z[0]=='l' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'c':\n     if( z[0]=='e' && z[2]=='n' && (z[3]=='a' || z[3]=='e')  && m_gt_1(z+4)  ){\n       z += 4;\n     }\n     break;\n   case 'e':\n     if( z[0]=='r' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'i':\n     if( z[0]=='c' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'l':\n     if( z[0]=='e' && z[2]=='b' && (z[3]=='a' || z[3]=='i') && m_gt_1(z",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 458,
        "end": 498,
        "startLoc": {
          "line": 458,
          "column": 6,
          "position": 3236
        },
        "endLoc": {
          "line": 498,
          "column": 5,
          "position": 3646
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 470,
        "end": 510,
        "startLoc": {
          "line": 470,
          "column": 6,
          "position": 3287
        },
        "endLoc": {
          "line": 510,
          "column": 3,
          "position": 3697
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "gt_1(z+3) ){\n           z += 3;\n         }\n       }else if( z[2]=='e' ){\n         stem(&z, \"tneme\", \"\", m_gt_1) ||\n         stem(&z, \"tnem\", \"\", m_gt_1) ||\n         stem(&z, \"tne\", \"\", m_gt_1);\n       }\n     }\n     break;\n   case 'o':\n     if( z[0]=='u' ){\n       if( m_gt_1(z+2) ){\n         z += 2;\n       }\n     }else if(",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 501,
        "end": 519,
        "startLoc": {
          "line": 501,
          "column": 8,
          "position": 3699
        },
        "endLoc": {
          "line": 519,
          "column": 5,
          "position": 3865
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 515,
        "end": 533,
        "startLoc": {
          "line": 515,
          "column": 8,
          "position": 3760
        },
        "endLoc": {
          "line": 533,
          "column": 3,
          "position": 3926
        }
      }
    },
    {
      "format": "c",
      "lines": 32,
      "fragment": "  }\n     break;\n   case 's':\n     if( z[0]=='m' && z[2]=='i' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n   case 't':\n     stem(&z, \"eta\", \"\", m_gt_1) ||\n     stem(&z, \"iti\", \"\", m_gt_1);\n     break;\n   case 'u':\n     if( z[0]=='s' && z[2]=='o' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n   case 'v':\n   case 'z':\n     if( z[0]=='e' && z[2]=='i' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n  }\n\n  /* Step 5a */\n  if( z[0]=='e' ){\n    if( m_gt_1(z+1) ){\n      z++;\n    }else if( m_eq_1(z+1) && !star_oh(z+1) ){\n      z++;\n    }\n  }\n\n  /* Ste",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 521,
        "end": 552,
        "startLoc": {
          "line": 521,
          "column": 6,
          "position": 3900
        },
        "endLoc": {
          "line": 552,
          "column": 7,
          "position": 4151
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 536,
        "end": 567,
        "startLoc": {
          "line": 536,
          "column": 6,
          "position": 3969
        },
        "endLoc": {
          "line": 567,
          "column": 2,
          "position": 4220
        }
      }
    },
    {
      "format": "c",
      "lines": 56,
      "fragment": "/* Step 5b */\n  if( m_gt_1(z) && z[0]=='l' && z[1]=='l' ){\n    z++;\n  }\n\n  /* z[] is now the stemmed word in reverse order.  Flip it back\n  ** around into forward order and return.\n  */\n  *pnOut = i = strlen(z);\n  zOut[i] = 0;\n  while( *z ){\n    zOut[--i] = *(z++);\n  }\n}\n\n/*\n** Characters that can be part of a token.  We assume any character\n** whose value is greater than 0x80 (any UTF character) can be\n** part of a token.  In other words, delimiters all must have\n** values of 0x7f or lower.\n*/\nstatic const char porterIdChar[] = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 4x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  /* 5x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 6x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  /* 7x */\n};\n#define isDelim(C) (((ch=C)&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30]))\n\n/*\n** Extract the next token from a tokenization cursor.  The cursor must\n** have been opened by a prior call to porterOpen().\n*/\nstatic int porterNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by porterOpen */\n  const char **pzToken,               /* OUT: *pzToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  const char *z = c->zInput;\n\n  while( c->iOffset<c->nInput ){\n    int iStartOffset, ch;\n\n    /* Scan past delimiter characters */\n    while( c->iOffset<c->nInput && isDelim(z[c->iOffset]) ){\n      c->iOffset++;\n    ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 552,
        "end": 607,
        "startLoc": {
          "line": 552,
          "column": 2,
          "position": 4151
        },
        "endLoc": {
          "line": 607,
          "column": 2,
          "position": 4738
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 567,
        "end": 622,
        "startLoc": {
          "line": 567,
          "column": 2,
          "position": 4223
        },
        "endLoc": {
          "line": 622,
          "column": 5,
          "position": 4810
        }
      }
    },
    {
      "format": "c",
      "lines": 24,
      "fragment": ") ){\n      c->iOffset++;\n    }\n\n    if( c->iOffset>iStartOffset ){\n      int n = c->iOffset-iStartOffset;\n      if( n>c->nAllocated ){\n        c->nAllocated = n+20;\n        c->zToken = sqlite3_realloc(c->zToken, c->nAllocated);\n        if( c->zToken==NULL ) return SQLITE_NOMEM;\n      }\n      porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes);\n      *pzToken = c->zToken;\n      *piStartOffset = iStartOffset;\n      *piEndOffset = c->iOffset;\n      *piPosition = c->iToken++;\n ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 609,
        "end": 632,
        "startLoc": {
          "line": 609,
          "column": 13,
          "position": 4784
        },
        "endLoc": {
          "line": 632,
          "column": 2,
          "position": 4913
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 626,
        "end": 649,
        "startLoc": {
          "line": 626,
          "column": 5,
          "position": 4868
        },
        "endLoc": {
          "line": 649,
          "column": 2,
          "position": 4998
        }
      }
    },
    {
      "format": "c",
      "lines": 37,
      "fragment": "(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS2)\n#ifdef SQLITE_ENABLE_ICU\n\n#include <assert.h>\n#include <string.h>\n#include \"fts2_tokenizer.h\"\n\n#include <unicode/ubrk.h>\n#include <unicode/ucol.h>\n#include <unicode/ustring.h>\n#include <unicode/utf16.h>\n\ntypedef struct IcuTokenizer IcuTokenizer;\ntypedef struct IcuCursor IcuCursor;\n\nstruct IcuTokenizer {\n  sqlite3_tokenizer base;\n  char *zLocale;\n};\n\nstruct IcuCursor {\n  sqlite3_tokenizer_cursor base;\n\n  UBreakIterator *pIter;      /* ICU break-iterator object */\n  int nChar;                  /* Number of UChar elements in pInput */\n  UChar *aChar;               /* Copy of input using utf-16 encoding */\n  int *aOffset;               /* Offsets of each character in utf-8 input */\n\n  int nBuffer;\n  char *zBuffer;\n\n  int iToken;\n};\n\n/*\n** Create a new tokenizer instance.\n*/\nstatic int icuCreate(\n  int argc,                            /* Number of entries in argv[] */\n  const char",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_icu.c",
        "start": 29,
        "end": 65,
        "startLoc": {
          "line": 29,
          "column": 1,
          "position": 15
        },
        "endLoc": {
          "line": 65,
          "column": 15,
          "position": 232
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_icu.c",
        "start": 27,
        "end": 63,
        "startLoc": {
          "line": 27,
          "column": 1,
          "position": 15
        },
        "endLoc": {
          "line": 63,
          "column": 17,
          "position": 232
        }
      }
    },
    {
      "format": "c",
      "lines": 51,
      "fragment": " * const *argv,            /* Tokenizer creation arguments */\n  sqlite3_tokenizer **ppTokenizer      /* OUT: Created tokenizer */\n){\n  IcuTokenizer *p;\n  int n = 0;\n\n  if( argc>0 ){\n    n = strlen(argv[0])+1;\n  }\n  p = (IcuTokenizer *)sqlite3_malloc(sizeof(IcuTokenizer)+n);\n  if( !p ){\n    return SQLITE_NOMEM;\n  }\n  memset(p, 0, sizeof(IcuTokenizer));\n\n  if( n ){\n    p->zLocale = (char *)&p[1];\n    memcpy(p->zLocale, argv[0], n);\n  }\n\n  *ppTokenizer = (sqlite3_tokenizer *)p;\n\n  return SQLITE_OK;\n}\n\n/*\n** Destroy a tokenizer\n*/\nstatic int icuDestroy(sqlite3_tokenizer *pTokenizer){\n  IcuTokenizer *p = (IcuTokenizer *)pTokenizer;\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\n/*\n** Prepare to begin tokenizing a particular string.  The input\n** string to be tokenized is pInput[0..nBytes-1].  A cursor\n** used to incrementally tokenize this string is returned in \n** *ppCursor.\n*/\nstatic int icuOpen(\n  sqlite3_tokenizer *pTokenizer,         /* The tokenizer */\n  const char *zInput,                    /* Input string */\n  int nInput,                            /* Length of zInput in bytes */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cur",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_icu.c",
        "start": 65,
        "end": 115,
        "startLoc": {
          "line": 65,
          "column": 15,
          "position": 233
        },
        "endLoc": {
          "line": 115,
          "column": 7,
          "position": 543
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_icu.c",
        "start": 63,
        "end": 113,
        "startLoc": {
          "line": 63,
          "column": 17,
          "position": 233
        },
        "endLoc": {
          "line": 113,
          "column": 7,
          "position": 543
        }
      }
    },
    {
      "format": "c",
      "lines": 83,
      "fragment": "pt = U_FOLD_CASE_DEFAULT;\n  UErrorCode status = U_ZERO_ERROR;\n  int nChar;\n\n  UChar32 c;\n  int iInput = 0;\n  int iOut = 0;\n\n  *ppCursor = 0;\n\n  if( nInput<0 ){\n    nInput = strlen(zInput);\n  }\n  nChar = nInput+1;\n  pCsr = (IcuCursor *)sqlite3_malloc(\n      sizeof(IcuCursor) +                /* IcuCursor */\n      ((nChar+3)&~3) * sizeof(UChar) +   /* IcuCursor.aChar[] */\n      (nChar+1) * sizeof(int)            /* IcuCursor.aOffset[] */\n  );\n  if( !pCsr ){\n    return SQLITE_NOMEM;\n  }\n  memset(pCsr, 0, sizeof(IcuCursor));\n  pCsr->aChar = (UChar *)&pCsr[1];\n  pCsr->aOffset = (int *)&pCsr->aChar[(nChar+3)&~3];\n\n  pCsr->aOffset[iOut] = iInput;\n  U8_NEXT(zInput, iInput, nInput, c); \n  while( c>0 ){\n    int isError = 0;\n    c = u_foldCase(c, opt);\n    U16_APPEND(pCsr->aChar, iOut, nChar, c, isError);\n    if( isError ){\n      sqlite3_free(pCsr);\n      return SQLITE_ERROR;\n    }\n    pCsr->aOffset[iOut] = iInput;\n\n    if( iInput<nInput ){\n      U8_NEXT(zInput, iInput, nInput, c);\n    }else{\n      c = 0;\n    }\n  }\n\n  pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status);\n  if( !U_SUCCESS(status) ){\n    sqlite3_free(pCsr);\n    return SQLITE_ERROR;\n  }\n  pCsr->nChar = iOut;\n\n  ubrk_first(pCsr->pIter);\n  *ppCursor = (sqlite3_tokenizer_cursor *)pCsr;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously opened by a call to icuOpen().\n*/\nstatic int icuClose(sqlite3_tokenizer_cursor *pCursor){\n  IcuCursor *pCsr = (IcuCursor *)pCursor;\n  ubrk_close(pCsr->pIter);\n  sqlite3_free(pCsr->zBuffer);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}\n\n/*\n** Extract the next token from a tokenization cursor.\n*/\nstatic int icuNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by simpleOpen */\n  const char **ppToken,               /* OUT: *ppToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  IcuCursor *pCsr = (IcuCursor *)pCursor;\n\n  int iStart = 0;\n  int iEnd = 0;\n  int nByte",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_icu.c",
        "start": 119,
        "end": 201,
        "startLoc": {
          "line": 119,
          "column": 15,
          "position": 585
        },
        "endLoc": {
          "line": 201,
          "column": 8,
          "position": 1265
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_icu.c",
        "start": 120,
        "end": 202,
        "startLoc": {
          "line": 120,
          "column": 17,
          "position": 615
        },
        "endLoc": {
          "line": 202,
          "column": 9,
          "position": 1295
        }
      }
    },
    {
      "format": "c",
      "lines": 42,
      "fragment": " = 0;\n\n  while( iStart==iEnd ){\n    UChar32 c;\n\n    iStart = ubrk_current(pCsr->pIter);\n    iEnd = ubrk_next(pCsr->pIter);\n    if( iEnd==UBRK_DONE ){\n      return SQLITE_DONE;\n    }\n\n    while( iStart<iEnd ){\n      int iWhite = iStart;\n      U8_NEXT(pCsr->aChar, iWhite, pCsr->nChar, c);\n      if( u_isspace(c) ){\n        iStart = iWhite;\n      }else{\n        break;\n      }\n    }\n    assert(iStart<=iEnd);\n  }\n\n  do {\n    UErrorCode status = U_ZERO_ERROR;\n    if( nByte ){\n      char *zNew = sqlite3_realloc(pCsr->zBuffer, nByte);\n      if( !zNew ){\n        return SQLITE_NOMEM;\n      }\n      pCsr->zBuffer = zNew;\n      pCsr->nBuffer = nByte;\n    }\n\n    u_strToUTF8(\n        pCsr->zBuffer, pCsr->nBuffer, &nByte,    /* Output vars */\n        &pCsr->aChar[iStart], iEnd-iStart,       /* Input vars */\n        &status                                  /* Output success/failure */\n    );\n  } while( nByte>pCsr->nBuffer );\n\n  *ppToken = pCsr->zBuffer;\n  *pnBytes = nByte;\n  *piStartOffset = pCsr->aOffset[iStart];\n  *piEndOffset =",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_icu.c",
        "start": 201,
        "end": 242,
        "startLoc": {
          "line": 201,
          "column": 8,
          "position": 1266
        },
        "endLoc": {
          "line": 242,
          "column": 15,
          "position": 1570
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_icu.c",
        "start": 202,
        "end": 243,
        "startLoc": {
          "line": 202,
          "column": 9,
          "position": 1296
        },
        "endLoc": {
          "line": 243,
          "column": 18,
          "position": 1600
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": " if( n1!=n2 ) return 1;\n  return strncmp((const char*)pKey1,(const char*)pKey2,n1);\n}\n\n/*\n** Hash and comparison functions when the mode is FTS2_HASH_BINARY\n*/\nstatic int binHash(const ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 117,
        "end": 125,
        "startLoc": {
          "line": 117,
          "column": 8,
          "position": 595
        },
        "endLoc": {
          "line": 125,
          "column": 11,
          "position": 697
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 115,
        "end": 123,
        "startLoc": {
          "line": 115,
          "column": 12,
          "position": 597
        },
        "endLoc": {
          "line": 123,
          "column": 15,
          "position": 699
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": "* The complete hash table */\n  struct _fts2ht *pEntry,  /* The entry into which pNew is inserted */\n  fts2HashElem *pNew       /* The element to be inserted */\n){\n  fts2HashElem *pHead;     /* First element already in pEntry */\n  pHead = pEntry->chain;\n  if( pHead ){\n    pNew->next = pHead;\n    pNew->prev = pHead->prev;\n    if( pHead->prev ){ pHead->prev->next = pNew; }\n    else             { pH->first = pNew; }\n    pHead->prev = pNew;\n  }else{\n    pNew->next = pH->first;\n    if( pH->first ){ pH->first->prev = pNew; }\n    pNew->prev = 0;\n    pH->first = pNew;\n  }\n  pEntry->count++;\n  pEntry->chain = p",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 173,
        "end": 195,
        "startLoc": {
          "line": 173,
          "column": 2,
          "position": 951
        },
        "endLoc": {
          "line": 195,
          "column": 3,
          "position": 1133
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 171,
        "end": 195,
        "startLoc": {
          "line": 171,
          "column": 2,
          "position": 953
        },
        "endLoc": {
          "line": 195,
          "column": 3,
          "position": 1135
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "id*,int);  /* comparison function */\n\n  if( pH->ht ){\n    struct _fts2ht *pEntry = &pH->ht[h];\n    elem = pEntry->chain;\n    count = pEntry->count;\n    xCompare = compareFunction(pH->keyClass);\n    while( count-- && elem ){\n      if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){ \n        return elem;\n      }\n      elem = elem->nex",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 233,
        "end": 247,
        "startLoc": {
          "line": 233,
          "column": 16,
          "position": 1540
        },
        "endLoc": {
          "line": 247,
          "column": 23,
          "position": 1629
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 234,
        "end": 248,
        "startLoc": {
          "line": 234,
          "column": 19,
          "position": 1550
        },
        "endLoc": {
          "line": 248,
          "column": 24,
          "position": 1639
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "  /* The pH containing \"elem\" */\n  fts2HashElem* elem,   /* The element to be removed from the pH */\n  int h                 /* Hash value for the element */\n){\n  struct _fts2ht *pEntry;\n  if( elem->prev ){\n    elem->prev->next = elem->next; \n  }else{\n    pH->first = elem->next;\n  }\n  if( elem->next ){\n    elem->next->prev = elem->prev;\n  }\n  pEntry = &pH->ht[h];\n  if( pEnt",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 252,
        "end": 270,
        "startLoc": {
          "line": 252,
          "column": 2,
          "position": 1665
        },
        "endLoc": {
          "line": 270,
          "column": 13,
          "position": 1836
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 253,
        "end": 271,
        "startLoc": {
          "line": 253,
          "column": 2,
          "position": 1675
        },
        "endLoc": {
          "line": 271,
          "column": 13,
          "position": 1846
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "element list */\n  fts2HashElem *new_elem;   /* New element added to the pH */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  assert( pH!=0 );\n  xHash = hashFun",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 327,
        "end": 332,
        "startLoc": {
          "line": 327,
          "column": 13,
          "position": 2234
        },
        "endLoc": {
          "line": 332,
          "column": 21,
          "position": 2317
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 338,
        "end": 343,
        "startLoc": {
          "line": 338,
          "column": 16,
          "position": 2297
        },
        "endLoc": {
          "line": 343,
          "column": 22,
          "position": 2380
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "d(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)\n\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"fts1_tokenizer.h\"\n\ntypedef struct simple_tokenizer {\n  sqlite3_tokenizer base;\n  char delim[128];             /* flag ASCII delimiters */\n} simple_tokenizer;\n\ntypedef struct simple_tokenizer_cursor {\n  sqlite3_tokenizer_cursor base;\n  const char *pInput;          /* input we are tokenizing */\n  int nBytes;                  /* size of the input */\n  int iOffset;                 /* current position in pInput */\n  int iToken;                  /* index of next token to be returned */\n  char *pToken;                /* storage for current token */\n  int nTokenAllocated;       ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 28,
        "end": 47,
        "startLoc": {
          "line": 28,
          "column": 1,
          "position": 16
        },
        "endLoc": {
          "line": 47,
          "column": 8,
          "position": 136
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 35,
        "end": 57,
        "startLoc": {
          "line": 35,
          "column": 1,
          "position": 15
        },
        "endLoc": {
          "line": 57,
          "column": 12,
          "position": 139
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "  /* space allocated to zToken buffer */\n} simple_tokenizer_cursor;\n\n\n/* Forward declaration */\nstatic const sqlite3_tokenizer_module simpleTokenizerModule;\n\nstatic int isDelim(simple_tokenizer *t, unsigned char c){\n  return c<0x80 && t->delim[c];\n}\n\n/*\n** Create a new toke",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 47,
        "end": 60,
        "startLoc": {
          "line": 47,
          "column": 8,
          "position": 137
        },
        "endLoc": {
          "line": 60,
          "column": 7,
          "position": 228
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 57,
        "end": 70,
        "startLoc": {
          "line": 57,
          "column": 12,
          "position": 140
        },
        "endLoc": {
          "line": 70,
          "column": 15,
          "position": 231
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "gc, const char * const *argv,\n  sqlite3_tokenizer **ppTokenizer\n){\n  simple_tokenizer *t;\n\n  t = (simple_tokenizer *) calloc(sizeof(*t), 1);\n  if( t==NULL ) return SQLITE_NOMEM;\n\n  /* TODO(shess) Delimiters need to remain the same from run to run,\n  ** else we need to reindex.  One solution would be a meta-table to\n  ** track such information in the database, then we'd only want this\n  ** information on the initial create.\n  */\n  if( argc>1 ){\n    int i, n = st",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 61,
        "end": 74,
        "startLoc": {
          "line": 61,
          "column": 13,
          "position": 254
        },
        "endLoc": {
          "line": 74,
          "column": 5,
          "position": 341
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 72,
        "end": 85,
        "startLoc": {
          "line": 72,
          "column": 2,
          "position": 271
        },
        "endLoc": {
          "line": 85,
          "column": 13,
          "position": 358
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": " /* String to be tokenized */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  simple_tokenizer_cursor *c;\n\n  c = (simple_tokenizer_cursor *) malloc(sizeof(*c));\n  if( c==NULL ) return SQLITE_NOMEM;\n\n  c->pInput = pInput;\n  if( pInput==0 ){\n    c->nBytes = 0;\n  }else if( nBytes<0 ){\n    c->nBytes = (int)strlen(pInput);\n  }else{\n    c->nBytes = nBytes;\n  }\n  c->iOffset = 0;                 /* start tokenizing at the beginning */\n  c->iToken = 0;\n  c->pToken = NULL;               /* no space allocated, yet. */\n  c->nTokenAllocated = 0;\n\n  *ppCursor = &c->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously ope",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 112,
        "end": 138,
        "startLoc": {
          "line": 112,
          "column": 7,
          "position": 548
        },
        "endLoc": {
          "line": 138,
          "column": 5,
          "position": 751
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 122,
        "end": 148,
        "startLoc": {
          "line": 122,
          "column": 15,
          "position": 627
        },
        "endLoc": {
          "line": 148,
          "column": 13,
          "position": 830
        }
      }
    },
    {
      "format": "c",
      "lines": 25,
      "fragment": " simpleOpen() above.\n*/\nstatic int simpleClose(sqlite3_tokenizer_cursor *pCursor){\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  free(c->pToken);\n  free(c);\n  return SQLITE_OK;\n}\n\n/*\n** Extract the next token from a tokenization cursor.  The cursor must\n** have been opened by a prior call to simpleOpen().\n*/\nstatic int simpleNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by simpleOpen */\n  const char **ppToken,               /* OUT: *ppToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;\n  unsigned ch",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 139,
        "end": 163,
        "startLoc": {
          "line": 139,
          "column": 5,
          "position": 761
        },
        "endLoc": {
          "line": 163,
          "column": 8,
          "position": 941
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_tokenizer1.c",
        "start": 149,
        "end": 173,
        "startLoc": {
          "line": 149,
          "column": 13,
          "position": 840
        },
        "endLoc": {
          "line": 173,
          "column": 12,
          "position": 1020
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": " && isDelim(t, p[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    /* Count non-delimiter characters. */\n    iStartOffset = c->iOffset;\n    while( c->iOffset<c->nBytes && !isDelim(t, p[c->iOffset]) ){\n      c->iOffset++;\n    ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 169,
        "end": 177,
        "startLoc": {
          "line": 169,
          "column": 8,
          "position": 997
        },
        "endLoc": {
          "line": 177,
          "column": 8,
          "position": 1085
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 181,
        "end": 189,
        "startLoc": {
          "line": 181,
          "column": 12,
          "position": 1052
        },
        "endLoc": {
          "line": 189,
          "column": 16,
          "position": 1140
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "}\n\n    if( c->iOffset>iStartOffset ){\n      int i, n = c->iOffset-iStartOffset;\n      if( n>c->nTokenAllocated ){\n        c->nTokenAllocated = n+20;\n        c->pToken = realloc(c->pToken, c->nTokenAllocated);\n        if( c->pToken==NULL ) return SQLITE_NOMEM;\n      }\n      for(i=0; i<n; i++",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 177,
        "end": 185,
        "startLoc": {
          "line": 177,
          "column": 8,
          "position": 1086
        },
        "endLoc": {
          "line": 185,
          "column": 3,
          "position": 1166
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 189,
        "end": 197,
        "startLoc": {
          "line": 189,
          "column": 16,
          "position": 1141
        },
        "endLoc": {
          "line": 197,
          "column": 2,
          "position": 1221
        }
      }
    },
    {
      "format": "c",
      "lines": 31,
      "fragment": "(shess) This needs expansion to handle UTF-8\n        ** case-insensitivity.\n        */\n        unsigned char ch = p[iStartOffset+i];\n        c->pToken[i] = ch<0x80 ? tolower(ch) : ch;\n      }\n      *ppToken = c->pToken;\n      *pnBytes = n;\n      *piStartOffset = iStartOffset;\n      *piEndOffset = c->iOffset;\n      *piPosition = c->iToken++;\n\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_DONE;\n}\n\n/*\n** The set of routines that implement the simple tokenizer\n*/\nstatic const sqlite3_tokenizer_module simpleTokenizerModule = {\n  0,\n  simpleCreate,\n  simpleDestroy,\n  sim",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer1.c",
        "start": 185,
        "end": 215,
        "startLoc": {
          "line": 185,
          "column": 3,
          "position": 1175
        },
        "endLoc": {
          "line": 215,
          "column": 33,
          "position": 1305
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_tokenizer1.c",
        "start": 197,
        "end": 227,
        "startLoc": {
          "line": 197,
          "column": 4,
          "position": 1245
        },
        "endLoc": {
          "line": 227,
          "column": 33,
          "position": 1375
        }
      }
    },
    {
      "format": "c-header",
      "lines": 27,
      "fragment": "o allow customization.\n  */\n  int (*xCreate)(int argc, const char *const*argv,\n                 sqlite3_tokenizer **ppTokenizer);\n  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);\n\n  /*\n  ** Tokenize a particular input.  Call xOpen() to prepare to\n  ** tokenize, xNext() repeatedly until it returns SQLITE_DONE, then\n  ** xClose() to free any internal state.  The pInput passed to\n  ** xOpen() must exist until the cursor is closed.  The ppToken\n  ** result from xNext() is only valid until the next call to xNext()\n  ** or until xClose() is called.\n  */\n  /* TODO(shess) current implementation requires pInput to be\n  ** nul-terminated.  This should either be fixed, or pInput/nBytes\n  ** should be converted to zInput.\n  */\n  int (*xOpen)(sqlite3_tokenizer *pTokenizer,\n               const char *pInput, int nBytes,\n               sqlite3_tokenizer_cursor **ppCursor);\n  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);\n  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,\n               const char **ppToken, int *pnBytes,\n               int *piStartOffset, in",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_tokenizer.h",
        "start": 43,
        "end": 69,
        "startLoc": {
          "line": 43,
          "column": 6,
          "position": 76
        },
        "endLoc": {
          "line": 69,
          "column": 6,
          "position": 224
        }
      },
      "secondFile": {
        "name": "ext/fts1/tokenizer.h",
        "start": 43,
        "end": 69,
        "startLoc": {
          "line": 43,
          "column": 2,
          "position": 75
        },
        "endLoc": {
          "line": 69,
          "column": 25,
          "position": 223
        }
      }
    },
    {
      "format": "c",
      "lines": 34,
      "fragment": "d(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)\n\n\n#include <assert.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"fts1_tokenizer.h\"\n\n/*\n** Class derived from sqlite3_tokenizer\n*/\ntypedef struct porter_tokenizer {\n  sqlite3_tokenizer base;      /* Base class */\n} porter_tokenizer;\n\n/*\n** Class derived from sqlit3_tokenizer_cursor\n*/\ntypedef struct porter_tokenizer_cursor {\n  sqlite3_tokenizer_cursor base;\n  const char *zInput;          /* input we are tokenizing */\n  int nInput;                  /* size of the input */\n  int iOffset;                 /* current position in zInput */\n  int iToken;                  /* index of next token to be returned */\n  char *zToken;                /* storage for current token */\n  int nAllocated;              /* space allocated to zToken buffer */\n} porter_tokenizer_cursor;\n\n\n/* Forward declaration */\nstatic const sqlite3_tokenizer_module porterTokenizerModule;\n\n\n/*\n** Create a new tok",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_porter.c",
        "start": 36,
        "end": 69,
        "startLoc": {
          "line": 36,
          "column": 1,
          "position": 16
        },
        "endLoc": {
          "line": 69,
          "column": 7,
          "position": 183
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 38,
        "end": 71,
        "startLoc": {
          "line": 38,
          "column": 1,
          "position": 19
        },
        "endLoc": {
          "line": 71,
          "column": 15,
          "position": 186
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": " /* String to be tokenized */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  porter_tokenizer_cursor *c;\n\n  c = (porter_tokenizer_cursor *) malloc(sizeof(*c));\n  if( c==NULL ) return SQLITE_NOMEM;\n\n  c->zInput = zInput;\n  if( zInput==0 ){\n    c->nInput = 0;\n  }else if( nInput<0 ){\n    c->nInput = (int)strlen(zInput);\n  }else{\n    c->nInput = nInput;\n  }\n  c->iOffset = 0;                 /* start tokenizing at the beginning */\n  c->iToken = 0;\n  c->zToken = NULL;               /* no space allocated, yet. */\n  c->nAllocated = 0;\n\n  *ppCursor = &c->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously ope",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_porter.c",
        "start": 97,
        "end": 123,
        "startLoc": {
          "line": 97,
          "column": 7,
          "position": 330
        },
        "endLoc": {
          "line": 123,
          "column": 5,
          "position": 533
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 98,
        "end": 124,
        "startLoc": {
          "line": 98,
          "column": 15,
          "position": 353
        },
        "endLoc": {
          "line": 124,
          "column": 13,
          "position": 556
        }
      }
    },
    {
      "format": "c",
      "lines": 440,
      "fragment": " porterOpen() above.\n*/\nstatic int porterClose(sqlite3_tokenizer_cursor *pCursor){\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  free(c->zToken);\n  free(c);\n  return SQLITE_OK;\n}\n/*\n** Vowel or consonant\n*/\nstatic const char cType[] = {\n   0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,\n   1, 1, 1, 2, 1\n};\n\n/*\n** isConsonant() and isVowel() determine if their first character in\n** the string they point to is a consonant or a vowel, according\n** to Porter ruls.  \n**\n** A consonate is any letter other than 'a', 'e', 'i', 'o', or 'u'.\n** 'Y' is a consonant unless it follows another consonant,\n** in which case it is a vowel.\n**\n** In these routine, the letters are in reverse order.  So the 'y' rule\n** is that 'y' is a consonant unless it is followed by another\n** consonent.\n*/\nstatic int isVowel(const char*);\nstatic int isConsonant(const char *z){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return j;\n  return z[1]==0 || isVowel(z + 1);\n}\nstatic int isVowel(const char *z){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return 1-j;\n  return isConsonant(z + 1);\n}\n\n/*\n** Let any sequence of one or more vowels be represented by V and let\n** C be sequence of one or more consonants.  Then every word can be\n** represented as:\n**\n**           [C] (VC){m} [V]\n**\n** In prose:  A word is an optional consonant followed by zero or\n** vowel-consonant pairs followed by an optional vowel.  \"m\" is the\n** number of vowel consonant pairs.  This routine computes the value\n** of m for the first i bytes of a word.\n**\n** Return true if the m-value for z is 1 or more.  In other words,\n** return true if z contains at least one vowel that is followed\n** by a consonant.\n**\n** In this routine z[] is in reverse order.  So we are really looking\n** for an instance of of a consonant followed by a vowel.\n*/\nstatic int m_gt_0(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/* Like mgt0 above except we are looking for a value of m which is\n** exactly 1\n*/\nstatic int m_eq_1(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 1;\n  while( isConsonant(z) ){ z++; }\n  return *z==0;\n}\n\n/* Like mgt0 above except we are looking for a value of m>1 instead\n** or m>0\n*/\nstatic int m_gt_1(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/*\n** Return TRUE if there is a vowel anywhere within z[0..n-1]\n*/\nstatic int hasVowel(const char *z){\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/*\n** Return TRUE if the word ends in a double consonant.\n**\n** The text is reversed here. So we are really looking at\n** the first two characters of z[].\n*/\nstatic int doubleConsonant(const char *z){\n  return isConsonant(z) && z[0]==z[1] && isConsonant(z+1);\n}\n\n/*\n** Return TRUE if the word ends with three letters which\n** are consonant-vowel-consonent and where the final consonant\n** is not 'w', 'x', or 'y'.\n**\n** The word is reversed here.  So we are really checking the\n** first three letters and the first one cannot be in [wxy].\n*/\nstatic int star_oh(const char *z){\n  return\n    z[0]!=0 && isConsonant(z) &&\n    z[0]!='w' && z[0]!='x' && z[0]!='y' &&\n    z[1]!=0 && isVowel(z+1) &&\n    z[2]!=0 && isConsonant(z+2);\n}\n\n/*\n** If the word ends with zFrom and xCond() is true for the stem\n** of the word that preceeds the zFrom ending, then change the \n** ending to zTo.\n**\n** The input word *pz and zFrom are both in reverse order.  zTo\n** is in normal order. \n**\n** Return TRUE if zFrom matches.  Return FALSE if zFrom does not\n** match.  Not that TRUE is returned even if xCond() fails and\n** no substitution occurs.\n*/\nstatic int stem(\n  char **pz,             /* The word being stemmed (Reversed) */\n  const char *zFrom,     /* If the ending matches this... (Reversed) */\n  const char *zTo,       /* ... change the ending to this (not reversed) */\n  int (*xCond)(const char*)   /* Condition that must be true */\n){\n  char *z = *pz;\n  while( *zFrom && *zFrom==*z ){ z++; zFrom++; }\n  if( *zFrom!=0 ) return 0;\n  if( xCond && !xCond(z) ) return 1;\n  while( *zTo ){\n    *(--z) = *(zTo++);\n  }\n  *pz = z;\n  return 1;\n}\n\n/*\n** This is the fallback stemmer used when the porter stemmer is\n** inappropriate.  The input word is copied into the output with\n** US-ASCII case folding.  If the input word is too long (more\n** than 20 bytes if it contains no digits or more than 6 bytes if\n** it contains digits) then word is truncated to 20 or 6 bytes\n** by taking 10 or 3 bytes from the beginning and end.\n*/\nstatic void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){\n  int i, mx, j;\n  int hasDigit = 0;\n  for(i=0; i<nIn; i++){\n    int c = zIn[i];\n    if( c>='A' && c<='Z' ){\n      zOut[i] = c - 'A' + 'a';\n    }else{\n      if( c>='0' && c<='9' ) hasDigit = 1;\n      zOut[i] = c;\n    }\n  }\n  mx = hasDigit ? 3 : 10;\n  if( nIn>mx*2 ){\n    for(j=mx, i=nIn-mx; i<nIn; i++, j++){\n      zOut[j] = zOut[i];\n    }\n    i = j;\n  }\n  zOut[i] = 0;\n  *pnOut = i;\n}\n\n\n/*\n** Stem the input word zIn[0..nIn-1].  Store the output in zOut.\n** zOut is at least big enough to hold nIn bytes.  Write the actual\n** size of the output word (exclusive of the '\\0' terminator) into *pnOut.\n**\n** Any upper-case characters in the US-ASCII character set ([A-Z])\n** are converted to lower case.  Upper-case UTF characters are\n** unchanged.\n**\n** Words that are longer than about 20 bytes are stemmed by retaining\n** a few bytes from the beginning and the end of the word.  If the\n** word contains digits, 3 bytes are taken from the beginning and\n** 3 bytes from the end.  For long words without digits, 10 bytes\n** are taken from each end.  US-ASCII case folding still applies.\n** \n** If the input word contains not digits but does characters not \n** in [a-zA-Z] then no stemming is attempted and this routine just \n** copies the input into the input into the output with US-ASCII\n** case folding.\n**\n** Stemming never increases the length of the word.  So there is\n** no chance of overflowing the zOut buffer.\n*/\nstatic void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){\n  int i, j, c;\n  char zReverse[28];\n  char *z, *z2;\n  if( nIn<3 || nIn>=sizeof(zReverse)-7 ){\n    /* The word is too big or too small for the porter stemmer.\n    ** Fallback to the copy stemmer */\n    copy_stemmer(zIn, nIn, zOut, pnOut);\n    return;\n  }\n  for(i=0, j=sizeof(zReverse)-6; i<nIn; i++, j--){\n    c = zIn[i];\n    if( c>='A' && c<='Z' ){\n      zReverse[j] = c + 'a' - 'A';\n    }else if( c>='a' && c<='z' ){\n      zReverse[j] = c;\n    }else{\n      /* The use of a character not in [a-zA-Z] means that we fallback\n      ** to the copy stemmer */\n      copy_stemmer(zIn, nIn, zOut, pnOut);\n      return;\n    }\n  }\n  memset(&zReverse[sizeof(zReverse)-5], 0, 5);\n  z = &zReverse[j+1];\n\n\n  /* Step 1a */\n  if( z[0]=='s' ){\n    if(\n     !stem(&z, \"sess\", \"ss\", 0) &&\n     !stem(&z, \"sei\", \"i\", 0)  &&\n     !stem(&z, \"ss\", \"ss\", 0)\n    ){\n      z++;\n    }\n  }\n\n  /* Step 1b */  \n  z2 = z;\n  if( stem(&z, \"dee\", \"ee\", m_gt_0) ){\n    /* Do nothing.  The work was all in the test */\n  }else if( \n     (stem(&z, \"gni\", \"\", hasVowel) || stem(&z, \"de\", \"\", hasVowel))\n      && z!=z2\n  ){\n     if( stem(&z, \"ta\", \"ate\", 0) ||\n         stem(&z, \"lb\", \"ble\", 0) ||\n         stem(&z, \"zi\", \"ize\", 0) ){\n       /* Do nothing.  The work was all in the test */\n     }else if( doubleConsonant(z) && (*z!='l' && *z!='s' && *z!='z') ){\n       z++;\n     }else if( m_eq_1(z) && star_oh(z) ){\n       *(--z) = 'e';\n     }\n  }\n\n  /* Step 1c */\n  if( z[0]=='y' && hasVowel(z+1) ){\n    z[0] = 'i';\n  }\n\n  /* Step 2 */\n  switch( z[1] ){\n   case 'a':\n     stem(&z, \"lanoita\", \"ate\", m_gt_0) ||\n     stem(&z, \"lanoit\", \"tion\", m_gt_0);\n     break;\n   case 'c':\n     stem(&z, \"icne\", \"ence\", m_gt_0) ||\n     stem(&z, \"icna\", \"ance\", m_gt_0);\n     break;\n   case 'e':\n     stem(&z, \"rezi\", \"ize\", m_gt_0);\n     break;\n   case 'g':\n     stem(&z, \"igol\", \"log\", m_gt_0);\n     break;\n   case 'l':\n     stem(&z, \"ilb\", \"ble\", m_gt_0) ||\n     stem(&z, \"illa\", \"al\", m_gt_0) ||\n     stem(&z, \"iltne\", \"ent\", m_gt_0) ||\n     stem(&z, \"ile\", \"e\", m_gt_0) ||\n     stem(&z, \"ilsuo\", \"ous\", m_gt_0);\n     break;\n   case 'o':\n     stem(&z, \"noitazi\", \"ize\", m_gt_0) ||\n     stem(&z, \"noita\", \"ate\", m_gt_0) ||\n     stem(&z, \"rota\", \"ate\", m_gt_0);\n     break;\n   case 's':\n     stem(&z, \"msila\", \"al\", m_gt_0) ||\n     stem(&z, \"ssenevi\", \"ive\", m_gt_0) ||\n     stem(&z, \"ssenluf\", \"ful\", m_gt_0) ||\n     stem(&z, \"ssensuo\", \"ous\", m_gt_0);\n     break;\n   case 't':\n     stem(&z, \"itila\", \"al\", m_gt_0) ||\n     stem(&z, \"itivi\", \"ive\", m_gt_0) ||\n     stem(&z, \"itilib\", \"ble\", m_gt_0);\n     break;\n  }\n\n  /* Step 3 */\n  switch( z[0] ){\n   case 'e':\n     stem(&z, \"etaci\", \"ic\", m_gt_0) ||\n     stem(&z, \"evita\", \"\", m_gt_0)   ||\n     stem(&z, \"ezila\", \"al\", m_gt_0);\n     break;\n   case 'i':\n     stem(&z, \"itici\", \"ic\", m_gt_0);\n     break;\n   case 'l':\n     stem(&z, \"laci\", \"ic\", m_gt_0) ||\n     stem(&z, \"luf\", \"\", m_gt_0);\n     break;\n   case 's':\n     stem(&z, \"ssen\", \"\", m_gt_0);\n     break;\n  }\n\n  /* Step 4 */\n  switch( z[1] ){\n   case 'a':\n     if( z[0]=='l' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'c':\n     if( z[0]=='e' && z[2]=='n' && (z[3]=='a' || z[3]=='e')  && m_gt_1(z+4)  ){\n       z += 4;\n     }\n     break;\n   case 'e':\n     if( z[0]=='r' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'i':\n     if( z[0]=='c' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'l':\n     if( z[0]=='e' && z[2]=='b' && (z[3]=='a' || z[3]=='i') && m_gt_1(z+4) ){\n       z += 4;\n     }\n     break;\n   case 'n':\n     if( z[0]=='t' ){\n       if( z[2]=='a' ){\n         if( m_gt_1(z+3) ){\n           z += 3;\n         }\n       }else if( z[2]=='e' ){\n         stem(&z, \"tneme\", \"\", m_gt_1) ||\n         stem(&z, \"tnem\", \"\", m_gt_1) ||\n         stem(&z, \"tne\", \"\", m_gt_1);\n       }\n     }\n     break;\n   case 'o':\n     if( z[0]=='u' ){\n       if( m_gt_1(z+2) ){\n         z += 2;\n       }\n     }else if( z[3]=='s' || z[3]=='t' ){\n       stem(&z, \"noi\", \"\", m_gt_1);\n     }\n     break;\n   case 's':\n     if( z[0]=='m' && z[2]=='i' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n   case 't':\n     stem(&z, \"eta\", \"\", m_gt_1) ||\n     stem(&z, \"iti\", \"\", m_gt_1);\n     break;\n   case 'u':\n     if( z[0]=='s' && z[2]=='o' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n   case 'v':\n   case 'z':\n     if( z[0]=='e' && z[2]=='i' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n  }\n\n  /* Step 5a */\n  if( z[0]=='e' ){\n    if( m_gt_1(z+1) ){\n      z++;\n    }else if( m_eq_1(z+1) && !star_oh(z+1) ){\n      z++;\n    }\n  }\n\n  /* Step 5b */\n  if( m_gt_1(z) && z[0]=='l' && z[1]=='l' ){\n    z++;\n  }\n\n  /* z[] is now the stemmed word in reverse order.  Flip it back\n  ** around into forward order and return.\n  */\n  *pnOut = i = strlen(z);\n  zOut[i] = 0;\n  while( *z ){\n    zOut[--i] = *(z++);\n  }\n}\n\n/*\n** Characters that can be part of a token.  We assume any character\n** who",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_porter.c",
        "start": 124,
        "end": 563,
        "startLoc": {
          "line": 124,
          "column": 5,
          "position": 543
        },
        "endLoc": {
          "line": 563,
          "column": 9,
          "position": 4192
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 125,
        "end": 565,
        "startLoc": {
          "line": 125,
          "column": 13,
          "position": 566
        },
        "endLoc": {
          "line": 565,
          "column": 13,
          "position": 4208
        }
      }
    },
    {
      "format": "c",
      "lines": 45,
      "fragment": "se value is greater than 0x80 (any UTF character) can be\n** part of a token.  In other words, delimiters all must have\n** values of 0x7f or lower.\n*/\nstatic const char isIdChar[] = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 4x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  /* 5x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 6x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  /* 7x */\n};\n#define idChar(C)  (((ch=C)&0x80)!=0 || (ch>0x2f && isIdChar[ch-0x30]))\n#define isDelim(C) (((ch=C)&0x80)==0 && (ch<0x30 || !isIdChar[ch-0x30]))\n\n/*\n** Extract the next token from a tokenization cursor.  The cursor must\n** have been opened by a prior call to porterOpen().\n*/\nstatic int porterNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by porterOpen */\n  const char **pzToken,               /* OUT: *pzToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  const char *z = c->zInput;\n\n  while( c->iOffset<c->nInput ){\n    int iStartOffset, ch;\n\n    /* Scan past delimiter characters */\n    while( c->iOffset<c->nInput && isDelim(z[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n   ",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_porter.c",
        "start": 563,
        "end": 607,
        "startLoc": {
          "line": 563,
          "column": 9,
          "position": 4193
        },
        "endLoc": {
          "line": 607,
          "column": 8,
          "position": 4741
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_porter.c",
        "start": 580,
        "end": 608,
        "startLoc": {
          "line": 580,
          "column": 13,
          "position": 4281
        },
        "endLoc": {
          "line": 608,
          "column": 16,
          "position": 4756
        }
      }
    },
    {
      "format": "c",
      "lines": 31,
      "fragment": " /* Count non-delimiter characters. */\n    iStartOffset = c->iOffset;\n    while( c->iOffset<c->nInput && !isDelim(z[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    if( c->iOffset>iStartOffset ){\n      int n = c->iOffset-iStartOffset;\n      if( n>c->nAllocated ){\n        c->nAllocated = n+20;\n        c->zToken = realloc(c->zToken, c->nAllocated);\n        if( c->zToken==NULL ) return SQLITE_NOMEM;\n      }\n      porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes);\n      *pzToken = c->zToken;\n      *piStartOffset = iStartOffset;\n      *piEndOffset = c->iOffset;\n      *piPosition = c->iToken++;\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_DONE;\n}\n\n/*\n** The set of routines that implem",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_porter.c",
        "start": 607,
        "end": 637,
        "startLoc": {
          "line": 607,
          "column": 8,
          "position": 4742
        },
        "endLoc": {
          "line": 637,
          "column": 33,
          "position": 4906
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_porter.c",
        "start": 608,
        "end": 638,
        "startLoc": {
          "line": 608,
          "column": 16,
          "position": 4757
        },
        "endLoc": {
          "line": 638,
          "column": 33,
          "position": 4921
        }
      }
    },
    {
      "format": "c",
      "lines": 18,
      "fragment": "H->xFree(elem);\n    elem = next_elem;\n  }\n  pH->count = 0;\n}\n\n/*\n** Hash and comparison functions when the mode is FTS1_HASH_STRING\n*/\nstatic int strHash(const void *pKey, int nKey){\n  const char *z = (const char *)pKey;\n  int h = 0;\n  if( nKey<=0 ) nKey = (int) strlen(z);\n  while( nKey > 0  ){\n    h = (h<<3) ^ h ^ *z++;\n    nKey--;\n  }\n  return h & 0x7fffffff;\n}\nstatic int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){\n  if( n1!=n2 ) return 1;\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 92,
        "end": 109,
        "startLoc": {
          "line": 92,
          "column": 1,
          "position": 390
        },
        "endLoc": {
          "line": 109,
          "column": 3,
          "position": 595
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 99,
        "end": 116,
        "startLoc": {
          "line": 99,
          "column": 1,
          "position": 383
        },
        "endLoc": {
          "line": 116,
          "column": 3,
          "position": 588
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": " return strncmp((const char*)pKey1,(const char*)pKey2,n1);\n}\n\n/*\n** Hash and comparison functions when the mode is FTS1_HASH_BINARY\n*/\nstatic int binHash(const void *pKey, int nKey){\n  int h = 0;\n  const char *z = (const char *)pKey;\n  while( nKey-- > 0 ){\n    h = (h<<3) ^ h ^ *(z++);\n  }\n  return h & 0x7fffffff;\n}\nstatic int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){\n  if( n1!=n2 ) return 1;\n  return memcmp(pKey1,pKey2,n1);\n}\n\n/*\n** Return a pointer to the appropriate hash function given the key class.\n**\n** The C syntax in this function definition may be unfamilar to some \n** programmers, so we provide the following additional explanation:\n**\n** The name of the function is \"hashFunction\".  The function takes a\n** single parameter \"keyClass\".  The return value of hashFunction()\n** is a pointer to another function.  Specifically, the return value\n** of hashFunction() is a pointer to a function that takes two parameters\n** with types \"cons",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 110,
        "end": 136,
        "startLoc": {
          "line": 110,
          "column": 1,
          "position": 597
        },
        "endLoc": {
          "line": 136,
          "column": 17,
          "position": 795
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 117,
        "end": 143,
        "startLoc": {
          "line": 117,
          "column": 1,
          "position": 590
        },
        "endLoc": {
          "line": 143,
          "column": 17,
          "position": 788
        }
      }
    },
    {
      "format": "c",
      "lines": 24,
      "fragment": "ht *pEntry,  /* The entry into which pNew is inserted */\n  fts1HashElem *pNew       /* The element to be inserted */\n){\n  fts1HashElem *pHead;     /* First element already in pEntry */\n  pHead = pEntry->chain;\n  if( pHead ){\n    pNew->next = pHead;\n    pNew->prev = pHead->prev;\n    if( pHead->prev ){ pHead->prev->next = pNew; }\n    else             { pH->first = pNew; }\n    pHead->prev = pNew;\n  }else{\n    pNew->next = pH->first;\n    if( pH->first ){ pH->first->prev = pNew; }\n    pNew->prev = 0;\n    pH->first = pNew;\n  }\n  pEntry->count++;\n  pEntry->chain = pNew;\n}\n\n\n/* Resize the hash table so that it cantains \"new_size\" bucket",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 166,
        "end": 189,
        "startLoc": {
          "line": 166,
          "column": 2,
          "position": 958
        },
        "endLoc": {
          "line": 189,
          "column": 9,
          "position": 1148
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 171,
        "end": 196,
        "startLoc": {
          "line": 171,
          "column": 2,
          "position": 953
        },
        "endLoc": {
          "line": 196,
          "column": 9,
          "position": 1141
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": ")==0 );\n  new_ht = (struct _fts1ht *)pH->xMalloc( new_size*sizeof(struct _fts1ht) );\n  if( new_ht==0 ) return;\n  if( pH->ht ) pH->xFree(pH->ht);\n  pH->ht = new_ht;\n  pH->htsize = new_size;\n  xHash = hashFunction(pH->keyClass);\n  for(elem=pH->first, pH->first=0; elem; elem = next_elem){\n    int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1);\n    next_elem = elem->next;\n    insertElement(pH, &new_ht[h], elem);\n  }\n}\n\n/* This function (for internal use only) locates an element in an\n** hash table tha",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 197,
        "end": 212,
        "startLoc": {
          "line": 197,
          "column": 6,
          "position": 1280
        },
        "endLoc": {
          "line": 212,
          "column": 13,
          "position": 1416
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 204,
        "end": 219,
        "startLoc": {
          "line": 204,
          "column": 13,
          "position": 1260
        },
        "endLoc": {
          "line": 219,
          "column": 13,
          "position": 1396
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "nts left to test */\n  int (*xCompare)(const void*,int,const void*,int);  /* comparison function */\n\n  if( pH->ht ){\n    struct _fts1ht *pEntry = &pH->ht[h];\n    elem = pEntry->chain;\n    count = pEntry->count;\n    xCompare = compareFunction(pH->keyClass);\n    while( count-- && elem ){\n      if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){ \n        return elem;\n      }\n      elem = elem->next;\n    }\n  }\n  return 0;\n}\n\n/* Remove a single entry fr",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 223,
        "end": 241,
        "startLoc": {
          "line": 223,
          "column": 2,
          "position": 1520
        },
        "endLoc": {
          "line": 241,
          "column": 9,
          "position": 1653
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 230,
        "end": 248,
        "startLoc": {
          "line": 230,
          "column": 2,
          "position": 1500
        },
        "endLoc": {
          "line": 248,
          "column": 9,
          "position": 1633
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "Elem* elem,   /* The element to be removed from the pH */\n  int h                 /* Hash value for the element */\n){\n  struct _fts1ht *pEntry;\n  if( elem->prev ){\n    elem->prev->next = elem->next; \n  }else{\n    pH->first = elem->next;\n  }\n  if( elem->next ){\n    elem->next->prev = elem->prev;\n  }\n  pEntry = &pH->ht[h];\n  if( pEntry->chain==elem ){\n    pEntry->ch",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 245,
        "end": 263,
        "startLoc": {
          "line": 245,
          "column": 2,
          "position": 1685
        },
        "endLoc": {
          "line": 263,
          "column": 3,
          "position": 1856
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 253,
        "end": 271,
        "startLoc": {
          "line": 253,
          "column": 2,
          "position": 1675
        },
        "endLoc": {
          "line": 271,
          "column": 13,
          "position": 1846
        }
      }
    },
    {
      "format": "c",
      "lines": 28,
      "fragment": "void *sqlite3Fts1HashFind(const fts1Hash *pH, const void *pKey, int nKey){\n  int h;                 /* A hash on key */\n  fts1HashElem *elem;    /* The element that matches key */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  if( pH==0 || pH->ht==0 ) return 0;\n  xHash = hashFunction(pH->keyClass);\n  assert( xHash!=0 );\n  h = (*xHash)(pKey,nKey);\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  elem = findElementGivenHash(pH,pKey,nKey, h & (pH->htsize-1));\n  return elem ? elem->data : 0;\n}\n\n/* Insert an element into the hash table pH.  The key is pKey,nKey\n** and the data is \"data\".\n**\n** If no element exists with a matching key, then a new\n** element is created.  A copy of the key is made if the copyKey\n** flag is set.  NULL is returned.\n**\n** If another element already exists with the same key, then the\n** new data replaces the old data and the old data is returned.\n** The key is not copied in this instance.  If a malloc fails, then\n** the new data is returned and the hash table is unchanged.\n**\n** If the \"data\" parame",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 280,
        "end": 307,
        "startLoc": {
          "line": 280,
          "column": 2,
          "position": 1979
        },
        "endLoc": {
          "line": 307,
          "column": 22,
          "position": 2145
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 287,
        "end": 314,
        "startLoc": {
          "line": 287,
          "column": 2,
          "position": 1955
        },
        "endLoc": {
          "line": 314,
          "column": 22,
          "position": 2121
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "  /* the hash of the key modulo hash table size */\n  fts1HashElem *elem;       /* Used to loop thru the element list */\n  fts1HashElem *new_elem;   /* New element added to the pH */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  assert( pH!=0 );\n  xHash = hashFunction(pH->keyClass);\n  assert( xHash!=0 );\n  hraw = (*xHash)(pKey, nKey);\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  h = hraw & (pH->htsize-1);\n  elem = findElementGivenHash(pH,pKey,nKey,h);\n  if( elem ){\n    void *old_data = elem->data;\n    if( data==0 ){\n      removeElementGivenH",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 316,
        "end": 336,
        "startLoc": {
          "line": 316,
          "column": 2,
          "position": 2215
        },
        "endLoc": {
          "line": 336,
          "column": 13,
          "position": 2445
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 323,
        "end": 343,
        "startLoc": {
          "line": 323,
          "column": 2,
          "position": 2191
        },
        "endLoc": {
          "line": 343,
          "column": 13,
          "position": 2421
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "0 ) return data;\n  if( pH->copyKey && pKey!=0 ){\n    new_elem->pKey = pH->xMalloc( nKey );\n    if( new_elem->pKey==0 ){\n      pH->xFree(new_elem);\n      return data;\n    }\n    memcpy((void*)new_elem->pKey, pKey, nKey);\n  }else{\n    new_elem->pKey = (void*)pKey;\n  }\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 341,
        "end": 354,
        "startLoc": {
          "line": 341,
          "column": 6,
          "position": 2527
        },
        "endLoc": {
          "line": 354,
          "column": 3,
          "position": 2645
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 348,
        "end": 361,
        "startLoc": {
          "line": 348,
          "column": 13,
          "position": 2497
        },
        "endLoc": {
          "line": 361,
          "column": 13,
          "position": 2615
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "lem->nKey = nKey;\n  pH->count++;\n  if( pH->htsize==0 ){\n    rehash(pH,8);\n    if( pH->htsize==0 ){\n      pH->count = 0;\n      pH->xFree(new_elem);\n      return data;\n    }\n  }\n  if( pH->count > pH->htsize ){\n    rehash(pH,pH->htsize*2);\n  }\n  assert( pH->htsize>0 );\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  h = hraw & (pH->htsize-1);\n  inse",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 354,
        "end": 369,
        "startLoc": {
          "line": 354,
          "column": 6,
          "position": 2648
        },
        "endLoc": {
          "line": 369,
          "column": 59,
          "position": 2792
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 361,
        "end": 376,
        "startLoc": {
          "line": 361,
          "column": 13,
          "position": 2616
        },
        "endLoc": {
          "line": 376,
          "column": 59,
          "position": 2760
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "or to reset a hash table\n** to the empty state.\n*/\nvoid HashClear(Hash *pH){\n  HashElem *elem;         /* For looping over all elements of the table */\n\n  assert( pH!=0 );\n  elem = pH->first;\n  pH->first = 0;\n  if( p",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 63,
        "end": 72,
        "startLoc": {
          "line": 63,
          "column": 2,
          "position": 242
        },
        "endLoc": {
          "line": 72,
          "column": 9,
          "position": 330
        }
      },
      "secondFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 70,
        "end": 79,
        "startLoc": {
          "line": 70,
          "column": 2,
          "position": 224
        },
        "endLoc": {
          "line": 79,
          "column": 13,
          "position": 312
        }
      }
    },
    {
      "format": "c",
      "lines": 18,
      "fragment": "y1<pKey2 ) return -1;\n  return 1;\n}\n#endif\n\n/*\n** Hash and comparison functions when the mode is HASH_STRING\n*/\nstatic int strHash(const void *pKey, int nKey){\n  const char *z = (const char *)pKey;\n  int h = 0;\n  if( nKey<=0 ) nKey = (int) strlen(z);\n  while( nKey > 0  ){\n    h = (h<<3) ^ h ^ *z++;\n    nKey--;\n  }\n  return h & 0x7fffffff;\n}\nstatic int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){\n  if( n1!=n2 ) return 1;\n  return strncmp((",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 112,
        "end": 129,
        "startLoc": {
          "line": 112,
          "column": 1,
          "position": 638
        },
        "endLoc": {
          "line": 129,
          "column": 3,
          "position": 843
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 99,
        "end": 116,
        "startLoc": {
          "line": 99,
          "column": 1,
          "position": 383
        },
        "endLoc": {
          "line": 116,
          "column": 3,
          "position": 588
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": "onst char*)pKey1,(const char*)pKey2,n1);\n}\n\n/*\n** Hash and comparison functions when the mode is HASH_BINARY\n*/\nstatic int binHash(const void *pKey, int nKey){\n  int h = 0;\n  const char *z = (const char *)pKey;\n  while( nKey-- > 0 ){\n    h = (h<<3) ^ h ^ *(z++);\n  }\n  return h & 0x7fffffff;\n}\nstatic int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){\n  if( n1!=n2 ) return 1;\n  return memcmp(pKey1,pKey2,n1);\n}\n\n/*\n** Return a pointer to the appropriate hash function given the key class.\n**\n** The C syntax in this function definition may be unfamilar to some \n** programmers, so we provide the following additional explanation:\n**\n** The name of the function is \"hashFunction\".  The function takes a\n** single parameter \"keyClass\".  The return value of hashFunction()\n** is a pointer to another function.  Specifically, the return value\n** of hashFunction() is a pointer to a function that takes two parameters\n** with types \"const void*\" and \"int\" and returns an \"in",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 130,
        "end": 156,
        "startLoc": {
          "line": 130,
          "column": 1,
          "position": 845
        },
        "endLoc": {
          "line": 156,
          "column": 47,
          "position": 1037
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 117,
        "end": 143,
        "startLoc": {
          "line": 117,
          "column": 1,
          "position": 590
        },
        "endLoc": {
          "line": 143,
          "column": 3,
          "position": 783
        }
      }
    },
    {
      "format": "c",
      "lines": 24,
      "fragment": "le */\n  struct _ht *pEntry,    /* The entry into which pNew is inserted */\n  HashElem *pNew         /* The element to be inserted */\n){\n  HashElem *pHead;       /* First element already in pEntry */\n  pHead = pEntry->chain;\n  if( pHead ){\n    pNew->next = pHead;\n    pNew->prev = pHead->prev;\n    if( pHead->prev ){ pHead->prev->next = pNew; }\n    else             { pH->first = pNew; }\n    pHead->prev = pNew;\n  }else{\n    pNew->next = pH->first;\n    if( pH->first ){ pH->first->prev = pNew; }\n    pNew->prev = 0;\n    pH->first = pNew;\n  }\n  pEntry->count++;\n  pEntry->chain = pNew;\n}\n\n\n/* Resize the hash table so that it cantains \"",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 208,
        "end": 231,
        "startLoc": {
          "line": 208,
          "column": 2,
          "position": 1361
        },
        "endLoc": {
          "line": 231,
          "column": 5,
          "position": 1551
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 171,
        "end": 196,
        "startLoc": {
          "line": 171,
          "column": 2,
          "position": 953
        },
        "endLoc": {
          "line": 196,
          "column": 9,
          "position": 1141
        }
      }
    },
    {
      "format": "c",
      "lines": 18,
      "fragment": "nst void*,int); /* The hash function */\n\n  assert( (new_size & (new_size-1))==0 );\n  new_ht = (struct _ht *)pH->xMalloc( new_size*sizeof(struct _ht) );\n  if( new_ht==0 ) return;\n  if( pH->ht ) pH->xFree(pH->ht);\n  pH->ht = new_ht;\n  pH->htsize = new_size;\n  xHash = hashFunction(pH->keyClass);\n  for(elem=pH->first, pH->first=0; elem; elem = next_elem){\n    int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1);\n    next_elem = elem->next;\n    insertElement(pH, &new_ht[h], elem);\n  }\n}\n\n/* This function (for internal use only) locates an element in an\n*",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 237,
        "end": 254,
        "startLoc": {
          "line": 237,
          "column": 4,
          "position": 1652
        },
        "endLoc": {
          "line": 254,
          "column": 9,
          "position": 1819
        }
      },
      "secondFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 195,
        "end": 219,
        "startLoc": {
          "line": 195,
          "column": 8,
          "position": 1249
        },
        "endLoc": {
          "line": 219,
          "column": 13,
          "position": 1396
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": " Number of elements left to test */\n  int (*xCompare)(const void*,int,const void*,int);  /* comparison function */\n\n  if( pH->ht ){\n    struct _ht *pEntry = &pH->ht[h];\n    elem = pEntry->chain;\n    count = pEntry->count;\n    xCompare = compareFunction(pH->keyClass);\n    while( count-- && elem ){\n      if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){ \n        return elem;\n      }\n      elem = elem->next;\n    }\n  }\n  return 0;\n}\n\n/* Remove a",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 265,
        "end": 283,
        "startLoc": {
          "line": 265,
          "column": 2,
          "position": 1923
        },
        "endLoc": {
          "line": 283,
          "column": 5,
          "position": 2056
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 230,
        "end": 248,
        "startLoc": {
          "line": 230,
          "column": 2,
          "position": 1500
        },
        "endLoc": {
          "line": 248,
          "column": 9,
          "position": 1633
        }
      }
    },
    {
      "format": "c",
      "lines": 26,
      "fragment": "ing \"elem\" */\n  HashElem* elem,   /* The element to be removed from the pH */\n  int h             /* Hash value for the element */\n){\n  struct _ht *pEntry;\n  if( elem->prev ){\n    elem->prev->next = elem->next; \n  }else{\n    pH->first = elem->next;\n  }\n  if( elem->next ){\n    elem->next->prev = elem->prev;\n  }\n  pEntry = &pH->ht[h];\n  if( pEntry->chain==elem ){\n    pEntry->chain = elem->next;\n  }\n  pEntry->count--;\n  if( pEntry->count<=0 ){\n    pEntry->chain = 0;\n  }\n  if( pH->copyKey && elem->pKey ){\n    pH->xFr",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 287,
        "end": 312,
        "startLoc": {
          "line": 287,
          "column": 2,
          "position": 2088
        },
        "endLoc": {
          "line": 312,
          "column": 10,
          "position": 2330
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 253,
        "end": 270,
        "startLoc": {
          "line": 253,
          "column": 2,
          "position": 1675
        },
        "endLoc": {
          "line": 270,
          "column": 14,
          "position": 1927
        }
      }
    },
    {
      "format": "c",
      "lines": 28,
      "fragment": ", or NULL if there is no match.\n*/\nvoid *HashFind(const Hash *pH, const void *pKey, int nKey){\n  int h;             /* A hash on key */\n  HashElem *elem;    /* The element that matches key */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  if( pH==0 || pH->ht==0 ) return 0;\n  xHash = hashFunction(pH->keyClass);\n  assert( xHash!=0 );\n  h = (*xHash)(pKey,nKey);\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  elem = findElementGivenHash(pH,pKey,nKey, h & (pH->htsize-1));\n  return elem ? elem->data : 0;\n}\n\n/* Insert an element into the hash table pH.  The key is pKey,nKey\n** and the data is \"data\".\n**\n** If no element exists with a matching key, then a new\n** element is created.  A copy of the key is made if the copyKey\n** flag is set.  NULL is returned.\n**\n** If another element already exists with the same key, then the\n** new data replaces the old data and the old data is returned.\n** The key is not copied in this instance.  If a malloc fails, then\n** the new data is returned and the hash table is unchanged.\n**\n",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 322,
        "end": 349,
        "startLoc": {
          "line": 322,
          "column": 2,
          "position": 2382
        },
        "endLoc": {
          "line": 349,
          "column": 11,
          "position": 2548
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 287,
        "end": 314,
        "startLoc": {
          "line": 287,
          "column": 2,
          "position": 1955
        },
        "endLoc": {
          "line": 314,
          "column": 22,
          "position": 2121
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "int h;                /* the hash of the key modulo hash table size */\n  HashElem *elem;       /* Used to loop thru the element list */\n  HashElem *new_elem;   /* New element added to the pH */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  assert( pH!=0 );\n  xHash = hashFunction(pH->keyClass);\n  assert( xHash!=0 );\n  hraw = (*xHash)(pKey, nKey);\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  h = hraw & (pH->htsize-1);\n  elem = findElementGivenHash(pH,pKey,nKey,h);\n  if( elem ){\n    void *old_data = elem->data;\n    if( data==0 ){\n      rem",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 353,
        "end": 373,
        "startLoc": {
          "line": 353,
          "column": 2,
          "position": 2604
        },
        "endLoc": {
          "line": 373,
          "column": 9,
          "position": 2834
        }
      },
      "secondFile": {
        "name": "ext/fts2/fts2_hash.c",
        "start": 323,
        "end": 343,
        "startLoc": {
          "line": 323,
          "column": 2,
          "position": 2191
        },
        "endLoc": {
          "line": 343,
          "column": 13,
          "position": 2421
        }
      }
    },
    {
      "format": "c",
      "lines": 32,
      "fragment": ";\n    }else{\n      elem->data = data;\n    }\n    return old_data;\n  }\n  if( data==0 ) return 0;\n  new_elem = (HashElem*)pH->xMalloc( sizeof(HashElem) );\n  if( new_elem==0 ) return data;\n  if( pH->copyKey && pKey!=0 ){\n    new_elem->pKey = pH->xMalloc( nKey );\n    if( new_elem->pKey==0 ){\n      pH->xFree(new_elem);\n      return data;\n    }\n    memcpy((void*)new_elem->pKey, pKey, nKey);\n  }else{\n    new_elem->pKey = (void*)pKey;\n  }\n  new_elem->nKey = nKey;\n  pH->count++;\n  if( pH->htsize==0 ){\n    rehash(pH,8);\n    if( pH->htsize==0 ){\n      pH->count = 0;\n      pH->xFree(new_elem);\n      return data;\n    }\n  }\n  if( pH->count > pH->htsize ){\n    rehash(pH,pH->htsize*2);\n  }\n  assert( pH->htsize>0 );\n  assert(",
      "tokens": 0,
      "firstFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 373,
        "end": 404,
        "startLoc": {
          "line": 373,
          "column": 9,
          "position": 2845
        },
        "endLoc": {
          "line": 404,
          "column": 2,
          "position": 3178
        }
      },
      "secondFile": {
        "name": "ext/fts1/fts1_hash.c",
        "start": 336,
        "end": 374,
        "startLoc": {
          "line": 336,
          "column": 13,
          "position": 2456
        },
        "endLoc": {
          "line": 374,
          "column": 2,
          "position": 2757
        }
      }
    },
    {
      "format": "cpp",
      "lines": 9,
      "fragment": "pace Windows::ApplicationModel::Activation;\nusing namespace Windows::Foundation;\nusing namespace Windows::Foundation::Collections;\nusing namespace Windows::UI::Xaml;\nusing namespace Windows::UI::Xaml::Controls;\nusing namespace Windows::UI::Xaml::Controls::Primitives;\nusing namespace Windows::UI::Xaml::Data;\nusing namespace Windows::UI::Xaml::Input;\n",
      "tokens": 0,
      "firstFile": {
        "name": "vsixtest/App.xaml.cpp",
        "start": 13,
        "end": 21,
        "startLoc": {
          "line": 13,
          "column": 11,
          "position": 45
        },
        "endLoc": {
          "line": 21,
          "column": 8,
          "position": 142
        }
      },
      "secondFile": {
        "name": "vsixtest/MainPage.xaml.cpp",
        "start": 12,
        "end": 20,
        "startLoc": {
          "line": 12,
          "column": 9,
          "position": 26
        },
        "endLoc": {
          "line": 20,
          "column": 6,
          "position": 123
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "hexValue(argv[i][1]);\n      uX = (uX<<7) + (x&0x7f);\n      if( (x&0x80)==0 ) break;\n    }\n    if( i==9 && i<argc ){\n      if( strlen(argv[i])!=2 ){\n        fprintf(stderr, \"Not a hex byte: %s\\n\",",
      "tokens": 0,
      "firstFile": {
        "name": "tool/varint.c",
        "start": 83,
        "end": 89,
        "startLoc": {
          "line": 83,
          "column": 2,
          "position": 806
        },
        "endLoc": {
          "line": 89,
          "column": 2,
          "position": 894
        }
      },
      "secondFile": {
        "name": "tool/varint.c",
        "start": 74,
        "end": 80,
        "startLoc": {
          "line": 74,
          "column": 3,
          "position": 672
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 760
        }
      }
    },
    {
      "format": "tcl",
      "lines": 18,
      "fragment": "set line {}\nwhile {![eof stdin]} {\n  if {$line!=\"\"} {\n    puts -nonewline \"> \"\n  } else {\n    puts -nonewline \"% \"\n  }\n  flush stdout\n  append line [gets stdin]\n  if {[info complete $line]} {\n    if {[catch {uplevel #0 $line} result]} {\n      puts stderr \"Error: $result\"\n    } elseif {$result!=\"\"} {\n      puts $result\n    }\n    set line {}\n  } else {\n    append line \\\\n\"",
      "tokens": 0,
      "firstFile": {
        "name": "tool/sqltclsh.tcl",
        "start": 52,
        "end": 69,
        "startLoc": {
          "line": 52,
          "column": 1,
          "position": 445
        },
        "endLoc": {
          "line": 69,
          "column": 5,
          "position": 597
        }
      },
      "secondFile": {
        "name": "ext/repair/sqlite3_checker.tcl",
        "start": 21,
        "end": 38,
        "startLoc": {
          "line": 21,
          "column": 3,
          "position": 105
        },
        "endLoc": {
          "line": 38,
          "column": 3,
          "position": 258
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": " nSql = fread(zSql, 1, nSql, in);\n  zSql[nSql] = 0;\n\n  printf(\"SQLite version: %d\\n\", sqlite3_libversion_number());\n  unlink(argv[1]);\n#if !defined(_MSC_VER)\n  clkStart = times(&tmsStart);\n#endif\n  iStart = sqlite3Hwtime();\n  rc = sqlite3_open(argv[1], &db);\n ",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest8.c",
        "start": 204,
        "end": 213,
        "startLoc": {
          "line": 204,
          "column": 3,
          "position": 1319
        },
        "endLoc": {
          "line": 213,
          "column": 8,
          "position": 1444
        }
      },
      "secondFile": {
        "name": "tool/speedtest8inst1.c",
        "start": 193,
        "end": 202,
        "startLoc": {
          "line": 193,
          "column": 3,
          "position": 1355
        },
        "endLoc": {
          "line": 202,
          "column": 8,
          "position": 1480
        }
      }
    },
    {
      "format": "tcl",
      "lines": 26,
      "fragment": "set ones {zero one two three four five six seven eight nine\n          ten eleven twelve thirteen fourteen fifteen sixteen seventeen\n          eighteen nineteen}\nset tens {{} ten twenty thirty forty fifty sixty seventy eighty ninety}\nproc number_name {n} {\n  if {$n>=1000} {\n    set txt \"[number_name [expr {$n/1000}]] thousand\"\n    set n [expr {$n%1000}]\n  } else {\n    set txt {}\n  }\n  if {$n>=100} {\n    append txt \" [lindex $::ones [expr {$n/100}]] hundred\"\n    set n [expr {$n%100}]\n  }\n  if {$n>=20} {\n    append txt \" [lindex $::tens [expr {$n/10}]]\"\n    set n [expr {$n%10}]\n  }\n  if {$n>0} {\n    append txt \" [lindex $::ones $n]\"\n  }\n  set txt [string trim $txt]\n  if {$txt==\"\"} {set txt zero}\n  return $txt\n}",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest2.tcl",
        "start": 90,
        "end": 115,
        "startLoc": {
          "line": 90,
          "column": 1,
          "position": 850
        },
        "endLoc": {
          "line": 115,
          "column": 2,
          "position": 1124
        }
      },
      "secondFile": {
        "name": "ext/session/session_common.tcl",
        "start": 190,
        "end": 215,
        "startLoc": {
          "line": 190,
          "column": 1,
          "position": 1635
        },
        "endLoc": {
          "line": 215,
          "column": 2,
          "position": 1909
        }
      }
    },
    {
      "format": "tcl",
      "lines": 68,
      "fragment": "for {set i 1} {$i<=25000} {incr i} {\n  set r [expr {int(rand()*500000)}]\n  puts $fd \"INSERT INTO t1 VALUES($i,$r,'[number_name $r]');\"\n}\nputs $fd \"COMMIT;\"\nclose $fd\nruntest {25000 INSERTs in a transaction}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"DELETE FROM t1;\"\nclose $fd\nruntest {DELETE everything}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"BEGIN;\"\nfor {set i 1} {$i<=25000} {incr i} {\n  set r [expr {int(rand()*500000)}]\n  puts $fd \"INSERT INTO t1 VALUES($i,$r,'[number_name $r]');\"\n}\nputs $fd \"COMMIT;\"\nclose $fd\nruntest {25000 INSERTs in a transaction}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"DELETE FROM t1;\"\nclose $fd\nruntest {DELETE everything}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"BEGIN;\"\nfor {set i 1} {$i<=25000} {incr i} {\n  set r [expr {int(rand()*500000)}]\n  puts $fd \"INSERT INTO t1 VALUES($i,$r,'[number_name $r]');\"\n}\nputs $fd \"COMMIT;\"\nclose $fd\nruntest {25000 INSERTs in a transaction}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"DELETE FROM t1;\"\nclose $fd\nruntest {DELETE everything}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"BEGIN;\"\nfor {set i 1} {$i<=25000} {incr i} {\n  set r [expr {int(rand()*500000)}]\n  puts $fd \"INSERT INTO t1 VALUES($i,$r,'[number_name $r]');\"\n}\nputs $fd \"COMMIT;\"\nclose $fd\nruntest {25000 INSERTs in a transaction}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"DELETE FROM t1;\"\nclose $fd\nruntest {DELETE everything}\n\n\nset fd [open test$cnt.sql w]\nputs $fd {",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest2.tcl",
        "start": 138,
        "end": 205,
        "startLoc": {
          "line": 138,
          "column": 1,
          "position": 1296
        },
        "endLoc": {
          "line": 205,
          "column": 2,
          "position": 1854
        }
      },
      "secondFile": {
        "name": "tool/speedtest2.tcl",
        "start": 121,
        "end": 137,
        "startLoc": {
          "line": 121,
          "column": 1,
          "position": 1156
        },
        "endLoc": {
          "line": 137,
          "column": 9,
          "position": 1294
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "= 0;\n\n  if( argc!=3 ){\n    fprintf(stderr, \"Usage: %s FILENAME SQL-SCRIPT\\n\"\n                    \"Runs SQL-SCRIPT as UTF16 against a UTF16 database\\n\",\n                    argv[0]);\n    exit(1);\n  }\n  in = fopen(argv[2], \"r\");\n  fseek(in, 0L, SEEK_END);\n  nSql = ftell(in);\n  zSql = malloc( n",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest16.c",
        "start": 116,
        "end": 129,
        "startLoc": {
          "line": 116,
          "column": 2,
          "position": 643
        },
        "endLoc": {
          "line": 129,
          "column": 6,
          "position": 780
        }
      },
      "secondFile": {
        "name": "tool/speedtest8.c",
        "start": 182,
        "end": 197,
        "startLoc": {
          "line": 182,
          "column": 7,
          "position": 1097
        },
        "endLoc": {
          "line": 197,
          "column": 9,
          "position": 1236
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": ");\n  rc = sqlite3_open16(utf16, &db);\n  iElapse = sqlite3Hwtime() - iStart;\n  iSetup = iElapse;\n  printf(\"sqlite3_open16() returns %d in %llu cycles\\n\", rc, iElapse);\n  free(utf16);\n  for(i=j=0; j<nSql; j++){\n    if( zSql[j]==';' ){\n      int isComplete;\n      char c = zSql[j+1];\n      zSql[j+1] = 0;\n      isComplete ",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest16.c",
        "start": 135,
        "end": 147,
        "startLoc": {
          "line": 135,
          "column": 6,
          "position": 857
        },
        "endLoc": {
          "line": 147,
          "column": 6,
          "position": 1015
        }
      },
      "secondFile": {
        "name": "tool/speedtest8.c",
        "start": 203,
        "end": 204,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1315
        },
        "endLoc": {
          "line": 204,
          "column": 14,
          "position": 1509
        }
      }
    },
    {
      "format": "tcl",
      "lines": 35,
      "fragment": "#!/usr/bin/tclsh\n#\n# Run this script using TCLSH to do a speed comparison between\n# various versions of SQLite and PostgreSQL and MySQL\n#\n\n# Run a test\n#\nset cnt 1\nproc runtest {title} {\n  global cnt\n  set sqlfile test$cnt.sql\n  puts \"<h2>Test $cnt: $title</h2>\"\n  incr cnt\n  set fd [open $sqlfile r]\n  set sql [string trim [read $fd [file size $sqlfile]]]\n  close $fd\n  set sx [split $sql \\n]\n  set n [llength $sx]\n  if {$n>8} {\n    set sql {}\n    for {set i 0} {$i<3} {incr i} {append sql [lindex $sx $i]<br>\\n}\n    append sql  \"<i>... [expr {$n-6}] lines omitted</i><br>\\n\"\n    for {set i [expr {$n-3}]} {$i<$n} {incr i} {\n      append sql [lindex $sx $i]<br>\\n\n    }\n  } else {\n    regsub -all \\n [string trim $sql] <br> sql\n  }\n  puts \"<blockquote>\"\n  puts \"$sql\"\n  puts \"</blockquote><table border=0 cellpadding=0 cellspacing=0>\"\n  set format {<tr><td>%s</td><td align=\"right\">&nbsp;&nbsp;&nbsp;%.3f</td></tr>}\n  set delay 1000\n#  exec sync; after $delay;",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest.tcl",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 28,
          "position": 354
        }
      },
      "secondFile": {
        "name": "tool/speedtest2.tcl",
        "start": 1,
        "end": 35,
        "startLoc": {
          "line": 1,
          "column": 1,
          "position": 0
        },
        "endLoc": {
          "line": 35,
          "column": 5,
          "position": 355
        }
      }
    },
    {
      "format": "tcl",
      "lines": 12,
      "fragment": "exec sync; after $delay;\n  set t [time \"exec mysql -f drh <$sqlfile\" 1]\n  set t [expr {[lindex $t 0]/1000000.0}]\n  puts [format $format MySQL: $t]\n#  set t [time \"exec ./sqlite232 s232.db <$sqlfile\" 1]\n#  set t [expr {[lindex $t 0]/1000000.0}]\n#  puts [format $format {SQLite 2.3.2:} $t]\n#  set t [time \"exec ./sqlite-100 s100.db <$sqlfile\" 1]\n#  set t [expr {[lindex $t 0]/1000000.0}]\n#  puts [format $format {SQLite 2.4 (cache=100):} $t]\n  exec sync; after $delay;\n  set t [time \"exec ./sqlite248 s2k.db <$sqlfile\"",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest.tcl",
        "start": 39,
        "end": 50,
        "startLoc": {
          "line": 39,
          "column": 3,
          "position": 363
        },
        "endLoc": {
          "line": 50,
          "column": 36,
          "position": 454
        }
      },
      "secondFile": {
        "name": "tool/speedtest2.tcl",
        "start": 39,
        "end": 50,
        "startLoc": {
          "line": 39,
          "column": 3,
          "position": 416
        },
        "endLoc": {
          "line": 50,
          "column": 36,
          "position": 507
        }
      }
    },
    {
      "format": "tcl",
      "lines": 26,
      "fragment": "(nosync):} $t]\n#  set t [time \"exec ./sqlite-t1 st1.db <$sqlfile\" 1]\n#  set t [expr {[lindex $t 0]/1000000.0}]\n#  puts [format $format {SQLite 2.4 (test):} $t]\n  puts \"</table>\"\n}\n\n# Initialize the environment\n#\nexpr srand(1)\ncatch {exec /bin/sh -c {rm -f s*.db}}\nset fd [open clear.sql w]\nputs $fd {\n  drop table t1;\n  drop table t2;\n}\nclose $fd\ncatch {exec psql drh <clear.sql}\ncatch {exec mysql drh <clear.sql}\nset fd [open 2kinit.sql w]\nputs $fd {\n  PRAGMA default_cache_size=2000;\n  PRAGMA default_synchronous=on;\n}\nclose $fd\nexec ./sqlite248",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest.tcl",
        "start": 64,
        "end": 89,
        "startLoc": {
          "line": 64,
          "column": 2,
          "position": 695
        },
        "endLoc": {
          "line": 89,
          "column": 10,
          "position": 861
        }
      },
      "secondFile": {
        "name": "tool/speedtest2.tcl",
        "start": 56,
        "end": 81,
        "startLoc": {
          "line": 56,
          "column": 2,
          "position": 613
        },
        "endLoc": {
          "line": 81,
          "column": 10,
          "position": 779
        }
      }
    },
    {
      "format": "tcl",
      "lines": 32,
      "fragment": "<nosync-init.sql\nset ones {zero one two three four five six seven eight nine\n          ten eleven twelve thirteen fourteen fifteen sixteen seventeen\n          eighteen nineteen}\nset tens {{} ten twenty thirty forty fifty sixty seventy eighty ninety}\nproc number_name {n} {\n  if {$n>=1000} {\n    set txt \"[number_name [expr {$n/1000}]] thousand\"\n    set n [expr {$n%1000}]\n  } else {\n    set txt {}\n  }\n  if {$n>=100} {\n    append txt \" [lindex $::ones [expr {$n/100}]] hundred\"\n    set n [expr {$n%100}]\n  }\n  if {$n>=20} {\n    append txt \" [lindex $::tens [expr {$n/10}]]\"\n    set n [expr {$n%10}]\n  }\n  if {$n>0} {\n    append txt \" [lindex $::ones $n]\"\n  }\n  set txt [string trim $txt]\n  if {$txt==\"\"} {set txt zero}\n  return $txt\n}\n\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));\"",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest.tcl",
        "start": 98,
        "end": 129,
        "startLoc": {
          "line": 98,
          "column": 2,
          "position": 938
        },
        "endLoc": {
          "line": 129,
          "column": 57,
          "position": 1241
        }
      },
      "secondFile": {
        "name": "tool/speedtest2.tcl",
        "start": 89,
        "end": 119,
        "startLoc": {
          "line": 89,
          "column": 2,
          "position": 845
        },
        "endLoc": {
          "line": 119,
          "column": 9,
          "position": 1147
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "an index}\n\n\nset fd [open test$cnt.sql w]\nputs $fd \"BEGIN;\"\nfor {set i 1} {$i<=25000} {incr i} {\n  set r [expr {int(rand()*500000)}]\n  puts $fd \"UPDATE t2 SET c='[number_name $r]' WHERE a=$i;\"",
      "tokens": 0,
      "firstFile": {
        "name": "tool/speedtest.tcl",
        "start": 212,
        "end": 219,
        "startLoc": {
          "line": 212,
          "column": 2,
          "position": 2005
        },
        "endLoc": {
          "line": 219,
          "column": 49,
          "position": 2084
        }
      },
      "secondFile": {
        "name": "tool/speedtest.tcl",
        "start": 200,
        "end": 208,
        "startLoc": {
          "line": 200,
          "column": 2,
          "position": 1900
        },
        "endLoc": {
          "line": 208,
          "column": 33,
          "position": 1980
        }
      }
    },
    {
      "format": "tcl",
      "lines": 26,
      "fragment": "#\nproc tclsh {} {\n  set line {}\n  while {![eof stdin]} {\n    if {$line!=\"\"} {\n      puts -nonewline \"> \"\n    } else {\n      puts -nonewline \"% \"\n    }\n    flush stdout\n    append line [gets stdin]\n    if {[info complete $line]} {\n      if {[catch {uplevel #0 $line} result]} {\n        puts stderr \"Error: $result\"\n      } elseif {$result!=\"\"} {\n        puts $result\n      }\n      set line {}\n    } else {\n      append line \\n\n    }\n  }\n}\n\n\n# Get the name of the database to analyze",
      "tokens": 0,
      "firstFile": {
        "name": "tool/spaceanal.tcl",
        "start": 29,
        "end": 54,
        "startLoc": {
          "line": 29,
          "column": 1,
          "position": 160
        },
        "endLoc": {
          "line": 54,
          "column": 42,
          "position": 337
        }
      },
      "secondFile": {
        "name": "ext/repair/sqlite3_checker.tcl",
        "start": 19,
        "end": 43,
        "startLoc": {
          "line": 19,
          "column": 1,
          "position": 93
        },
        "endLoc": {
          "line": 43,
          "column": 54,
          "position": 269
        }
      }
    },
    {
      "format": "tcl",
      "lines": 11,
      "fragment": "set root_filename $file_to_analyze\nregexp {^file:(//)?([^?]*)} $file_to_analyze all x1 root_filename\nif {![file exists $root_filename]} {\n  puts stderr \"No such file: $root_filename\"\n  exit 1\n}\nif {![file readable $root_filename]} {\n  puts stderr \"File is not readable: $root_filename\"\n  exit 1\n}\nset",
      "tokens": 0,
      "firstFile": {
        "name": "tool/spaceanal.tcl",
        "start": 107,
        "end": 117,
        "startLoc": {
          "line": 107,
          "column": 1,
          "position": 894
        },
        "endLoc": {
          "line": 117,
          "column": 4,
          "position": 989
        }
      },
      "secondFile": {
        "name": "ext/repair/sqlite3_checker.tcl",
        "start": 204,
        "end": 215,
        "startLoc": {
          "line": 204,
          "column": 1,
          "position": 1581
        },
        "endLoc": {
          "line": 215,
          "column": 3,
          "position": 1677
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "b32(x1);\n    }\n    pCksum->s0 += x0 + pCksum->s1;\n    pCksum->s1 += x1 + pCksum->s0;\n    nByte -= 8;\n    a32 += 2;\n  }\n}\n\n/*\n** Convert the var-int format into i64.  Return the number of bytes\n** in the var-int.  Write the ",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showwal.c",
        "start": 96,
        "end": 108,
        "startLoc": {
          "line": 96,
          "column": 2,
          "position": 628
        },
        "endLoc": {
          "line": 108,
          "column": 3,
          "position": 761
        }
      },
      "secondFile": {
        "name": "ext/misc/scrub.c",
        "start": 279,
        "end": 292,
        "startLoc": {
          "line": 279,
          "column": 2,
          "position": 2064
        },
        "endLoc": {
          "line": 292,
          "column": 3,
          "position": 2197
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "ata<=pLimit ){\n    n = decodeVarint(a, &x);\n    a += n;\n    i -= n;\n    nLocal -= n;\n    zDesc[0] = sep;\n    sep = ',';\n    nDesc++;\n    zDesc++;\n    if( x==0 ){\n      sprintf(zDesc, \"*\");     /* NULL is a \"*\" */\n    }else if( x>=1 && x<=6 ){\n      v = (signed char)pData[0];\n      pData++;\n      switch",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showwal.c",
        "start": 318,
        "end": 324,
        "startLoc": {
          "line": 318,
          "column": 9,
          "position": 2741
        },
        "endLoc": {
          "line": 324,
          "column": 8,
          "position": 2914
        }
      },
      "secondFile": {
        "name": "ext/misc/dbdata.c",
        "start": 420,
        "end": 427,
        "startLoc": {
          "line": 420,
          "column": 11,
          "position": 2438
        },
        "endLoc": {
          "line": 427,
          "column": 3,
          "position": 2613
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "pe.h>\n#include \"sqlite3.h\"\n\n#define ISPRINT(X)  isprint((unsigned char)(X))\n\ntypedef sqlite3_int64 i64;   /* 64-bit signed integer type */\n\n\n/*\n** Convert the var-int format into i64.  Return the number of bytes\n** in the var-int.  Write the var-int value into *pVal.\n*/\nstatic int decodeVarint(const unsigned char *z, i64 *pVal){\n  i64 v = 0;\n  int i;\n  for(i=0; i<8; i++){\n    v",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showstat4.c",
        "start": 17,
        "end": 35,
        "startLoc": {
          "line": 17,
          "column": 1,
          "position": 21
        },
        "endLoc": {
          "line": 35,
          "column": 4,
          "position": 184
        }
      },
      "secondFile": {
        "name": "tool/showwal.c",
        "start": 91,
        "end": 292,
        "startLoc": {
          "line": 91,
          "column": 1,
          "position": 600
        },
        "endLoc": {
          "line": 292,
          "column": 3,
          "position": 2197
        }
      }
    },
    {
      "format": "c",
      "lines": 25,
      "fragment": "at.h>\n#include <fcntl.h>\n#include <assert.h>\n\n#define ISDIGIT(X)  isdigit((unsigned char)(X))\n#define ISPRINT(X)  isprint((unsigned char)(X))\n\n#if !defined(_MSC_VER)\n#include <unistd.h>\n#include <sys/types.h>\n#else\n#include <io.h>\n#endif\n\n#include <stdlib.h>\n#include <string.h>\n\nstatic int fd = -1;             /* The open SHM file */\n\n/* Report an out-of-memory error and die.\n*/\nstatic void out_of_memory(void){\n  fprintf(stderr,\"Out of memory...\\n\");\n  exit(1);\n}\n\n/*\n** Read content from the fil",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showshm.c",
        "start": 26,
        "end": 50,
        "startLoc": {
          "line": 26,
          "column": 1,
          "position": 37
        },
        "endLoc": {
          "line": 50,
          "column": 3,
          "position": 160
        }
      },
      "secondFile": {
        "name": "tool/showwal.c",
        "start": 107,
        "end": 131,
        "startLoc": {
          "line": 107,
          "column": 1,
          "position": 761
        },
        "endLoc": {
          "line": 131,
          "column": 3,
          "position": 884
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "alues\n*/\n#define FG_HEX     1    /* Show as hex */\n#define FG_NBO     2    /* Native byte order */\n#define FG_PGSZ    4    /* Show as page-size */\n\n/* Print a line of decode output showing a 4-byte integer.\n*/\nstatic void print_decode_line(\n  unsigned char *aData,      /* Content being decoded */\n  int ofst, int nByte,       /* Start and size of decode */\n  unsigned flg,              /* Display flags */\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showshm.c",
        "start": 61,
        "end": 77,
        "startLoc": {
          "line": 61,
          "column": 3,
          "position": 211
        },
        "endLoc": {
          "line": 77,
          "column": 6,
          "position": 405
        }
      },
      "secondFile": {
        "name": "tool/showwal.c",
        "start": 179,
        "end": 195,
        "startLoc": {
          "line": 179,
          "column": 3,
          "position": 1335
        },
        "endLoc": {
          "line": 195,
          "column": 6,
          "position": 1529
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "bel[100];\n    sprintf(zLabel, \"aReadMark[%d]\", j);\n    print_decode_line(aData, 4*j+4+i, 4, FG_NBO, zLabel);\n  }\n  print_decode_line(aData,24+i, 8, 0,       \"aL",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showshm.c",
        "start": 143,
        "end": 151,
        "startLoc": {
          "line": 143,
          "column": 23,
          "position": 1208
        },
        "endLoc": {
          "line": 151,
          "column": 6,
          "position": 1287
        }
      },
      "secondFile": {
        "name": "tool/showwal.c",
        "start": 519,
        "end": 527,
        "startLoc": {
          "line": 519,
          "column": 34,
          "position": 4879
        },
        "endLoc": {
          "line": 527,
          "column": 6,
          "position": 4958
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "nsigned val = aData[ofst];\n  char zBuf[100];\n  sprintf(zBuf, \" %05x: %02x\", ofst, aData[ofst]);\n  i = (int)strlen(zBuf);\n  for(j=1; j<4; j++){\n    if( j>=nByte ){\n      sprintf(&zBuf[i], \"   \");\n    }else{\n      sprintf(&zBuf[i], \" %02x\", aData[ofst+j]);\n      val = va",
      "tokens": 0,
      "firstFile": {
        "name": "tool/showjournal.c",
        "start": 55,
        "end": 66,
        "startLoc": {
          "line": 55,
          "column": 14,
          "position": 383
        },
        "endLoc": {
          "line": 66,
          "column": 8,
          "position": 524
        }
      },
      "secondFile": {
        "name": "tool/showwal.c",
        "start": 184,
        "end": 195,
        "startLoc": {
          "line": 184,
          "column": 14,
          "position": 1385
        },
        "endLoc": {
          "line": 195,
          "column": 3,
          "position": 1526
        }
      }
    },
    {
      "format": "bash",
      "lines": 19,
      "fragment": "--reprepare)\n        SPEEDTEST_OPTS=\"$SPEEDTEST_OPTS $1\"\n        ;;\n    --autovacuum)\n        SPEEDTEST_OPTS=\"$SPEEDTEST_OPTS $1\"\n        ;;\n    --utf16be)\n        SPEEDTEST_OPTS=\"$SPEEDTEST_OPTS $1\"\n        ;;\n    --stats)\n        SPEEDTEST_OPTS=\"$SPEEDTEST_OPTS $1\"\n        ;;\n    --without-rowid)\n        SPEEDTEST_OPTS=\"$SPEEDTEST_OPTS $1\"\n        ;;\n    --nomemstat)\n        SPEEDTEST_OPTS=\"$SPEEDTEST_OPTS $1\"\n        ;;\n    --wal",
      "tokens": 0,
      "firstFile": {
        "name": "tool/run-speed-test.sh",
        "start": 30,
        "end": 48,
        "startLoc": {
          "line": 30,
          "column": 5,
          "position": 103
        },
        "endLoc": {
          "line": 48,
          "column": 6,
          "position": 205
        }
      },
      "secondFile": {
        "name": "tool/speed-check.sh",
        "start": 50,
        "end": 68,
        "startLoc": {
          "line": 50,
          "column": 5,
          "position": 200
        },
        "endLoc": {
          "line": 68,
          "column": 14,
          "position": 302
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "ude <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n\n/*\n** Compute signature for a block of content.\n**\n** For blocks of 16 or fewer bytes, the signature is just a hex dump of\n** the entire block.\n**\n** For blocks of more than 16 bytes, the signature is a hex dump of the\n** first 8 bytes followed by a 64-bit has of the entire block.\n*/\nstatic void vlogSignature(unsigned char *p, int n, char *zCksum){\n  unsigned int s0 = 0, s1 = 0;",
      "tokens": 0,
      "firstFile": {
        "name": "tool/pagesig.c",
        "start": 22,
        "end": 36,
        "startLoc": {
          "line": 22,
          "column": 1,
          "position": 7
        },
        "endLoc": {
          "line": 36,
          "column": 8,
          "position": 97
        }
      },
      "secondFile": {
        "name": "ext/misc/vfslog.c",
        "start": 345,
        "end": 359,
        "startLoc": {
          "line": 345,
          "column": 1,
          "position": 2408
        },
        "endLoc": {
          "line": 359,
          "column": 17,
          "position": 2498
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "  unsigned int *pI;\n  int i;\n  if( n<=16 ){\n    for(i=0; i<n; i++) sprintf(zCksum+i*2, \"%02x\", p[i]);\n  }else{ \n    pI = (unsigned int*)p;\n    for(i=0; i<n-7; i+=8){\n      s0 += pI[0] + s1;\n",
      "tokens": 0,
      "firstFile": {
        "name": "tool/pagesig.c",
        "start": 36,
        "end": 44,
        "startLoc": {
          "line": 36,
          "column": 2,
          "position": 99
        },
        "endLoc": {
          "line": 44,
          "column": 8,
          "position": 219
        }
      },
      "secondFile": {
        "name": "ext/misc/vfslog.c",
        "start": 359,
        "end": 367,
        "startLoc": {
          "line": 359,
          "column": 2,
          "position": 2503
        },
        "endLoc": {
          "line": 367,
          "column": 17,
          "position": 2623
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "0 ){\n    ofstError(p, \"no such column: %s.%s\", zTable, zColumn);\n    goto rootAndColumn_exit;\n  }\n\n  zSql = sqlite3_mprintf(\"PRAGMA page_size\");\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc )  ofstError(p, \"%s: [%s]\", sqlite3_errmsg(db), zSql);\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "tool/offsets.c",
        "start": 113,
        "end": 119,
        "startLoc": {
          "line": 113,
          "column": 19,
          "position": 851
        },
        "endLoc": {
          "line": 119,
          "column": 24,
          "position": 947
        }
      },
      "secondFile": {
        "name": "tool/offsets.c",
        "start": 79,
        "end": 85,
        "startLoc": {
          "line": 79,
          "column": 7,
          "position": 459
        },
        "endLoc": {
          "line": 85,
          "column": 27,
          "position": 555
        }
      }
    },
    {
      "format": "tcl",
      "lines": 38,
      "fragment": "}\n\f\nproc getEnvironmentVariable { name } {\n  #\n  # NOTE: Returns the value of the specified environment variable or an empty\n  #       string for environment variables that do not exist in the current\n  #       process environment.\n  #\n  return [expr {[info exists ::env($name)] ? $::env($name) : \"\"}]\n}\n\f\nproc getTemporaryPath {} {\n  #\n  # NOTE: Returns the normalized path to the first temporary directory found\n  #       in the typical set of environment variables used for that purpose\n  #       or an empty string to signal a failure to locate such a directory.\n  #\n  set names [list]\n\n  foreach name [list TEMP TMP] {\n    lappend names [string toupper $name] [string tolower $name] \\\n        [string totitle $name]\n  }\n\n  foreach name $names {\n    set value [getEnvironmentVariable $name]\n\n    if {[string length $value] > 0} then {\n      return [file normalize $value]\n    }\n  }\n\n  return \"\"\n}\n\f\nproc appendArgs { args } {\n  #\n  # NOTE: Returns all passed arguments joined together as a single string with",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mkvsix.tcl",
        "start": 110,
        "end": 147,
        "startLoc": {
          "line": 110,
          "column": 1,
          "position": 286
        },
        "endLoc": {
          "line": 147,
          "column": 77,
          "position": 532
        }
      },
      "secondFile": {
        "name": "vsixtest/vsixtest.tcl",
        "start": 86,
        "end": 123,
        "startLoc": {
          "line": 86,
          "column": 1,
          "position": 441
        },
        "endLoc": {
          "line": 123,
          "column": 72,
          "position": 687
        }
      }
    },
    {
      "format": "tcl",
      "lines": 29,
      "fragment": "#\n  eval append result $args\n}\n\f\nproc readFile { fileName } {\n  #\n  # NOTE: Reads and returns the entire contents of the specified file, which\n  #       may contain binary data.\n  #\n  set file_id [open $fileName RDONLY]\n  fconfigure $file_id -encoding binary -translation binary\n  set result [read $file_id]\n  close $file_id\n  return $result\n}\n\f\nproc writeFile { fileName data } {\n  #\n  # NOTE: Writes the entire contents of the specified file, which may contain\n  #       binary data.\n  #\n  set file_id [open $fileName {WRONLY CREAT TRUNC}]\n  fconfigure $file_id -encoding binary -translation binary\n  puts -nonewline $file_id $data\n  close $file_id\n  return \"\"\n}\n\f\n#",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mkvsix.tcl",
        "start": 149,
        "end": 177,
        "startLoc": {
          "line": 149,
          "column": 3,
          "position": 538
        },
        "endLoc": {
          "line": 177,
          "column": 2,
          "position": 725
        }
      },
      "secondFile": {
        "name": "vsixtest/vsixtest.tcl",
        "start": 125,
        "end": 153,
        "startLoc": {
          "line": 125,
          "column": 3,
          "position": 693
        },
        "endLoc": {
          "line": 153,
          "column": 5,
          "position": 880
        }
      }
    },
    {
      "format": "tcl",
      "lines": 12,
      "fragment": "]} then {\n  set shortName $shortNames($packageFlavor,$vsVersion)\n  set displayName $displayNames($packageFlavor,$vsVersion)\n  set targetPlatformIdentifier Windows\n  set targetPlatformVersion v8.0\n  set minVsVersion [getMinVsVersionXmlChunk $vsVersion]\n  set maxPlatformVersion \\\n      [getMaxPlatformVersionXmlChunk $packageFlavor $vsVersion]\n  set extraSdkPath \"\"\n  set extraFileListAttributes \\\n      [getExtraFileListXmlChunk $packageFlavor $vsVersion]\n} else",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mkvsix.tcl",
        "start": 474,
        "end": 485,
        "startLoc": {
          "line": 474,
          "column": 6,
          "position": 2986
        },
        "endLoc": {
          "line": 485,
          "column": 5,
          "position": 3092
        }
      },
      "secondFile": {
        "name": "tool/mkvsix.tcl",
        "start": 404,
        "end": 415,
        "startLoc": {
          "line": 404,
          "column": 6,
          "position": 2277
        },
        "endLoc": {
          "line": 415,
          "column": 7,
          "position": 2383
        }
      }
    },
    {
      "format": "tcl",
      "lines": 59,
      "fragment": "} {\n  set available_hdr($hdr) 1\n}\n\n# 78 stars used for comment formatting.\nset s78 \\\n{*****************************************************************************}\n\n# Insert a comment into the code\n#\nproc section_comment {text} {\n  global out s78\n  set n [string length $text]\n  set nstar [expr {60 - $n}]\n  set stars [string range $s78 0 $nstar]\n  puts $out \"/************** $text $stars/\"\n}\n\n# Read the source file named $filename and write it into the\n# sqlite3.c output file.  If any #include statements are seen,\n# process them approprately.\n#\nproc copy_file {filename} {\n  global seen_hdr available_hdr out\n  set tail [file tail $filename]\n  section_comment \"Begin file $tail\"\n  set in [open $filename r]\n  while {![eof $in]} {\n    set line [gets $in]\n    if {[regexp {^#\\s*include\\s+[\"<]([^\">]+)[\">]} $line all hdr]} {\n      if {[info exists available_hdr($hdr)]} {\n        if {$available_hdr($hdr)} {\n          section_comment \"Include $hdr in the middle of $tail\"\n          copy_file tsrc/$hdr\n          section_comment \"Continuing where we left off in $tail\"\n        }\n      } elseif {![info exists seen_hdr($hdr)]} {\n        set seen_hdr($hdr) 1\n        puts $out $line\n      }\n    } elseif {[regexp {^#ifdef __cplusplus} $line]} {\n      puts $out \"#if 0\"\n    } elseif {[regexp {^#line} $line]} {\n      # Skip #line directives.\n    } else {\n      puts $out $line\n    }\n  }\n  close $in\n  section_comment \"End of $tail\"\n}\n\n\n# Process the source files.  Process files containing commonly\n# used subroutines first in order to help the compiler find\n# inlining opportunities.\n#\nforeach file {\n   sqliteInt.h",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3internalh.tcl",
        "start": 75,
        "end": 133,
        "startLoc": {
          "line": 75,
          "column": 1,
          "position": 357
        },
        "endLoc": {
          "line": 133,
          "column": 12,
          "position": 795
        }
      },
      "secondFile": {
        "name": "ext/fts3/mkfts3amal.tcl",
        "start": 48,
        "end": 106,
        "startLoc": {
          "line": 48,
          "column": 1,
          "position": 349
        },
        "endLoc": {
          "line": 106,
          "column": 7,
          "position": 787
        }
      }
    },
    {
      "format": "tcl",
      "lines": 15,
      "fragment": "set in [open tsrc/sqlite3.h]\nset cnt 0\nset VERSION ?????\nwhile {![eof $in]} {\n  set line [gets $in]\n  if {$line==\"\" && [eof $in]} break\n  incr cnt\n  regexp {#define\\s+SQLITE_VERSION\\s+\"(.*)\"} $line all VERSION\n}\nclose $in\n\n# Open the output file and write a header comment at the beginning\n# of the file.\n#\nset out [open sqlite3.c",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 44,
        "end": 58,
        "startLoc": {
          "line": 44,
          "column": 1,
          "position": 223
        },
        "endLoc": {
          "line": 58,
          "column": 10,
          "position": 330
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3internalh.tcl",
        "start": 29,
        "end": 43,
        "startLoc": {
          "line": 29,
          "column": 1,
          "position": 55
        },
        "endLoc": {
          "line": 43,
          "column": 18,
          "position": 162
        }
      }
    },
    {
      "format": "tcl",
      "lines": 19,
      "fragment": "}\n\n# 78 stars used for comment formatting.\nset s78 \\\n{*****************************************************************************}\n\n# Insert a comment into the code\n#\nproc section_comment {text} {\n  global out s78\n  set n [string length $text]\n  set nstar [expr {60 - $n}]\n  set stars [string range $s78 0 $nstar]\n  puts $out \"/************** $text $stars/\"\n}\n\n# Read the source file named $filename and write it into the\n# sqlite3.c output file.  If any #include statements are seen,\n# process them appropriately.",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 163,
        "end": 181,
        "startLoc": {
          "line": 163,
          "column": 1,
          "position": 1136
        },
        "endLoc": {
          "line": 181,
          "column": 30,
          "position": 1277
        }
      },
      "secondFile": {
        "name": "ext/fts3/mkfts3amal.tcl",
        "start": 50,
        "end": 68,
        "startLoc": {
          "line": 50,
          "column": 1,
          "position": 364
        },
        "endLoc": {
          "line": 68,
          "column": 29,
          "position": 505
        }
      }
    },
    {
      "format": "tcl",
      "lines": 15,
      "fragment": "]} {\n          set line SQLITE_API\n          append line \" \" [string trim $rettype]\n          if {[string index $rettype end] ne \"*\"} {\n            append line \" \"\n          }\n          if {$useapicall} {\n            if {[lsearch -exact $cdecllist $funcname] >= 0} {\n              append line SQLITE_CDECL \" \"\n            } else {\n              append line SQLITE_APICALL \" \"\n            }\n          }\n          append line $funcname $rest\n          if",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 244,
        "end": 258,
        "startLoc": {
          "line": 244,
          "column": 9,
          "position": 2015
        },
        "endLoc": {
          "line": 258,
          "column": 3,
          "position": 2152
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3h.tcl",
        "start": 128,
        "end": 142,
        "startLoc": {
          "line": 128,
          "column": 5,
          "position": 1008
        },
        "endLoc": {
          "line": 142,
          "column": 2,
          "position": 1145
        }
      }
    },
    {
      "format": "tcl",
      "lines": 71,
      "fragment": "#\n# The amalgamated SQLite code will be written into sqlite3.c\n#\n\n# Begin by reading the \"sqlite3.h\" header file.  Extract the version number\n# from in this file.  The version number is needed to generate the header\n# comment of the amalgamation.\n#\nset addstatic 1\nset linemacros 0\nset useapicall 0\nfor {set i 0} {$i<[llength $argv]} {incr i} {\n  set x [lindex $argv $i]\n  if {[regexp {^-+nostatic$} $x]} {\n    set addstatic 0\n  } elseif {[regexp {^-+linemacros} $x]} {\n    set linemacros 1\n  } elseif {[regexp {^-+useapicall} $x]} {\n    set useapicall 1\n  } else {\n    error \"unknown command-line option: $x\"\n  }\n}\nset in [open tsrc/sqlite3.h]\nset cnt 0\nset VERSION ?????\nwhile {![eof $in]} {\n  set line [gets $in]\n  if {$line==\"\" && [eof $in]} break\n  incr cnt\n  regexp {#define\\s+SQLITE_VERSION\\s+\"(.*)\"} $line all VERSION\n}\nclose $in\n\n# Open the output file and write a header comment at the beginning\n# of the file.\n#\nset out [open sqlite3.c w]\n# Force the output to use unix line endings, even on Windows.\nfconfigure $out -translation lf\nset today [clock format [clock seconds] -format \"%Y-%m-%d %H:%M:%S UTC\" -gmt 1]\nputs $out [subst \\\n{/******************************************************************************\n** This file is an amalgamation of many separate C source files from SQLite\n** version $VERSION.  By combining all the individual C code files into this\n** single large file, the entire code can be compiled as a single translation\n** unit.  This allows many compilers to do optimizations that would not be\n** possible if the files were compiled separately.  Performance improvements\n** of 5% or more are commonly seen when SQLite is compiled as a single\n** translation unit.\n**\n** This file is all you need to compile SQLite.  To use SQLite in other\n** programs, you need this file and the \"sqlite3.h\" header file that defines\n** the programming interface to the SQLite library.  (If you do not have\n** the \"sqlite3.h\" header file at hand, you will find a copy embedded within\n** the text of this file.  Search for \"Begin file sqlite3.h\" to find the start\n** of the embedded sqlite3.h header file.) Additional code files may be needed\n** if you want a wrapper to interface SQLite with your choice of programming\n** language. The code for the \"sqlite3\" command-line shell is also in a\n** separate file. This file contains only code for the core SQLite library.\n*/\n#define SQLITE_CORE 1\n#define SQLITE_AMALGAMATION 1}]\nif {$addstatic} {\n  puts $out \\\n{#ifndef SQLITE_PRIVATE\n# define SQLITE_PRIVATE static\n#endif}\n}\n\n# These are the header files used by SQLite.  The first time any of these",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c-noext.tcl",
        "start": 21,
        "end": 91,
        "startLoc": {
          "line": 21,
          "column": 1,
          "position": 40
        },
        "endLoc": {
          "line": 91,
          "column": 74,
          "position": 874
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 21,
        "end": 91,
        "startLoc": {
          "line": 21,
          "column": 1,
          "position": 40
        },
        "endLoc": {
          "line": 91,
          "column": 63,
          "position": 874
        }
      }
    },
    {
      "format": "tcl",
      "lines": 53,
      "fragment": ") 0\n\n# These headers should be copied into the amalgamation without modifying any\n# of their function declarations or definitions.\nset varonly_hdr(sqlite3.h) 1\n\n# These are the functions that accept a variable number of arguments.  They\n# always need to use the \"cdecl\" calling convention even when another calling\n# convention (e.g. \"stcall\") is being used for the rest of the library.\nset cdecllist {\n  sqlite3_config\n  sqlite3_db_config\n  sqlite3_log\n  sqlite3_mprintf\n  sqlite3_snprintf\n  sqlite3_test_control\n  sqlite3_vtab_config\n}\n\n# 78 stars used for comment formatting.\nset s78 \\\n{*****************************************************************************}\n\n# Insert a comment into the code\n#\nproc section_comment {text} {\n  global out s78\n  set n [string length $text]\n  set nstar [expr {60 - $n}]\n  set stars [string range $s78 0 $nstar]\n  puts $out \"/************** $text $stars/\"\n}\n\n# Read the source file named $filename and write it into the\n# sqlite3.c output file.  If any #include statements are seen,\n# process them appropriately.\n#\nproc copy_file {filename} {\n  global seen_hdr available_hdr varonly_hdr cdecllist out\n  global addstatic linemacros useapicall\n  set ln 0\n  set tail [file tail $filename]\n  section_comment \"Begin file $tail\"\n  if {$linemacros} {puts $out \"#line 1 \\\"$filename\\\"\"}\n  set in [open $filename r]\n  set varpattern {^[a-zA-Z][a-zA-Z_0-9 *]+(sqlite3[_a-zA-Z0-9]+)(\\[|;| =)}\n  set declpattern {([a-zA-Z][a-zA-Z_0-9 ]+ \\**)(sqlite3[_a-zA-Z0-9]+)(\\(.*)}\n  if {[file extension $filename]==\".h\"} {\n    set declpattern \" *$declpattern\"\n  }\n  set declpattern ^$declpattern\\$\n  while {![eof $in]} {\n    set line [gets",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c-noext.tcl",
        "start": 125,
        "end": 177,
        "startLoc": {
          "line": 125,
          "column": 12,
          "position": 988
        },
        "endLoc": {
          "line": 177,
          "column": 5,
          "position": 1433
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 146,
        "end": 198,
        "startLoc": {
          "line": 146,
          "column": 17,
          "position": 1084
        },
        "endLoc": {
          "line": 198,
          "column": 7,
          "position": 1529
        }
      }
    },
    {
      "format": "tcl",
      "lines": 43,
      "fragment": "]\n    incr ln\n    if {[regexp {^\\s*#\\s*include\\s+[\"<]([^\">]+)[\">]} $line all hdr]} {\n      if {[info exists available_hdr($hdr)]} {\n        if {$available_hdr($hdr)} {\n          if {$hdr!=\"os_common.h\" && $hdr!=\"hwtime.h\"} {\n            set available_hdr($hdr) 0\n          }\n          section_comment \"Include $hdr in the middle of $tail\"\n          copy_file tsrc/$hdr\n          section_comment \"Continuing where we left off in $tail\"\n          if {$linemacros} {puts $out \"#line [expr {$ln+1}] \\\"$filename\\\"\"}\n        } else {\n          # Comment out the entire line, replacing any nested comment\n          # begin/end markers with the harmless substring \"**\".\n          puts $out \"/* [string map [list /* ** */ **] $line] */\"\n        }\n      } elseif {![info exists seen_hdr($hdr)]} {\n        if {![regexp {/\\*\\s+amalgamator:\\s+dontcache\\s+\\*/} $line]} {\n          set seen_hdr($hdr) 1\n        }\n        puts $out $line\n      } elseif {[regexp {/\\*\\s+amalgamator:\\s+keep\\s+\\*/} $line]} {\n        # This include file must be kept because there was a \"keep\"\n        # directive inside of a line comment.\n        puts $out $line\n      } else {\n        # Comment out the entire line, replacing any nested comment\n        # begin/end markers with the harmless substring \"**\".\n        puts $out \"/* [string map [list /* ** */ **] $line] */\"\n      }\n    } elseif {[regexp {^#ifdef __cplusplus} $line]} {\n      puts $out \"#if 0\"\n    } elseif {!$linemacros && [regexp {^#line} $line]} {\n      # Skip #line directives.\n    } elseif {$addstatic\n               && ![regexp {^(static|typedef|SQLITE_PRIVATE)} $line]} {\n      # Skip adding the SQLITE_PRIVATE or SQLITE_API keyword before\n      # functions if this header file does not need it.\n      if {![info exists varonly_hdr($tail)]\n       && [regexp $declpattern $line all rettype funcname rest]} {\n        regsub {^SQLITE_API } $line {} line\n        # Add the SQLITE_PRIVATE or SQLITE_API keyword before functions.",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c-noext.tcl",
        "start": 177,
        "end": 219,
        "startLoc": {
          "line": 177,
          "column": 3,
          "position": 1437
        },
        "endLoc": {
          "line": 219,
          "column": 65,
          "position": 1869
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 198,
        "end": 240,
        "startLoc": {
          "line": 198,
          "column": 2,
          "position": 1539
        },
        "endLoc": {
          "line": 240,
          "column": 7,
          "position": 1971
        }
      }
    },
    {
      "format": "tcl",
      "lines": 17,
      "fragment": "# Add the SQLITE_PRIVATE or SQLITE_API keyword before functions.\n        # so that linkage can be modified at compile-time.\n        if {[regexp {^sqlite3[a-z]*_} $funcname]} {\n          set line SQLITE_API\n          append line \" \" [string trim $rettype]\n          if {[string index $rettype end] ne \"*\"} {\n            append line \" \"\n          }\n          if {$useapicall} {\n            if {[lsearch -exact $cdecllist $funcname] >= 0} {\n              append line SQLITE_CDECL \" \"\n            } else {\n              append line SQLITE_APICALL \" \"\n            }\n          }\n          append line $funcname $rest\n          puts",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c-noext.tcl",
        "start": 219,
        "end": 235,
        "startLoc": {
          "line": 219,
          "column": 9,
          "position": 1869
        },
        "endLoc": {
          "line": 235,
          "column": 5,
          "position": 2032
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 242,
        "end": 142,
        "startLoc": {
          "line": 242,
          "column": 9,
          "position": 1989
        },
        "endLoc": {
          "line": 142,
          "column": 2,
          "position": 1145
        }
      }
    },
    {
      "format": "tcl",
      "lines": 42,
      "fragment": "} else {\n          puts $out \"SQLITE_PRIVATE $line\"\n        }\n      } elseif {[regexp $varpattern $line all varname]} {\n          # Add the SQLITE_PRIVATE before variable declarations or\n          # definitions for internal use\n          regsub {^SQLITE_API } $line {} line\n          if {![regexp {^sqlite3_} $varname]} {\n            regsub {^extern } $line {} line\n            puts $out \"SQLITE_PRIVATE $line\"\n          } else {\n            if {[regexp {const char sqlite3_version\\[\\];} $line]} {\n              set line {const char sqlite3_version[] = SQLITE_VERSION;}\n            }\n            regsub {^SQLITE_EXTERN } $line {} line\n            puts $out \"SQLITE_API $line\"\n          }\n      } elseif {[regexp {^(SQLITE_EXTERN )?void \\(\\*sqlite3IoTrace\\)} $line]} {\n        regsub {^SQLITE_API } $line {} line\n        regsub {^SQLITE_EXTERN } $line {} line\n        puts $out $line\n      } elseif {[regexp {^void \\(\\*sqlite3Os} $line]} {\n        regsub {^SQLITE_API } $line {} line\n        puts $out \"SQLITE_PRIVATE $line\"\n      } else {\n        puts $out $line\n      }\n    } else {\n      puts $out $line\n    }\n  }\n  close $in\n  section_comment \"End of $tail\"\n}\n\n\n# Process the source files.  Process files containing commonly\n# used subroutines first in order to help the compiler find\n# inlining opportunities.\n#\nforeach file {\n   sqliteInt.h",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksqlite3c-noext.tcl",
        "start": 236,
        "end": 277,
        "startLoc": {
          "line": 236,
          "column": 9,
          "position": 2041
        },
        "endLoc": {
          "line": 277,
          "column": 12,
          "position": 2431
        }
      },
      "secondFile": {
        "name": "tool/mksqlite3c.tcl",
        "start": 265,
        "end": 306,
        "startLoc": {
          "line": 265,
          "column": 9,
          "position": 2203
        },
        "endLoc": {
          "line": 306,
          "column": 8,
          "position": 2593
        }
      }
    },
    {
      "format": "tcl",
      "lines": 28,
      "fragment": "set ones {zero one two three four five six seven eight nine\n          ten eleven twelve thirteen fourteen fifteen sixteen seventeen\n          eighteen nineteen}\nset tens {{} ten twenty thirty forty fifty sixty seventy eighty ninety}\nproc number_name {n} {\n  if {$n>=1000} {\n    set txt \"[number_name [expr {$n/1000}]] thousand\"\n    set n [expr {$n%1000}]\n  } else {\n    set txt {}\n  }\n  if {$n>=100} {\n    append txt \" [lindex $::ones [expr {$n/100}]] hundred\"\n    set n [expr {$n%100}]\n  }\n  if {$n>=20} {\n    append txt \" [lindex $::tens [expr {$n/10}]]\"\n    set n [expr {$n%10}]\n  }\n  if {$n>0} {\n    append txt \" [lindex $::ones $n]\"\n  }\n  set txt [string trim $txt]\n  if {$txt==\"\"} {set txt zero}\n  return $txt\n}\n\n# Create a database schema.",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mkspeedsql.tcl",
        "start": 26,
        "end": 53,
        "startLoc": {
          "line": 26,
          "column": 1,
          "position": 53
        },
        "endLoc": {
          "line": 53,
          "column": 28,
          "position": 330
        }
      },
      "secondFile": {
        "name": "ext/session/session_common.tcl",
        "start": 190,
        "end": 118,
        "startLoc": {
          "line": 190,
          "column": 1,
          "position": 1635
        },
        "endLoc": {
          "line": 118,
          "column": 4,
          "position": 1128
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "er\n** using C-preprocessor macros.  If that is unsuccessful, or if\n** -DBYTEORDER=0 is set, then byte-order is determined\n** at run-time.\n*/\n#ifndef BYTEORDER\n# if defined(i386)     || defined(__i386__)   || defined(_M_IX86) ||    \\\n     defined(__x86_64) || defined(__x86_64__) || defined(_M_X64)  ||    \\\n     defined(_M_AMD64) || defined(_M_ARM)     || defined(__x86)   ||    \\\n     defined(__arm__)\n#   define BYTEORDER    1234\n# elif defined(sparc)    || defined(__ppc__)\n#   define BYTEORDER    4321\n# else\n#   define BYTEORDER 0\n# endif\n#endif\n\n\n\n/*\n** State structure for a SHA3 hash in progress\n*/\ntypedef struct SHA3Conte",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 48,
        "end": 67,
        "startLoc": {
          "line": 48,
          "column": 1,
          "position": 53
        },
        "endLoc": {
          "line": 67,
          "column": 3,
          "position": 157
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 62,
        "end": 81,
        "startLoc": {
          "line": 62,
          "column": 1,
          "position": 35
        },
        "endLoc": {
          "line": 81,
          "column": 3,
          "position": 139
        }
      }
    },
    {
      "format": "c",
      "lines": 44,
      "fragment": "         /* Keccak state. 5x5 lines of 64 bits each */\n    unsigned char x[1600];    /* ... or 1600 bytes */\n  } u;\n  unsigned nRate;        /* Bytes of input accepted per Keccak iteration */\n  unsigned nLoaded;      /* Input bytes loaded into u.x[] so far this cycle */\n  unsigned ixMask;       /* Insert next input into u.x[nLoaded^ixMask]. */\n};\n\n/*\n** A single step of the Keccak mixing function for a 1600-bit state\n*/\nstatic void KeccakF1600Step(SHA3Context *p){\n  int i;\n  u64 B0, B1, B2, B3, B4;\n  u64 C0, C1, C2, C3, C4;\n  u64 D0, D1, D2, D3, D4;\n  static const u64 RC[] = {\n    0x0000000000000001ULL,  0x0000000000008082ULL,\n    0x800000000000808aULL,  0x8000000080008000ULL,\n    0x00000000000",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 69,
        "end": 112,
        "startLoc": {
          "line": 69,
          "column": 3,
          "position": 206
        },
        "endLoc": {
          "line": 112,
          "column": 3,
          "position": 358
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 83,
        "end": 126,
        "startLoc": {
          "line": 83,
          "column": 3,
          "position": 188
        },
        "endLoc": {
          "line": 126,
          "column": 3,
          "position": 340
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "   B0 ^((~B1)&  B2 );\n    A31 =   B1 ^((~B2)&  B3 );\n    A42 =   B2 ^((~B3)&  B4 );\n    A03 =   B3 ^((~B4)&  B0 );\n    A14 =   B4 ^((~B0)&  B1 );\n\n    B4 = ROL64((A40^D0),",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 183,
        "end": 191,
        "startLoc": {
          "line": 183,
          "column": 4,
          "position": 1557
        },
        "endLoc": {
          "line": 191,
          "column": 4,
          "position": 1660
        }
      },
      "secondFile": {
        "name": "tool/mksourceid.c",
        "start": 116,
        "end": 124,
        "startLoc": {
          "line": 116,
          "column": 4,
          "position": 435
        },
        "endLoc": {
          "line": 124,
          "column": 4,
          "position": 538
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "   B0 ^((~B1)&  B2 );\n    A21 =   B1 ^((~B2)&  B3 );\n    A02 =   B2 ^((~B3)&  B4 );\n    A33 =   B3 ^((~B4)&  B0 );\n    A14 =   B4 ^((~B0)&  B1 );\n\n    B4 = ROL64((A30^D0),",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 250,
        "end": 258,
        "startLoc": {
          "line": 250,
          "column": 4,
          "position": 2681
        },
        "endLoc": {
          "line": 258,
          "column": 4,
          "position": 2784
        }
      },
      "secondFile": {
        "name": "tool/mksourceid.c",
        "start": 116,
        "end": 124,
        "startLoc": {
          "line": 116,
          "column": 4,
          "position": 435
        },
        "endLoc": {
          "line": 124,
          "column": 4,
          "position": 538
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "   B0 ^((~B1)&  B2 );\n    A01 =   B1 ^((~B2)&  B3 );\n    A22 =   B2 ^((~B3)&  B4 );\n    A43 =   B3 ^((~B4)&  B0 );\n    A14 =   B4 ^((~B0)&  B1 );\n\n    B4 = ROL64((A10^D0),",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 317,
        "end": 325,
        "startLoc": {
          "line": 317,
          "column": 4,
          "position": 3805
        },
        "endLoc": {
          "line": 325,
          "column": 4,
          "position": 3908
        }
      },
      "secondFile": {
        "name": "tool/mksourceid.c",
        "start": 116,
        "end": 124,
        "startLoc": {
          "line": 116,
          "column": 4,
          "position": 435
        },
        "endLoc": {
          "line": 124,
          "column": 4,
          "position": 538
        }
      }
    },
    {
      "format": "c",
      "lines": 101,
      "fragment": " = ROL64((A10^D0), 3);\n    B3 = ROL64((A11^D1), 45);\n    B4 = ROL64((A12^D2), 61);\n    B0 = ROL64((A13^D3), 28);\n    B1 = ROL64((A14^D4), 20);\n    A10 =   B0 ^((~B1)&  B2 );\n    A11 =   B1 ^((~B2)&  B3 );\n    A12 =   B2 ^((~B3)&  B4 );\n    A13 =   B3 ^((~B4)&  B0 );\n    A14 =   B4 ^((~B0)&  B1 );\n\n    B4 = ROL64((A20^D0), 18);\n    B0 = ROL64((A21^D1), 1);\n    B1 = ROL64((A22^D2), 6);\n    B2 = ROL64((A23^D3), 25);\n    B3 = ROL64((A24^D4), 8);\n    A20 =   B0 ^((~B1)&  B2 );\n    A21 =   B1 ^((~B2)&  B3 );\n    A22 =   B2 ^((~B3)&  B4 );\n    A23 =   B3 ^((~B4)&  B0 );\n    A24 =   B4 ^((~B0)&  B1 );\n\n    B1 = ROL64((A30^D0), 36);\n    B2 = ROL64((A31^D1), 10);\n    B3 = ROL64((A32^D2), 15);\n    B4 = ROL64((A33^D3), 56);\n    B0 = ROL64((A34^D4), 27);\n    A30 =   B0 ^((~B1)&  B2 );\n    A31 =   B1 ^((~B2)&  B3 );\n    A32 =   B2 ^((~B3)&  B4 );\n    A33 =   B3 ^((~B4)&  B0 );\n    A34 =   B4 ^((~B0)&  B1 );\n\n    B3 = ROL64((A40^D0), 41);\n    B4 = ROL64((A41^D1), 2);\n    B0 = ROL64((A42^D2), 62);\n    B1 = ROL64((A43^D3), 55);\n    B2 = ROL64((A44^D4), 39);\n    A40 =   B0 ^((~B1)&  B2 );\n    A41 =   B1 ^((~B2)&  B3 );\n    A42 =   B2 ^((~B3)&  B4 );\n    A43 =   B3 ^((~B4)&  B0 );\n    A44 =   B4 ^((~B0)&  B1 );\n  }\n}\n\n/*\n** Initialize a new hash.  iSize determines the size of the hash\n** in bits and should be one of 224, 256, 384, or 512.  Or iSize\n** can be zero to use the default hash size of 256 bits.\n*/\nstatic void SHA3Init(SHA3Context *p, int iSize){\n  memset(p, 0, sizeof(*p));\n  if( iSize>=128 && iSize<=512 ){\n    p->nRate = (1600 - ((iSize + 31)&~31)*2)/8;\n  }else{\n    p->nRate = (1600 - 2*256)/8;\n  }\n#if BYTEORDER==1234\n  /* Known to be little-endian at compile-time. No-op */\n#elif BYTEORDER==4321\n  p->ixMask = 7;  /* Big-endian */\n#else\n  {\n    static unsigned int one = 1;\n    if( 1==*(unsigned char*)&one ){\n      /* Little endian.  No byte swapping. */\n      p->ixMask = 0;\n    }else{\n      /* Big endian.  Byte swap. */\n      p->ixMask = 7;\n    }\n  }\n#endif\n}\n\n/*\n** Make consecutive calls to the SHA3Update function to add new content\n** to the hash\n*/\nstatic void SHA3Update(\n  SHA3Context *p,\n  const unsigned char *aData,\n  unsigned int nData\n){\n  unsigned int i = 0;\n#if BYTEORDER==1234\n  if( (p->nLoaded % 8)==0 && ((aData - (const unsigned char*)0)&",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 378,
        "end": 478,
        "startLoc": {
          "line": 378,
          "column": 2,
          "position": 4847
        },
        "endLoc": {
          "line": 478,
          "column": 3,
          "position": 5617
        }
      },
      "secondFile": {
        "name": "ext/misc/shathree.c",
        "start": 392,
        "end": 487,
        "startLoc": {
          "line": 392,
          "column": 2,
          "position": 4829
        },
        "endLoc": {
          "line": 487,
          "column": 79,
          "position": 5598
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": " Return the number of errors.\n*/\nstatic int sha3sum_file(const char *zFilename, int iSize, char *pCksum){\n  FILE *in;\n  SHA3Context ctx;\n  char zBuf[10240];\n\n  in = fopen(zFilename,\"rb\");\n  if( in==0 ){\n    return 1;\n  }\n  SHA3Init(&ctx, iSize);\n  for(;;){\n    int n = (int)fread(zBuf, 1, s",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 570,
        "end": 580,
        "startLoc": {
          "line": 570,
          "column": 2,
          "position": 6029
        },
        "endLoc": {
          "line": 580,
          "column": 44,
          "position": 6129
        }
      },
      "secondFile": {
        "name": "ext/misc/sha1.c",
        "start": 66,
        "end": 79,
        "startLoc": {
          "line": 66,
          "column": 1,
          "position": 84
        },
        "endLoc": {
          "line": 79,
          "column": 38,
          "position": 186
        }
      }
    },
    {
      "format": "c",
      "lines": 49,
      "fragment": "of(zBuf), in);\n    if( n<=0 ) break;\n    SHA3Update(&ctx, (unsigned char*)zBuf, (unsigned)n);\n  }\n  fclose(in);\n  DigestToBase16(SHA3Final(&ctx), pCksum, iSize/8);\n  return 0;\n}\n\n/*\n** The SHA1 implementation below is adapted from:\n**\n**  $NetBSD: sha1.c,v 1.6 2009/11/06 20:31:18 joerg Exp $\n**  $OpenBSD: sha1.c,v 1.9 1997/07/23 21:12:32 kstailey Exp $\n**\n** SHA-1 in C\n** By Steve Reid <steve@edmweb.com>\n** 100% Public Domain\n*/\ntypedef struct SHA1Context SHA1Context;\nstruct SHA1Context {\n  unsigned int state[5];\n  unsigned int count[2];\n  unsigned char buffer[64];\n};\n\n/*\n * blk0() and blk() perform the initial expand.\n * I got the idea of expanding during the round function from SSLeay\n *\n * blk0le() for little-endian and blk0be() for big-endian.\n */\n#define SHA_ROT(x,l,r) ((x) << (l) | (x) >> (r))\n#define rol(x,k) SHA_ROT(x,k,32-(k))\n#define ror(x,k) SHA_ROT(x,32-(k),k)\n\n#define blk0le(i) (block[i] = (ror(block[i],8)&0xFF00FF00) \\\n    |(rol(block[i],8)&0x00FF00FF))\n#define blk0be(i) block[i]\n#define blk(i) (block[i&15] = rol(block[(i+13)&15]^block[(i+8)&15] \\\n    ^block[(i+2)&15]^block[i&15],1))\n\n/*\n * (R0+R1), R2, R3, R4 are the different operations (rounds) used in SHA1\n *\n * Rl0() for little-endian and Rb0() for big-endian.  Endianness is\n * determined at run-time.\n */\n#define Rl0(v,w,x,y,z,i) \\\n    z+=((w&(x^y))^y)+blk0le(i)+0x5A827999+rol(v,5);w=ror(w,2);\n#define Rb0(v,w,x,y,z,i) \\\n    z+=((w&(x^y))^y)+blk0be(i)+0x5A827999+rol(v,5);w=ror(w,2);\n#define R1(v,w,x,y,z,i) \\\n    z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=ror(w,2);\n#define R2(v,w,x,y,z,i) \\\n    z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=ror(w,2);\n#define R3(v,w,x,y,z,i) \\\n    z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=ror(w,2);\n#define R4(v,w,x,y,z,i) \\\n    z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=ror(w,2);\n\n/*\n * Hash a single 512-bit block. This is the core of the algorithm.\n */\n#define a qq[0]\n#define b qq[1]\n#define c qq[2]\n#define d qq[3]\n#define e qq[4]\n\nstatic void SHA1Transform(\n  unsigned int state[5],\n  const unsigned char buffer[64]\n){\n  unsigned int qq[5]; /* a, b, c, d, e; */\n  static int one = 1;\n  unsigned int block[16];\n  memcpy(block, buffer, 64);\n  memcpy(qq,state,5*sizeof(uns",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mksourceid.c",
        "start": 581,
        "end": 629,
        "startLoc": {
          "line": 581,
          "column": 3,
          "position": 6132
        },
        "endLoc": {
          "line": 629,
          "column": 4,
          "position": 7815
        }
      },
      "secondFile": {
        "name": "ext/misc/sha1.c",
        "start": 80,
        "end": 132,
        "startLoc": {
          "line": 80,
          "column": 3,
          "position": 189
        },
        "endLoc": {
          "line": 132,
          "column": 32,
          "position": 1878
        }
      }
    },
    {
      "format": "tcl",
      "lines": 9,
      "fragment": "$if]} continue\n  set seentype($type) 1\n  puts $fd [format {#define %-35s %4d} PragTyp_$type $pnum]\n  incr pnum\n}\nforeach name $allnames {\n  set type [lindex $allbyname($name) 0]\n  if {[info exists seentype($type)]} continue\n  set seentype",
      "tokens": 0,
      "firstFile": {
        "name": "tool/mkpragmatab.tcl",
        "start": 490,
        "end": 498,
        "startLoc": {
          "line": 490,
          "column": 2,
          "position": 3232
        },
        "endLoc": {
          "line": 498,
          "column": 9,
          "position": 3318
        }
      },
      "secondFile": {
        "name": "tool/mkpragmatab.tcl",
        "start": 481,
        "end": 489,
        "startLoc": {
          "line": 481,
          "column": 2,
          "position": 3122
        },
        "endLoc": {
          "line": 489,
          "column": 3,
          "position": 3208
        }
      }
    },
    {
      "format": "c",
      "lines": 30,
      "fragment": "perform the initial expand.\n * I got the idea of expanding during the round function from SSLeay\n *\n * blk0le() for little-endian and blk0be() for big-endian.\n */\n#define SHA_ROT(x,l,r) ((x) << (l) | (x) >> (r))\n#define rol(x,k) SHA_ROT(x,k,32-(k))\n#define ror(x,k) SHA_ROT(x,32-(k),k)\n\n#define blk0le(i) (block[i] = (ror(block[i],8)&0xFF00FF00) \\\n    |(rol(block[i],8)&0x00FF00FF))\n#define blk0be(i) block[i]\n#define blk(i) (block[i&15] = rol(block[(i+13)&15]^block[(i+8)&15] \\\n    ^block[(i+2)&15]^block[i&15],1))\n\n/*\n * (R0+R1), R2, R3, R4 are",
      "tokens": 0,
      "firstFile": {
        "name": "tool/dbhash.c",
        "start": 73,
        "end": 102,
        "startLoc": {
          "line": 73,
          "column": 1,
          "position": 131
        },
        "endLoc": {
          "line": 102,
          "column": 40,
          "position": 244
        }
      },
      "secondFile": {
        "name": "ext/misc/sha1.c",
        "start": 50,
        "end": 79,
        "startLoc": {
          "line": 50,
          "column": 1,
          "position": 73
        },
        "endLoc": {
          "line": 79,
          "column": 38,
          "position": 186
        }
      }
    },
    {
      "format": "c",
      "lines": 47,
      "fragment": "e different operations (rounds) used in SHA1\n *\n * Rl0() for little-endian and Rb0() for big-endian.  Endianness is\n * determined at run-time.\n */\n#define Rl0(v,w,x,y,z,i) \\\n    z+=((w&(x^y))^y)+blk0le(i)+0x5A827999+rol(v,5);w=ror(w,2);\n#define Rb0(v,w,x,y,z,i) \\\n    z+=((w&(x^y))^y)+blk0be(i)+0x5A827999+rol(v,5);w=ror(w,2);\n#define R1(v,w,x,y,z,i) \\\n    z+=((w&(x^y))^y)+blk(i)+0x5A827999+rol(v,5);w=ror(w,2);\n#define R2(v,w,x,y,z,i) \\\n    z+=(w^x^y)+blk(i)+0x6ED9EBA1+rol(v,5);w=ror(w,2);\n#define R3(v,w,x,y,z,i) \\\n    z+=(((w|x)&y)|(w&x))+blk(i)+0x8F1BBCDC+rol(v,5);w=ror(w,2);\n#define R4(v,w,x,y,z,i) \\\n    z+=(w^x^y)+blk(i)+0xCA62C1D6+rol(v,5);w=ror(w,2);\n\n/*\n * Hash a single 512-bit block. This is the core of the algorithm.\n */\n#define a qq[0]\n#define b qq[1]\n#define c qq[2]\n#define d qq[3]\n#define e qq[4]\n\nvoid SHA1Transform(unsigned int state[5], const unsigned char buffer[64]){\n  unsigned int qq[5]; /* a, b, c, d, e; */\n  static int one = 1;\n  unsigned int block[16];\n  memcpy(block, buffer, 64);\n  memcpy(qq,state,5*sizeof(unsigned int));\n\n  /* Copy g.cx.state[] to working vars */\n  /*\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  */\n\n  /* 4 rounds of 20 operations each. Loop unrolled. */\n  if( 1 == *(unsigned char*)&one ){\n    Rl0(a,b,c,d,e, 0); Rl0(e,a,b,c,d, 1); Rl0(d,e,a,b,c, 2); Rl0(c,d,e,a,b, 3);\n    Rl0(b,c,d,e,a, 4); Rl0(a,b,c,d,e, 5); Rl0(e,a,b,c,d, 6); Rl0(d,e,a,b,c, 7);\n    Rl0(c,d,e,a,b, 8); Rl0(b,c,d,e,a, 9); Rl0(a,b,c,d,e,10); Rl0(e,a,b,c,d,11);\n    Rl0(d,e,a,b,c,12); Rl0(c,d,e,a,b,13); Rl0(b,c,d,e,a,14); Rl0(a,b,c,d,e,15);\n  }else{\n    Rb0(a,b,c,d,e, 0); Rb0(e,a,b,c,d, 1); Rb0(d,e,a,b,c, 2); Rb0(c,d,e,a,b, 3);\n    Rb0(b,c,d,e,a, 4); Rb0(a,b,c,d,e, 5); Rb0(e,a,b,c,d, 6); Rb0(d,e,a,b,c, 7);\n    Rb0(c,d,e,a,b, 8); Rb0(b,c,d,e,a, 9); Rb0(a,b,c,d,e,10); Rb0(e,a,b,c,d,11);\n    Rb0(d,e,a,b,c,12); Rb0(c,d,e,a,b,13); Rb0(b,c,d,e,a,14); Rb0(a,b,c,d,e,15);\n  }\n  R1(e,a,b,c,d,16); R1(d,e,a,b,c,17); R1(c,d,e,a,b,18); R1(b,c,d,e,a,19);\n  R2(a,b,c,d,e,20); R2(e,a,b,c,d,21); R2(d,e,a,b,c,22); R2(c,d,e,a,b,23);\n  R2(b,c,d,e,a,24); R2(a,b,c,d,e,25); R2(e,a,b,c,d,26); R2(d,e,a,b,c,27);\n  R2(c,d,e,a,b,28); R2(b,c,d,e,a,29",
      "tokens": 0,
      "firstFile": {
        "name": "tool/dbhash.c",
        "start": 103,
        "end": 149,
        "startLoc": {
          "line": 103,
          "column": 3,
          "position": 247
        },
        "endLoc": {
          "line": 149,
          "column": 31,
          "position": 1930
        }
      },
      "secondFile": {
        "name": "ext/misc/sha1.c",
        "start": 80,
        "end": 132,
        "startLoc": {
          "line": 80,
          "column": 3,
          "position": 189
        },
        "endLoc": {
          "line": 132,
          "column": 32,
          "position": 1878
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "j;\n\n  j = g.cx.count[0];\n  if( (g.cx.count[0] += len << 3) < j ){\n    g.cx.count[1] += (len>>29)+1;\n  }\n  j = (j >> 3) & 63;\n  if( (j + len) > 63 ){\n    (void)memcpy(&g.cx.buffer[j], data",
      "tokens": 0,
      "firstFile": {
        "name": "tool/dbhash.c",
        "start": 201,
        "end": 208,
        "startLoc": {
          "line": 201,
          "column": 2,
          "position": 2639
        },
        "endLoc": {
          "line": 208,
          "column": 7,
          "position": 2761
        }
      },
      "secondFile": {
        "name": "ext/misc/sha1.c",
        "start": 208,
        "end": 215,
        "startLoc": {
          "line": 208,
          "column": 3,
          "position": 2708
        },
        "endLoc": {
          "line": 215,
          "column": 2,
          "position": 2829
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "255); /* Endian independent */\n  }\n  hash_step((const unsigned char *)\"\\200\", 1);\n  while ((g.cx.count[0] & 504) != 448){\n    hash_step((const unsigned char *)\"\\0\", 1);\n  }\n",
      "tokens": 0,
      "firstFile": {
        "name": "tool/dbhash.c",
        "start": 231,
        "end": 237,
        "startLoc": {
          "line": 231,
          "column": 13,
          "position": 2884
        },
        "endLoc": {
          "line": 237,
          "column": 5,
          "position": 2956
        }
      },
      "secondFile": {
        "name": "tool/dbhash.c",
        "start": 217,
        "end": 223,
        "startLoc": {
          "line": 217,
          "column": 13,
          "position": 2786
        },
        "endLoc": {
          "line": 223,
          "column": 34,
          "position": 2858
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "s such as\\n\"\n\"sqlite_stat1, sqlite_stat4, and sqlite_sequence are omitted from the hash.\\n\"\n\"Options:\\n\"\n\"   --debug N           Set",
      "tokens": 0,
      "firstFile": {
        "name": "tool/dbhash.c",
        "start": 384,
        "end": 389,
        "startLoc": {
          "line": 384,
          "column": 2,
          "position": 4181
        },
        "endLoc": {
          "line": 389,
          "column": 8,
          "position": 4255
        }
      },
      "secondFile": {
        "name": "tool/index_usage.c",
        "start": 65,
        "end": 70,
        "startLoc": {
          "line": 65,
          "column": 2,
          "position": 274
        },
        "endLoc": {
          "line": 70,
          "column": 11,
          "position": 348
        }
      }
    },
    {
      "format": "csharp",
      "lines": 23,
      "fragment": "///////////////////////////////////////////////////////////////\r\n\r\n        #region Private Support Methods\r\n        /// <summary>\r\n        /// This method displays an error message to the console and/or\r\n        /// displays the command line usage information for this tool.\r\n        /// </summary>\r\n        /// <param name=\"message\">\r\n        /// The error message to display, if any.\r\n        /// </param>\r\n        /// <param name=\"usage\">\r\n        /// Non-zero to display the command line usage information.\r\n        /// </param>\r\n        private static void Error(\r\n            string message,\r\n            bool usage\r\n            )\r\n        {\r\n            if (message != null)\r\n                Console.WriteLine(message);\r\n\r\n            string fileName = Path.GetFileName(\r\n                Process.GetCurrentProcess().",
      "tokens": 0,
      "firstFile": {
        "name": "tool/GetFile.cs",
        "start": 149,
        "end": 171,
        "startLoc": {
          "line": 149,
          "column": 9,
          "position": 684
        },
        "endLoc": {
          "line": 171,
          "column": 30,
          "position": 820
        }
      },
      "secondFile": {
        "name": "tool/Replace.cs",
        "start": 86,
        "end": 108,
        "startLoc": {
          "line": 86,
          "column": 9,
          "position": 309
        },
        "endLoc": {
          "line": 108,
          "column": 58,
          "position": 423
        }
      }
    },
    {
      "format": "tcl",
      "lines": 28,
      "fragment": "(10,89), (11,81), (12,96), (13,59), (14,38), (15,68), (16,39), (17,62),\n  (18,91), (19,46), (20,6), (21,99), (22,97), (23,27), (24,46), (25,78),\n  (26,54), (27,97), (28,8), (29,67), (30,29), (31,93), (32,84), (33,77),\n  (34,23), (35,16), (36,16), (37,93), (38,65), (39,35), (40,47), (41,7),\n  (42,86), (43,74), (44,61), (45,91), (46,85), (47,24), (48,85), (49,43),\n  (50,59), (51,12), (52,32), (53,56), (54,3), (55,91), (56,22), (57,90),\n  (58,55), (59,15), (60,28), (61,89), (62,25), (63,47), (64,1), (65,56),\n  (66,40), (67,43), (68,56), (69,16), (70,75), (71,36), (72,89), (73,98),\n  (74,76), (75,81), (76,4), (77,94), (78,42), (79,30), (80,78), (81,33),\n  (82,29), (83,53), (84,63), (85,2), (86,87), (87,37), (88,80), (89,84),\n  (90,72), (91,41), (92,9), (93,61), (94,73), (95,95), (96,65), (97,13),\n  (98,58), (99,96), (100,98), (101,1), (102,21), (103,74), (104,65), (105,35),\n  (106,5), (107,73), (108,11), (109,51), (110,87), (111,41), (112,12), (113,8),\n  (114,20), (115,31), (116,31), (117,15), (118,95), (119,22), (120,73), \n  (121,79), (122,88), (123,34), (124,8), (125,11), (126,49), (127,34), \n  (128,90), (129,59), (130,96), (131,60), (132,55), (133,75), (134,77),\n  (135,44), (136,2), (137,7), (138,85), (139,57), (140,74), (141,29), (142,70),\n  (143,59), (144,19), (145,39), (146,26), (147,26), (148,47), (149,80),\n  (150,90), (151,36), (152,58), (153,47), (154,9), (155,72), (156,72), (157,66),\n  (158,33), (159,93), (160,75), (161,64), (162,81), (163,9), (164,23), (165,37),\n  (166,13), (167,12), (168,14), (169,62), (170,91), (171,36), (172,91),\n  (173,33), (174,15), (175,34), (176,36), (177,99), (178,3), (179,95), (180,69),\n  (181,58), (182,52), (183,30), (184,50), (185,84), (186,10), (187,84),\n  (188,33), (189,21), (190,39), (191,44), (192,58), (193,30), (194,38),\n  (195,34), (196,83), (197,27), (198,82), (199,17), (200,7);\n}\n\nexecsql_test 4.1",
      "tokens": 0,
      "firstFile": {
        "name": "test/window2.tcl",
        "start": 292,
        "end": 319,
        "startLoc": {
          "line": 292,
          "column": 3,
          "position": 2256
        },
        "endLoc": {
          "line": 319,
          "column": 4,
          "position": 3242
        }
      },
      "secondFile": {
        "name": "test/window3.tcl",
        "start": 24,
        "end": 51,
        "startLoc": {
          "line": 24,
          "column": 3,
          "position": 111
        },
        "endLoc": {
          "line": 51,
          "column": 4,
          "position": 1097
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "set s [subst -novar -noback $s]\n  }\n  if {[regsub -all {[{}]} $s {[wappInt-%HHchar \\\\&]} s]} {\n    set s [subst -novar -noback $s]\n  }\n  return $s\n}\nproc wappInt-enc-string",
      "tokens": 0,
      "firstFile": {
        "name": "test/wapp.tcl",
        "start": 150,
        "end": 157,
        "startLoc": {
          "line": 150,
          "column": 5,
          "position": 981
        },
        "endLoc": {
          "line": 157,
          "column": 19,
          "position": 1070
        }
      },
      "secondFile": {
        "name": "test/wapp.tcl",
        "start": 141,
        "end": 148,
        "startLoc": {
          "line": 141,
          "column": 5,
          "position": 835
        },
        "endLoc": {
          "line": 148,
          "column": 15,
          "position": 924
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "=]\n      set nm [lindex $qsplit 0]\n      if {[regexp {^[a-z][-a-z0-9_]*$} $nm]} {\n        dict set wapp $nm [wappInt-decode-url [lindex $qsplit 1]]\n      }\n    }\n  }\n  set",
      "tokens": 0,
      "firstFile": {
        "name": "test/wapp.tcl",
        "start": 659,
        "end": 666,
        "startLoc": {
          "line": 659,
          "column": 2,
          "position": 5597
        },
        "endLoc": {
          "line": 666,
          "column": 4,
          "position": 5684
        }
      },
      "secondFile": {
        "name": "test/wapp.tcl",
        "start": 574,
        "end": 580,
        "startLoc": {
          "line": 574,
          "column": 2,
          "position": 4476
        },
        "endLoc": {
          "line": 580,
          "column": 7,
          "position": 4562
        }
      }
    },
    {
      "format": "tcl",
      "lines": 10,
      "fragment": "}\n  } else {\n    # If .toread is set, that means we are reading the query content.\n    # Continue reading until .toread reaches zero.\n    set got [read $chan [dict get $W .toread]]\n    dict append W CONTENT $got\n    dict set W .toread [expr {[dict get $W .toread]-[string length $got]}]\n    if {[dict get $W .toread]<=0} {\n      # Handle the request as soon as all the query content is received\n      dict",
      "tokens": 0,
      "firstFile": {
        "name": "test/wapp.tcl",
        "start": 844,
        "end": 853,
        "startLoc": {
          "line": 844,
          "column": 5,
          "position": 7202
        },
        "endLoc": {
          "line": 853,
          "column": 5,
          "position": 7311
        }
      },
      "secondFile": {
        "name": "test/wapp.tcl",
        "start": 491,
        "end": 500,
        "startLoc": {
          "line": 491,
          "column": 5,
          "position": 3552
        },
        "endLoc": {
          "line": 500,
          "column": 4,
          "position": 3661
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": ");\n  launch_thread(&err, &threads, lookaside1_thread_reader, 0);\n  launch_thread(&err, &threads, lookaside1_thread_reader, 0);\n  launch_thread(&err, &threads, lookaside1_thread_reader, 0);\n  launch_thread(&err, &threads, lookaside1_thread_reader, 0);\n  launch_thread(&err, &threads, lookaside1_thread_writer",
      "tokens": 0,
      "firstFile": {
        "name": "test/tt3_lookaside1.c",
        "start": 90,
        "end": 95,
        "startLoc": {
          "line": 90,
          "column": 2,
          "position": 548
        },
        "endLoc": {
          "line": 95,
          "column": 25,
          "position": 634
        }
      },
      "secondFile": {
        "name": "test/tt3_lookaside1.c",
        "start": 89,
        "end": 94,
        "startLoc": {
          "line": 89,
          "column": 2,
          "position": 530
        },
        "endLoc": {
          "line": 94,
          "column": 25,
          "position": 616
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "(int iTid, void *pArg){\n  Error err = {0};                /* Error code and message */\n  Sqlite db = {0};                /* SQLite database connection */\n\n  while( !timetostop(&err) ){\n    opendb(&err, &db, \"test.db\", 0);\n\n    sql_script(&err, &db, \n      \"DROP INDEX IF EXISTS i1;\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/tt3_index.c",
        "start": 17,
        "end": 25,
        "startLoc": {
          "line": 17,
          "column": 25,
          "position": 10
        },
        "endLoc": {
          "line": 25,
          "column": 27,
          "position": 98
        }
      },
      "secondFile": {
        "name": "test/tt3_stress.c",
        "start": 39,
        "end": 44,
        "startLoc": {
          "line": 39,
          "column": 16,
          "position": 181
        },
        "endLoc": {
          "line": 44,
          "column": 31,
          "position": 265
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": ");\n  launch_thread(&err, &threads, create_drop_index_thread, 0);\n  launch_thread(&err, &threads, create_drop_index_thread, 0);\n  launch_thread(&err, &threads, create_drop_index_thread, 0);\n  launch_thread(&err, &threads, create_drop_index_thread, 0);\n\n  join_all_threads",
      "tokens": 0,
      "firstFile": {
        "name": "test/tt3_index.c",
        "start": 65,
        "end": 71,
        "startLoc": {
          "line": 65,
          "column": 2,
          "position": 326
        },
        "endLoc": {
          "line": 71,
          "column": 17,
          "position": 403
        }
      },
      "secondFile": {
        "name": "test/tt3_index.c",
        "start": 64,
        "end": 69,
        "startLoc": {
          "line": 64,
          "column": 2,
          "position": 308
        },
        "endLoc": {
          "line": 69,
          "column": 14,
          "position": 384
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "   break;\n      }\n    }\n  }\n  fclose(in);\n}   \n#endif\n\n/*\n** Return the value of a hexadecimal digit.  Return -1 if the input\n** is not a hex digit.\n*/\nstatic int hexDigitValue(char c){\n  if( c>='0' && c<='9' ) return c - '0';\n",
      "tokens": 0,
      "firstFile": {
        "name": "test/startup.c",
        "start": 420,
        "end": 429,
        "startLoc": {
          "line": 420,
          "column": 14,
          "position": 1380
        },
        "endLoc": {
          "line": 429,
          "column": 3,
          "position": 1480
        }
      },
      "secondFile": {
        "name": "tool/varint.c",
        "start": 17,
        "end": 24,
        "startLoc": {
          "line": 17,
          "column": 9,
          "position": 59
        },
        "endLoc": {
          "line": 24,
          "column": 7,
          "position": 159
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "EXPR}\n  {EXPR+EXPR EXPR+EXPR}\n  {EXPR-EXPR EXPR-EXPR}\n  {EXPR*EXPR EXPR*EXPR}\n  {EXPR+EXPR EXPR+EXPR}\n  {EXPR-EXPR EXPR-EXPR}\n  {EXPR*EXPR EXPR*EXPR}\n  {{",
      "tokens": 0,
      "firstFile": {
        "name": "test/randexpr1.tcl",
        "start": 39,
        "end": 46,
        "startLoc": {
          "line": 39,
          "column": 2,
          "position": 244
        },
        "endLoc": {
          "line": 46,
          "column": 2,
          "position": 315
        }
      },
      "secondFile": {
        "name": "test/randexpr1.tcl",
        "start": 36,
        "end": 43,
        "startLoc": {
          "line": 36,
          "column": 2,
          "position": 211
        },
        "endLoc": {
          "line": 43,
          "column": 5,
          "position": 282
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "econds since the\n** Julian epoch (-4714-11-24).\n*/\nstatic sqlite3_int64 timeOfDay(void){\n  static sqlite3_vfs *clockVfs = 0;\n  sqlite3_int64 t;\n  if( clockVfs==0 ){\n    clockVfs = sqlite3_vfs_find(0);\n    if( clockVfs==0 ) return 0;\n  }\n  if( clockVfs->iVersion>=2 && clockVfs->xCurrentTimeInt64!=0 ){\n    clockVf",
      "tokens": 0,
      "firstFile": {
        "name": "test/ossfuzz.c",
        "start": 43,
        "end": 55,
        "startLoc": {
          "line": 43,
          "column": 2,
          "position": 146
        },
        "endLoc": {
          "line": 55,
          "column": 3,
          "position": 221
        }
      },
      "secondFile": {
        "name": "test/wordcount.c",
        "start": 109,
        "end": 119,
        "startLoc": {
          "line": 109,
          "column": 2,
          "position": 144
        },
        "endLoc": {
          "line": 119,
          "column": 38,
          "position": 219
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": ",  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  10",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 112,
        "end": 128,
        "startLoc": {
          "line": 112,
          "column": 3,
          "position": 5983
        },
        "endLoc": {
          "line": 128,
          "column": 3,
          "position": 6868
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": ",  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   5",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 139,
        "end": 160,
        "startLoc": {
          "line": 139,
          "column": 4,
          "position": 7530
        },
        "endLoc": {
          "line": 160,
          "column": 2,
          "position": 8708
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": ",  1,197,  1,191,  1,185,  1,179,  1,173,  1,167,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  5,\n   3,  1,  1, 48",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 166,
        "end": 187,
        "startLoc": {
          "line": 166,
          "column": 4,
          "position": 9049
        },
        "endLoc": {
          "line": 187,
          "column": 3,
          "position": 10269
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 139,
        "end": 160,
        "startLoc": {
          "line": 139,
          "column": 4,
          "position": 7500
        },
        "endLoc": {
          "line": 160,
          "column": 3,
          "position": 8720
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": ", 84,  4,  7, 23, 17, 17,  1,129, 19,116, 97, 98,108,101,116,\n  52,116, 52,  5, 67, 82, 69, 65, 84, 69, 32, 84, 65, 66, 76, 69, 32,116, 52,\n  40, 97, 32, 73, 78, 84, 32, 85, 78, 73, 81, 85, 69, 32, 78, 79, 84, 32, 78,\n  85, 76, 76, 44, 32, 98, 32, 73, 78, 84, 32, 85, 78, 73, 81, 85, 69, 32, 78,\n  79, 84, 32, 78, 85, 76, 76, 44, 99, 44,100, 44,101, 41, 35,  6,  6, 23, 55,\n  17,  1,  0,105,110,100,101,120,115,113,108,105,116,101, 95, 97,117,116,111,\n 105,110,100,101,120, 95,116, 52, 95, 50,116, 52,  7, 35,  5,  6, 23, 55, 17,\n   1,  0,105,110,100,101,120,115,113,108,105,116,101, 95, 97,117,116,111,105,\n 110,100,101,120, 95,116, 52, 95, 49,116, 52,  6, 42,  3,  6, 23, 17, 17,  1,\n  65,116, 97, 98,108,101,116, 51,116, 51,  4, 67, 82, 69, 65, 84, 69, 32, 84,\n  65, 66, 76, 69, 32,116, 51, 40, 97, 44, 98, 44, 99, 44,100, 44,101, 41, 95,\n   2,  7, 23, 17, 17,  1,129, 41,116, 97, 98,108,101,116, 50,116, 50,  3, 67,\n  82, 69, 65, 84, 69, 32, 84, 65, 66, 76, 69, 32,116, 50, 40, 97, 32, 73, 78,\n  84, 44, 32, 98, 32, 73, 78, 84, 44, 32, 99, 32, 73, 78, 84, 44,100, 32, 73,\n  78, 84, 44,101, 32, 73, 78, 84, 44, 80, 82, 73, 77, 65, 82, 89, 32, 75, 69,\n  89, 40, 98, 44, 97, 41, 41, 87, 73, 84, 72, 79, 85, 84, 32, 82, 79, 87, 73,\n  68, 83,  1,  7, 23, 17, 17,  1,129, 17,116, 97, 98,108,101,116, 49,116, 49,\n   2, 67, 82, 69, 65, 84, 69, 32, 84, 65, 66, 76, 69, 32,116, 49, 40, 97, 32,\n  73, 78, 84, 69, 71, 69, 82, 32, 80, 82, 73, 77, 65, 82",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 225,
        "end": 243,
        "startLoc": {
          "line": 225,
          "column": 3,
          "position": 12263
        },
        "endLoc": {
          "line": 243,
          "column": 3,
          "position": 13263
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 9,
        "end": 28,
        "startLoc": {
          "line": 9,
          "column": 4,
          "position": 380
        },
        "endLoc": {
          "line": 28,
          "column": 2,
          "position": 1383
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": ",\n   1,195,  1,180,  1,166,  1,151,  1,136,  1,121,  1,105,  1, 91,  1, 76,  1,\n  61,  1, 46,  1, 29,  1, 14,  0,252,  0,238,  0,224,  0,209,  0,194,  0,177,\n   0,157,  0,143,  0,128,  0,110,  0, 94,  0, 78,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0, 14, 28,  6,  0,  1,  1,  1, 23, 17, 67, 31,119,\n 111,114,107,115, 14, 27,  6,  0,  1,  1,  1, 23, 22, 71,  3, 97,110,103,101,\n 108, 16, 26,  6,  0,  1,  1,  1, 27, 40, 98, 17,109,111,114,110,105,110,103,\n  13, 25,  6,  0,  1,  1,  1, 21, 10,  7, 19,103,111,110,101, 12, 24,  6,  0,\n   1,  1,  9, 21, 43, 46,119, 97,121,115, 18, 23,  6,  0,  1,  1,  1, 31,  6,\n  37, 31,115, 97, 99,114,105,102,105, 99,101, 15, 22,  6,  0,  1,  1,  1, 25,\n  45, 71, 28,116,104,111,117,103,104, 13, 21,  6,  0,  1,  1,  1, 21, 22, 92,\n  18,115,111,109,101, 13, 20,  6,  0,  9,  1,  1, 23,  2, 45, 97, 98,111,118,\n 101, 12, 19,  6,  0,  1,  1,  8, 21,  4, 58,119, 97,121,115, 12, 18,  6,  0,\n   1,  1,  1, 19, 44, 19, 43,119, 97,114, 16, 17,  6,  0,  1,  1,  1, 27, 29,\n  74, 36, 98,101,116,119,101,101,110, 13, 16,  6,  0,  1,  1,  1, 21, 44, 52,\n  19,112,111,111,114, 15, 15,  6,  0,  1,  1,  1, 25,  6,  3, 11,116,101,109,\n 112,108,101, 13, 14,  6,  0,  1,  1,  1, 21, 35, 48, 27,100,105,101,100, 13,\n  13,  6,  0,  1,  1,  1, 21,  4, 21, 39,100,111,116,104, 13, 12,  6,  0,  1,\n   1,  1, 21,  4, 38, 36,115,101,110,100, 12, 11,  6,  0,  1,  1,  1, 19, 13,\n  48, 22,115,105,120, 14, 10,  6,  0,  1,  1,  1, 23, 41, 89, 14,115,101,114,\n 118,101, 13,  9,  6,  0,  8,  1,  1, 23, 16, 50, 98,101,103, 97,116, 13,  8,\n   6,  0,  1,  1,  1, 21, 42, 49, 34,115,101,110,100, 13,  7,  6,  0,  1,  1,\n   1, 21, 21, 91, 38,110,101, 97,114, 12,  6,  6,  0,  1,  1,  1, 19,  2, 37,\n  11, 99, 97,110, 13,  5,  6,  0,  1,  1,  1, 21, 25, 27, 28,103,111,110,101,\n  13,  4,  6,  0,  1,  1,  1, 21, 41, 32, 35,110,101, 97,114, 14,  3,  6,  0,\n   1,  1,  1, 23, 32, 24, 26,115,101,114,118,101, 13,  2,  6,  0,  1,  1,  1,\n  21, 45, 14, 39,115, 97,118,101, 13,  1,  6,  0,  1,  1,  1, 21, 40, 68, 32",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 380,
        "end": 406,
        "startLoc": {
          "line": 380,
          "column": 4,
          "position": 20529
        },
        "endLoc": {
          "line": 406,
          "column": 3,
          "position": 21915
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 30,
        "end": 56,
        "startLoc": {
          "line": 30,
          "column": 4,
          "position": 1528
        },
        "endLoc": {
          "line": 56,
          "column": 2,
          "position": 2916
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": ",  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 16",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 409,
        "end": 415,
        "startLoc": {
          "line": 409,
          "column": 4,
          "position": 22068
        },
        "endLoc": {
          "line": 415,
          "column": 3,
          "position": 22418
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": ",  1,221,\n   1,211,  1,203,  1,193,  1,183,  1,173,  1,163,  1,151,  1,143,  1,133,  1,\n 122,  1,109,  1,100,  1, 92,  1, 83,  1, 74,  1, 64,  1, 55,  1, 46,  1, 34,\n   1, 22,  1, 13,  1,  4,  0,252,  0,241,  0,232,  0,218,  0,209,  0,200,  0,\n 191,  0,182,  0,173,  0,163,  0,153,  0,144,  0,136,  0,127,  0,116,  0,105,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 434,
        "end": 439,
        "startLoc": {
          "line": 434,
          "column": 4,
          "position": 23425
        },
        "endLoc": {
          "line": 439,
          "column": 2,
          "position": 23678
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 327,
        "end": 331,
        "startLoc": {
          "line": 327,
          "column": 4,
          "position": 17734
        },
        "endLoc": {
          "line": 331,
          "column": 3,
          "position": 17986
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": ",116,101,\n 109,112,108,101, 48, 10,  3, 25,  1,116,101,109,112,108,101, 15,  8,  3, 21,\n   1,115,111,109,101, 21,  7,  3, 19,  1,115,105,120, 11,  8,  3, 21,  1,115,\n 104,101,119, 38,  9,  3, 23,  1,115,101,114,118,101, 10,  9,  3, 23,  1,115,\n 101,114,118,101,  3,  8,  3, 21,  1,115,101,110,100, 40,  8,  3, 21,  1,115,\n 101,110,100, 29,  8,  3, 21,  1,115,101,110,100, 12,  8,  3, 21,  1,115,101,\n 110,100,  8,  8,  3, 21,  1,115, 97,118,101,  2, 13,  3, 31,  1,115, 97, 99,\n 114,105,102,105, 99,101, 23,  8,  3, 21,  1,112,111,111,114, 16, 10,  3, 25,\n   1,112,108, 97, 99,101,115, 32,  7,  3, 19,  1,111,105,108, 49,  8,  3, 21,\n   1,110,101, 97,114,  7,  8,  3, 21,  1,110,101, 97,114,  4, 11,  3, 27,  1,\n 109,111,114,110,105,110,103, 41, 11,  3, 27,  1,109,111,114,110,105,110,103,\n  26,  8,  3, 21,  1,103,111,110,101, 25,  8,  3, 21,  1,103,111,110,101,  5,\n   9,  3, 23,  1,100,119,101,108,116, 37,  8,  3, 21,  1,100,111,116,104, 44,\n   8,  3, 21,  1,100,111,116,104, 13,  7,  3, 21,  9,100,111,116,104,  8,  3,\n  21,  1,100,105,101,100, 14, 12,  3, 29,  1,100,101,112, 97,114,116,101,100,\n  46, 10,  3, 25,  1, 99,117, 98,105,116,115, 35,  9,  3, 23,  1, 99,104,105,\n 108,100, 36,  7,  3, 19,  1, 99, 97,110,  6, 11,  3, 27,  1, 98,101,116,119,\n 101,101,110, 17,  9,  3, 23,  1, 98,101,103, 97,116, 43,  9,  3, 23,  1, 98,\n 101,103, 97,116, 42,  9,  3, 23,  1, 98,101,103, 97,116, 39,  9,  3, 23,  1,\n  98,101,103, 97,116,  9,  7,  3, 19,  1, 97,114,107, 34,  9,  3, 23,  1, 97,\n 110,103,101,114, 47,  9,  3, 23,  1, 97,110,103,101,108, 27,  9,  3, 23,  1,\n  97, 98,111,118,101, 45,  9",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 439,
        "end": 460,
        "startLoc": {
          "line": 439,
          "column": 3,
          "position": 23688
        },
        "endLoc": {
          "line": 460,
          "column": 2,
          "position": 24721
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 332,
        "end": 352,
        "startLoc": {
          "line": 332,
          "column": 2,
          "position": 17997
        },
        "endLoc": {
          "line": 352,
          "column": 2,
          "position": 19023
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": ",  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  9",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 462,
        "end": 483,
        "startLoc": {
          "line": 462,
          "column": 4,
          "position": 24827
        },
        "endLoc": {
          "line": 483,
          "column": 2,
          "position": 26080
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": ",  1,  1,115,101,110,100, 26, 14, 40, 12,  5, 21,  1,  1,\n   1,115, 97,118,101, 39, 45,  2, 17,  5, 31,  1,  1,  1,115, 97, 99,114,105,\n 102,105, 99,101, 31,  6, 23, 12,  5, 21,  1,  1,  1,112,111,111,114, 19, 44,\n  16, 13,  5, 25,  8,  1,  1,112,108, 97, 99,101,115, 16, 32, 11,  5, 19,  1,\n   1,  1,111,105,108, 38,  9, 49, 12,  5, 21,  1,  1,  1,110,101, 97,114, 38,\n  21,  7, 12,  5, 21,  1,  1,  1,110,101, 97,114, 35, 41,  4, 15,  5, 27,  1,\n   1,  1,109,111,114,110,105,110,103, 17, 40, 26, 15,  5, 27,  1,  1,  1,109,\n 111,114,110,105,110,103, 13, 46, 41, 12,  5, 21,  1,  1,  1,103,111,110,101,\n  28, 25,  5, 12,  5, 21,  1,  1,  1,103,111,110,101, 19, 10, 25, 13,  5, 23,\n   1,  1,  1,100,119,101,108,116, 18, 17, 37, 12,  5, 21,  1,  1,  1,100,111,\n 116,104, 39,  4, 13, 11,  5, 21,  1,  1,  9,100,111,116,104, 32, 40, 12,  5,\n  21,  1,  1,  1,100,111,116,104,  9, 48, 44, 12,  5, 21,  1,  1,  1,100,105,\n 101,100, 27, 35, 14, 16,  5, 29,  1,  1,  1,100,101,112, 97,114,116,101,100,\n  22, 28, 46, 14,  5, 25,  1,  1,  1, 99,117, 98,105,116,115, 22, 38, 35, 12,\n   5, 23,  1,  8,  1, 99,104,105,108,100, 17, 36, 11,  5, 19,  1,  1,  1, 99,\n  97,110, 11,  2,  6, 15,  5, 27,  1,  1,  1, 98,101,116,119,101,101,110, 36,\n  29, 17, 12,  5, 23,  1,  8,  1, 98,101,103, 97,116, 50,  9, 13,  5, 23,  1,\n   1,  1, 98,101,103, 97,116, 45,  3, 39, 13,  5, 23,  1,  1,  1, 98,101,103,\n  97,116, 41,  5, 43, 13,  5, 23,  1,  1,  1, 98,101,103, 97,116,  5, 20, 42,\n  11,  5, 19,  1,  1,  1, 97,114,107, 20, 26, 34, 13,  5, 23,  1,  1,  1, 97,\n 110,103,101,114, 40, 22, 47, 13,  5, 23,  1,  1,  1, 97,110,103,101,108,  3,\n  22, 27, 12,  5, 23,  1,  9,  1, 97, 98,111,118,101, 45, 20, 13,  5, 23,  1,\n   1,  1, 97",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 492,
        "end": 514,
        "startLoc": {
          "line": 492,
          "column": 3,
          "position": 26505
        },
        "endLoc": {
          "line": 514,
          "column": 3,
          "position": 27659
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 357,
        "end": 379,
        "startLoc": {
          "line": 357,
          "column": 2,
          "position": 19287
        },
        "endLoc": {
          "line": 379,
          "column": 2,
          "position": 20443
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": ",  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0, 13",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 517,
        "end": 529,
        "startLoc": {
          "line": 517,
          "column": 3,
          "position": 27830
        },
        "endLoc": {
          "line": 529,
          "column": 3,
          "position": 28519
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": ",  1,  1, 19, 26, 34,\n  15, 20, 97,114,107, 14,  6,  1,  1,  1,  1, 21, 25,  5, 27, 28,103,111,110,\n 101, 15,  6,  1,  1,  1,  1, 23, 22, 47, 16, 40, 97,110,103,101,114, 15,  6,\n   1,  1,  1,  1, 23, 22, 27, 71,  3, 97,110,103,101,108, 14,  6,  1,  1,  1,\n   1, 21, 22, 21, 92, 18,115,111,109,101, 14,  6,  1,  1,  1,  1, 21, 21,  7,\n  91, 38,110,101, 97,114, 15,  6,  1,  1,  1,  1, 23, 20, 42, 18,  5, 98,101,\n 103, 97,116, 15,  6,  1,  1,  1,  1, 23, 17, 37, 66, 18,100,119,101,108,116,\n  15,  6,  1,  1,  1,  1, 23, 17, 28, 67, 31,119,111,114,107,115, 15,  6,  1,\n   1,  1,  8, 25, 16, 32,  7,112,108, 97, 99,101,115, 14,  6,  1,  1,  1,  1,\n  21, 16, 30, 81, 25,119, 97,108,107, 14,  6,  1,  1,  1,  1, 21, 14, 40, 30,\n  26,115,101,110,100, 13,  6,  1,  1,  1,  1, 19, 13, 11, 48, 22,115,105,120,\n  14,  6,  1,  1,  1,  1, 21, 10, 38, 97, 34,115,104,101,119, 14,  6,  1,  1,\n   1,  1, 21, 10, 25,  7, 19,103,111,110,101, 17,  6,  1,  1,  1,  1, 27,  9,\n  50, 92, 29,116,104,101,114,101,105,110, 13,  6,  1,  1,  1,  1, 19,  9, 49,\n  51, 38,111,105,108, 10,  6,  1,  1,  1,  1,  0,  7, 33, 72, 31, 19,  6,  1,\n   1,  1,  1, 31,  6, 23, 37, 31,115, 97, 99,114,105,102,105, 99,101, 16,  6,\n   1,  1,  1,  1, 25,  6, 15,  3, 11,116,101,109,112,108,101, 15,  6,  1,  1,\n   1,  1, 23,  5, 43, 23, 41, 98,101,103, 97,116, 13,  6,  1,  1,  1,  8, 21,\n   4, 19, 58,119, 97,121,115, 14,  6,  1,  1,  1,  1, 21,  4, 13, 21, 39,100,\n 111,116,104, 14,  6,  1,  1,  1,  1, 21,  4, 12, 38, 36,115,101,110,100, 15,\n   6,  1,  1,  1,  1, 23,  3, 39, 21, 45, 98,101,103, 97,116, 13,  6,  1,  1,\n   1,  1, 19,  2,  6, 37, 11, 99, 97,110, 14,  6,  9,  1,  1,  1, 23, 20,  2,\n  45, 97, 98,111,118,101, 14,  6,  8,  1,  1,  1, 23, 36, 52, 17, 99,104,105",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 545,
        "end": 567,
        "startLoc": {
          "line": 545,
          "column": 3,
          "position": 29383
        },
        "endLoc": {
          "line": 567,
          "column": 4,
          "position": 30575
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 60,
        "end": 82,
        "startLoc": {
          "line": 60,
          "column": 2,
          "position": 3132
        },
        "endLoc": {
          "line": 82,
          "column": 2,
          "position": 4324
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": ",  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0, 14",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 571,
        "end": 578,
        "startLoc": {
          "line": 571,
          "column": 4,
          "position": 30763
        },
        "endLoc": {
          "line": 578,
          "column": 3,
          "position": 31153
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": ",  1,  1,  0,  1, 49, 51, 38, 15, 12,  7,  1,\n   1,  1,  1,  0,  1, 48, 37, 93,  7, 30, 11,  7,  1,  1,  1,  0,  0,  1, 47,\n  22, 16, 24, 11,  7,  1,  0,  1,  1,  0,  1, 47, 16, 40, 12, 12,  7,  1,  1,\n   1,  1,  0,  1, 46, 28, 88, 22,  2, 11,  7,  1,  1,  0,  1,  0,  1, 44, 48,\n   9, 19, 16,  7,  1,  1,  1,  0, 23,  1, 42, 20, 18, 98,101,103, 97,116, 22,\n  16,  7,  1,  1,  0,  1, 23,  1, 37, 17, 18,100,119,101,108,116, 16, 17,  7,\n   1,  1,  0,  1, 25,  1, 35, 38, 22, 99,117, 98,105,116,115, 17, 14,  7,  1,\n   1,  1,  0, 19,  1, 34, 26, 15, 97,114,107, 21, 11,  7,  1,  1,  1,  0,  0,\n   1, 32, 16,  7, 23, 12,  7,  1,  1,  1,  1,  0,  1, 28, 17, 67, 31, 29, 11,\n   7,  1,  0,  1,  1,  0,  1, 25,  7, 19, 11, 12,  7,  1,  1,  1,  1,  0,  1,\n  22, 45, 71, 28, 28, 12,  7,  1,  1,  1,  1,  0,  1, 21, 22, 92, 18,  4, 11,\n   7,  1,  1,  0,  1,  0,  1, 21, 22, 18, 18, 11,  7,  1,  1,  1,  1,  0,  9,\n  17, 29, 74, 36, 11,  7,  1,  1,  1,  0,  0,  1, 17, 29, 74, 25, 18,  7,  1,\n   1,  1,  1, 25,  1, 15,  6,  3, 11,116,101,109,112,108,101,  5, 12,  7,  1,\n   1,  1,  1,  0,  1, 12,  4, 38, 36, 27, 16,  7,  1,  0,  1,  1, 23,  1, 10,\n  89, 14,115,101,114,118,101, 14, 16,  7,  1,  1,  1,  1, 21,  1,  4, 41, 32,\n  35,110,101, 97,114,  3, 14,  7,  9,  0,  1,  1, 21,  1, 68, 32,100,111,116,\n 104, 13, 15,  7,  0,  1,  1,  1, 21,  1, 21, 91, 38,110,101, 97,114,  6, 11,\n   7,  0,  1,  1,  1,  0,  1, 16, 81, 25,  9, 10,  7,  0,  1,  1,  8,  0,  1,\n  16,  7, 10, 11,  7,  0,  1,  1,  1,  0,  1,  7, 72, 31,  8, 11,  7,  0,  1,\n   1,  1,  0,  1,  6, 37, 31,  7,  8,  7,  0,  0,  0,  0,  0,  1, 35,  8,  7,\n   0,  0,  0,  0,  0,  1, 34,  8,  7,  0,  0,  0,  0,  0,  1, 33,  8,  7,  0,\n   0,  0,  0",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 600,
        "end": 622,
        "startLoc": {
          "line": 600,
          "column": 3,
          "position": 32323
        },
        "endLoc": {
          "line": 622,
          "column": 2,
          "position": 33549
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 303,
        "end": 325,
        "startLoc": {
          "line": 303,
          "column": 2,
          "position": 16430
        },
        "endLoc": {
          "line": 325,
          "column": 3,
          "position": 17655
        }
      }
    },
    {
      "format": "c",
      "lines": 26,
      "fragment": ",  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0, 12",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 623,
        "end": 648,
        "startLoc": {
          "line": 623,
          "column": 4,
          "position": 33620
        },
        "endLoc": {
          "line": 648,
          "column": 3,
          "position": 35072
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": ",  1,168,  1,148,  1,130,  1,107,\n   1, 86,  1, 65,  1, 44,  1, 27,  1, 14,  0,250,  0,224,  0,205,  0,184,  0,\n 165,  0,145,  0,123,  0,106,  0, 86,  0, 67,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0, 17, 23,  6,  0, 23,  1,  1, 21,107,110,111,119,110, 52,\n  19,112,111,111,114, 18, 22,  6,  0, 23,  1,  1, 23, 97, 98,111,118,101, 24,\n  26,115,101,114,118,101, 15, 21,  6,  0, 19,  1,  1, 21,119, 97,114, 52, 19,\n 112,111,111,114, 20, 20,  6,  0, 27,  1,  8, 25,110,111,116,104,105,110,103,\n   7,112,108, 97, 99,101,115, 18, 19,  6,  0, 23,  1,  1, 23, 98,101,103, 97,\n 116, 90, 27,116,114,117,116,104, 17, 18,  6,  0, 23,  1,  1, 21,100,119,101,\n 108,116, 21, 39,100,111,116,104, 19, 17,  6,  0, 27,  1,  1, 21,109,111,114,\n 110,105,110,103, 52, 19,112,111,111,114, 17, 16,  6,  0, 21,  1,  1, 23,115,\n 104,101,119, 90, 27,116,114,117,116,104, 24, 15,  6,  0, 27,  1,  1, 31,116,\n 104,101,114,101,105,110, 37, 31,115, 97, 99,114,105,102,105, 99,101, 18, 14,\n   6,  0, 23,  1,  8, 25,115,109,111,116,101,  7,112,108, 97, 99,101,115, 11,\n  13,  6,  0, 19,  1,  1,  0, 97,114,107, 72, 31, 15, 12,  6,  0, 21,  1,  8,\n  21,119,105,110,101, 58,119, 97,121,115, 19, 11,  6,  0, 21,  1,  1, 27,115,\n 111,109,101, 98, 17,109,111,114,110,105,110,103, 19, 10,  6,  0, 27,  1,  1,\n  21, 98,101,116,119,101,101,110, 92, 18,115,111,109,101, 19,  9,  6,  0, 21,\n   1,  1, 27,115, 97,118,101, 74, 36, 98,101,116,119,101,101,110, 21,  8,  6,\n   0, 25,  1,  1, 27,116,104,111,117,103,104, 98, 17,109,111,114,110,105,110,\n 103, 16,  7,  6,  0, 21,  1,  1, 21,115,101,110,100, 49, 34,115,101,110,100,\n  18,  6,  6,  0, 25,  1,  1, 21,119,105,115,100,111,109, 38, 36,115,101,110,\n 100, 16,  5,  6,  0, 23,  1,  9, 21, 97,110,103,101,114, 46,119, 97,121,115,\n  14,  4,  6,  0, 19,  1,  1, 19, 99, 97,110, 19, 43,119, 97,114, 16,  3,  6,\n   0, 23,  1,  1, 19,111,102,102,101,114, 48, 22,115,105,120, 16,  2,  6,  0,\n  23,  1,  8, 21,119,111,114,107,115, 58,119, 97,121,115, 16,  1,  6,  0, 23,\n   1,  1, 19,116",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 650,
        "end": 676,
        "startLoc": {
          "line": 650,
          "column": 4,
          "position": 35191
        },
        "endLoc": {
          "line": 676,
          "column": 4,
          "position": 36485
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 192,
        "end": 218,
        "startLoc": {
          "line": 192,
          "column": 4,
          "position": 10572
        },
        "endLoc": {
          "line": 218,
          "column": 2,
          "position": 11868
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": ",  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 18",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 704,
        "end": 725,
        "startLoc": {
          "line": 704,
          "column": 4,
          "position": 37919
        },
        "endLoc": {
          "line": 725,
          "column": 3,
          "position": 39142
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 7,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": ",116,114,\n 101,101, 49, 11,  3, 27,  1,116,104,121,115,101,108,102, 27, 10,  3, 25,  1,\n 116,104,111,117,103,104,  8, 11,  3, 27,  1,116,104,101,114,101,105,110, 15,\n  10,  3, 25,  1,116,101,109,112,108,101, 43,  8,  3, 21,  1,116,101,108,108,\n  25,  8,  3, 21,  1,115,111,109,101, 11,  9,  3, 23,  1,115,109,111,116,101,\n  14,  7,  3, 19,  1,115,105,120, 48,  8,  3, 21,  1,115,104,101,119, 16,  9,\n   3, 23,  1,115,101,114,118,101, 37,  8,  3, 21,  1,115,101,110,100,  7,  8,\n   3, 21,  1,115, 97,118,101,  9, 13,  3, 31,  1,115, 97, 99,114,105,102,105,\n  99,101, 24,  8,  3, 21,  1,112,111,111,114, 40, 10,  3, 25,  1,112,108, 97,\n  99,101,115, 28,  8,  3, 21,  1,112, 97,114,116, 30,  7,  3, 19,  1,111,105,\n 108, 46,  9,  3, 23,  1,111,102,102,101,114,  3, 11,  3, 27,  1,110,111,116,\n 104,105,110,103, 20,  8,  3, 21,  1,110,101, 97,114, 36, 11,  3, 27,  1,109,\n 111,114,110,105,110,103, 17,  8,  3, 21,  1,108,111,110,103, 35,  9,  3, 23,\n   1,107,110,111,119,110, 23, 15,  3, 35,  1,105,110,104, 97, 98,105,116, 97,\n 110,116,115, 45,  8,  3, 21,  1,103,111,110,101, 32,  9,  3, 23,  1,102,114,\n 117,105,116, 38,  9,  3, 23,  1,100,119,101,108,116, 18,  8,  3, 21,  1,100,\n 111,116,104, 39,  8,  3, 21,  1,100,105,101,100, 47, 12,  3, 29,  1,100,101,\n 112, 97,114,116,101,100, 26, 10,  3, 25,  1, 99,117, 98,105,116,115, 33,  9,\n   3, 23,  1, 99,104,105,108,100, 42,  7,  3, 19,  1, 99, 97,110,  4, 11,  3,\n  27,  1, 98,101,116,119,101,101,110, 10,  9,  3, 23,  1, 98,101,103, 97,116,\n  19,  8,  3, 21,  1, 98,101, 97,114, 29,  7,  3, 19,  1, 97,114,107, 13,  9,\n   3, 23,  1, 97,110,103,101,114,  5,  9,  3, 23,  1, 97,110,103,101",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 735,
        "end": 756,
        "startLoc": {
          "line": 735,
          "column": 2,
          "position": 39667
        },
        "endLoc": {
          "line": 756,
          "column": 4,
          "position": 40714
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 250,
        "end": 271,
        "startLoc": {
          "line": 250,
          "column": 2,
          "position": 13646
        },
        "endLoc": {
          "line": 271,
          "column": 2,
          "position": 14695
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": ",  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   9,  3, 23,  1,119,114",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 758,
        "end": 780,
        "startLoc": {
          "line": 758,
          "column": 4,
          "position": 40818
        },
        "endLoc": {
          "line": 780,
          "column": 4,
          "position": 42058
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 484,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 484,
          "column": 4,
          "position": 26094
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": ", 19, 19,  8,129, 33,118,\n 105,101,119,118, 50, 49,118, 50, 49, 67, 82, 69, 65, 84, 69, 32, 86, 73, 69,\n  87, 32,118, 50, 49, 40, 97, 44, 98, 44, 99, 44,100, 44,101, 41, 32, 65, 83,\n  32, 83, 69, 76, 69, 67, 84, 32, 97, 44, 98, 44, 99, 44,100, 44,101, 32, 70,\n  82, 79, 77, 32,116, 50, 32, 79, 82, 68, 69, 82, 32, 66, 89, 32, 98, 32, 76,\n  73, 77, 73, 84, 32, 49, 48, 13",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 833,
        "end": 838,
        "startLoc": {
          "line": 833,
          "column": 3,
          "position": 44998
        },
        "endLoc": {
          "line": 838,
          "column": 3,
          "position": 45260
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 789,
        "end": 793,
        "startLoc": {
          "line": 789,
          "column": 3,
          "position": 42533
        },
        "endLoc": {
          "line": 793,
          "column": 3,
          "position": 42793
        }
      }
    },
    {
      "format": "c",
      "lines": 18,
      "fragment": ",  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,129, 52",
      "tokens": 0,
      "firstFile": {
        "name": "test/optfuzz-db01.c",
        "start": 919,
        "end": 936,
        "startLoc": {
          "line": 919,
          "column": 3,
          "position": 49746
        },
        "endLoc": {
          "line": 936,
          "column": 3,
          "position": 50724
        }
      },
      "secondFile": {
        "name": "test/optfuzz-db01.c",
        "start": 6,
        "end": 841,
        "startLoc": {
          "line": 6,
          "column": 2,
          "position": 188
        },
        "endLoc": {
          "line": 841,
          "column": 3,
          "position": 45461
        }
      }
    },
    {
      "format": "tcl",
      "lines": 13,
      "fragment": "set nArg [llength $args]\n  if {($nArg%2)==0} {\n    error \"wrong # args: should be \\\"fts3_build_db_1 ?switches? n\\\"\"\n  }\n\n  set n [lindex $args [expr $nArg-1]]\n  array set opts [array get default]\n  array set opts [lrange $args 0 [expr $nArg-2]]\n  foreach k [array names opts] {\n    if {0==[info exists default($k)]} { error \"unknown option: $k\" }\n  }\n\n  if {$n > 100000",
      "tokens": 0,
      "firstFile": {
        "name": "test/fts3_common.tcl",
        "start": 110,
        "end": 122,
        "startLoc": {
          "line": 110,
          "column": 3,
          "position": 756
        },
        "endLoc": {
          "line": 122,
          "column": 7,
          "position": 908
        }
      },
      "secondFile": {
        "name": "test/fts3_common.tcl",
        "start": 61,
        "end": 73,
        "startLoc": {
          "line": 61,
          "column": 3,
          "position": 141
        },
        "endLoc": {
          "line": 73,
          "column": 6,
          "position": 293
        }
      }
    },
    {
      "format": "tcl",
      "lines": 6,
      "fragment": "{ \n  SELECT min(b) FILTER (WHERE a>19),\n         min(b) FILTER (WHERE a>0),\n         max(a+b) FILTER (WHERE a>19),\n         max(b+a) FILTER (WHERE a BETWEEN 10 AND 40)\n  FROM t1",
      "tokens": 0,
      "firstFile": {
        "name": "test/filter2.tcl",
        "start": 61,
        "end": 66,
        "startLoc": {
          "line": 61,
          "column": 2,
          "position": 734
        },
        "endLoc": {
          "line": 66,
          "column": 3,
          "position": 819
        }
      },
      "secondFile": {
        "name": "test/filter2.tcl",
        "start": 43,
        "end": 48,
        "startLoc": {
          "line": 43,
          "column": 2,
          "position": 568
        },
        "endLoc": {
          "line": 48,
          "column": 4,
          "position": 653
        }
      }
    },
    {
      "format": "c",
      "lines": 54,
      "fragment": "static int nCb = 0;                  /* Number of callbacks seen so far */\nstatic int mxCb = 250000;            /* Maximum allowed callbacks */\n\n/***** Copy/paste from ext/misc/memtrace.c ***************************/\n/* The original memory allocation routines */\nstatic sqlite3_mem_methods memtraceBase;\nstatic FILE *memtraceOut;\n\n/* Methods that trace memory allocations */\nstatic void *memtraceMalloc(int n){\n  if( memtraceOut ){\n    fprintf(memtraceOut, \"MEMTRACE: allocate %d bytes\\n\", \n            memtraceBase.xRoundup(n));\n  }\n  return memtraceBase.xMalloc(n);\n}\nstatic void memtraceFree(void *p){\n  if( p==0 ) return;\n  if( memtraceOut ){\n    fprintf(memtraceOut, \"MEMTRACE: free %d bytes\\n\", memtraceBase.xSize(p));\n  }\n  memtraceBase.xFree(p);\n}\nstatic void *memtraceRealloc(void *p, int n){\n  if( p==0 ) return memtraceMalloc(n);\n  if( n==0 ){\n    memtraceFree(p);\n    return 0;\n  }\n  if( memtraceOut ){\n    fprintf(memtraceOut, \"MEMTRACE: resize %d -> %d bytes\\n\",\n            memtraceBase.xSize(p), memtraceBase.xRoundup(n));\n  }\n  return memtraceBase.xRealloc(p, n);\n}\nstatic int memtraceSize(void *p){\n  return memtraceBase.xSize(p);\n}\nstatic int memtraceRoundup(int n){\n  return memtraceBase.xRoundup(n);\n}\nstatic int memtraceInit(void *p){\n  return memtraceBase.xInit(p);\n}\nstatic void memtraceShutdown(void *p){\n  memtraceBase.xShutdo",
      "tokens": 0,
      "firstFile": {
        "name": "test/dbfuzz2.c",
        "start": 82,
        "end": 135,
        "startLoc": {
          "line": 82,
          "column": 1,
          "position": 147
        },
        "endLoc": {
          "line": 135,
          "column": 2,
          "position": 552
        }
      },
      "secondFile": {
        "name": "ext/misc/memtrace.c",
        "start": 28,
        "end": 80,
        "startLoc": {
          "line": 28,
          "column": 1,
          "position": 6
        },
        "endLoc": {
          "line": 80,
          "column": 2,
          "position": 410
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": "own(p);\n}\n\n/* The substitute memory allocator */\nstatic sqlite3_mem_methods ersaztMethods = {\n  memtraceMalloc,\n  memtraceFree,\n  memtraceRealloc,\n  memtraceSize,\n  memtraceRoundup,\n  memtraceInit,\n  memtraceShutdown\n};\n\n/* Begin tracing memory allocations to out. */\nint sqlite3MemTraceActivate(FILE *out){\n  int rc = SQLITE_OK;\n  if( memtraceBase.xMalloc==0 ){\n    rc = sqlite3_config(SQLITE_CONFIG_GETMALLOC, &memtraceBase);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3_config(SQLITE_CONFIG_MALLOC, &ersaztMethods);\n    }\n  }\n  memtraceOut = out;\n  return rc;\n}\n\n/* Deactivate memory tracing */\nint sqlite3MemTraceDeactivate(void){\n  int rc = SQLITE_OK;\n",
      "tokens": 0,
      "firstFile": {
        "name": "test/dbfuzz2.c",
        "start": 135,
        "end": 161,
        "startLoc": {
          "line": 135,
          "column": 1,
          "position": 552
        },
        "endLoc": {
          "line": 161,
          "column": 2,
          "position": 752
        }
      },
      "secondFile": {
        "name": "ext/misc/memtrace.c",
        "start": 82,
        "end": 108,
        "startLoc": {
          "line": 82,
          "column": 1,
          "position": 415
        },
        "endLoc": {
          "line": 108,
          "column": 2,
          "position": 615
        }
      }
    },
    {
      "format": "c",
      "lines": 47,
      "fragment": "   sqlite3_free(p->z);\n      memset(p, 0, sizeof(*p));\n      p->oomErr = 1;\n      return;\n    }\n    p->z = zNew;\n    p->nAlloc = nNew;\n  }\n  memcpy(p->z + p->n, z, (int)n);\n  p->n += n;\n  p->z[p->n] = 0;\n}\n\n/* Return the current string content */\nstatic char *StrStr(Str *p){\n return p->z;\n}\n\n/* Free the string */\nstatic void StrFree(Str *p){\n  sqlite3_free(p->z);\n  StrInit(p);\n}\n\n/*\n** Return the value of a hexadecimal digit.  Return -1 if the input\n** is not a hex digit.\n*/\nstatic int hexDigitValue(char c){\n  if( c>='0' && c<='9' ) return c - '0';\n  if( c>='a' && c<='f' ) return c - 'a' + 10;\n  if( c>='A' && c<='F' ) return c - 'A' + 10;\n  return -1;\n}\n\n/*\n** Interpret zArg as an integer value, possibly with suffixes.\n*/\nstatic int integerValue(const char *zArg){\n  sqlite3_int64 v = 0;\n  static const struct { char *zSuffix; int iMult; } aMult[] = {\n    { \"KiB\", 1024 },\n    { \"MiB\", 1024*1024 },\n    { \"GiB\", 1024*1024*1024 },\n    { \"KB\",  1000 },\n    { \"MB\",  1000000 },\n    { \"GB\",  1000000000 }",
      "tokens": 0,
      "firstFile": {
        "name": "test/dbfuzz.c",
        "start": 484,
        "end": 530,
        "startLoc": {
          "line": 484,
          "column": 2,
          "position": 3341
        },
        "endLoc": {
          "line": 530,
          "column": 8,
          "position": 3782
        }
      },
      "secondFile": {
        "name": "test/startup.c",
        "start": 412,
        "end": 459,
        "startLoc": {
          "line": 412,
          "column": 3,
          "position": 1365
        },
        "endLoc": {
          "line": 459,
          "column": 8,
          "position": 1808
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": ",\n    { \"K\",   1000 },\n    { \"M\",   1000000 },\n    { \"G\",   1000000000 },\n  };\n  int i;\n  int isNeg = 0;\n  if( zArg[0]=='-' ){\n    isNeg = 1;\n    zArg++;\n  }else if( zArg[0]=='+' ){\n    zArg++;\n  }\n  if( zArg[0]=='0' && zArg[1]=='x' ){\n    int x;\n    zArg",
      "tokens": 0,
      "firstFile": {
        "name": "test/dbfuzz.c",
        "start": 530,
        "end": 541,
        "startLoc": {
          "line": 530,
          "column": 8,
          "position": 3783
        },
        "endLoc": {
          "line": 541,
          "column": 11,
          "position": 3910
        }
      },
      "secondFile": {
        "name": "test/startup.c",
        "start": 459,
        "end": 470,
        "startLoc": {
          "line": 459,
          "column": 8,
          "position": 1809
        },
        "endLoc": {
          "line": 470,
          "column": 2,
          "position": 1935
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "{SELECT rowid, a, x FROM t1 ORDER BY a} $ans\n\nset ans {}\nforeach a [reverse [sort $all_a]] {\n  set r $t1ar($a)\n  lappend ans $r $a $t1rx($r)\n}\nmaketest 3.9",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary4.tcl",
        "start": 265,
        "end": 272,
        "startLoc": {
          "line": 265,
          "column": 2,
          "position": 2733
        },
        "endLoc": {
          "line": 272,
          "column": 4,
          "position": 2815
        }
      },
      "secondFile": {
        "name": "test/boundary4.tcl",
        "start": 168,
        "end": 175,
        "startLoc": {
          "line": 168,
          "column": 2,
          "position": 1349
        },
        "endLoc": {
          "line": 175,
          "column": 4,
          "position": 1431
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "{SELECT rowid, a, x FROM t1 ORDER BY x} $ans\n\nset ans {}\nforeach x [reverse [sort $all_x]] {\n  set r $t1xr($x)\n  lappend ans $r $t1ra($r) $x\n}\nmaketest 3.13",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary4.tcl",
        "start": 281,
        "end": 288,
        "startLoc": {
          "line": 281,
          "column": 2,
          "position": 2957
        },
        "endLoc": {
          "line": 288,
          "column": 5,
          "position": 3039
        }
      },
      "secondFile": {
        "name": "test/boundary4.tcl",
        "start": 184,
        "end": 191,
        "startLoc": {
          "line": 184,
          "column": 2,
          "position": 1573
        },
        "endLoc": {
          "line": 191,
          "column": 5,
          "position": 1655
        }
      }
    },
    {
      "format": "tcl",
      "lines": 59,
      "fragment": "}]) 1\n  set x [expr {wide($x*128 + 127)}]\n}\n\n# Scramble the $inlist into a random order.\n#\nproc scramble {inlist} {\n  set y {}\n  foreach x $inlist {\n    lappend y [list [expr {rand()}] $x]\n  }\n  set y [lsort $y]\n  set outlist {}\n  foreach x $y {\n    lappend outlist [lindex $x 1]\n  }\n  return $outlist\n}\n\n# A simple selection sort.  Not trying to be efficient.\n#\nproc sort {inlist} {\n  set outlist {}\n  set mn [lindex $inlist 0]\n  foreach x $inlist {\n    if {$x<$mn} {set mn $x}\n  }\n  set outlist $mn\n  set mx $mn\n  while {1} {\n    set valid 0\n    foreach x $inlist {\n      if {$x>$mx && (!$valid || $mn>$x)} {\n        set mn $x\n        set valid 1\n      }\n    }\n    if {!$valid} break\n    lappend outlist $mn\n    set mx $mn\n  }\n  return $outlist\n}\n\n# Reverse the order of a list\n#\nproc reverse {inlist} {\n  set i [llength $inlist]\n  set outlist {}\n  for {incr i -1} {$i>=0} {incr i -1} {\n    lappend outlist [lindex $inlist $i]\n  }\n  return $outlist\n}\n\nset nums1 [scramble [array names boundarynum]]\nset nums2 [scramble [array names boundarynum]]\n\nset tname boundary3",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary3.tcl",
        "start": 51,
        "end": 109,
        "startLoc": {
          "line": 51,
          "column": 2,
          "position": 348
        },
        "endLoc": {
          "line": 109,
          "column": 10,
          "position": 821
        }
      },
      "secondFile": {
        "name": "test/boundary4.tcl",
        "start": 51,
        "end": 109,
        "startLoc": {
          "line": 51,
          "column": 2,
          "position": 339
        },
        "endLoc": {
          "line": 109,
          "column": 10,
          "position": 812
        }
      }
    },
    {
      "format": "tcl",
      "lines": 26,
      "fragment": "set testdir [file dirname $argv0]\nsource $testdir/tester.tcl\n\n# Many of the boundary tests depend on a working 64-bit implementation.\nif {![working_64bit_int]} { finish_test; return }\n}\n\nexpr srand(0)\n\n# Generate interesting boundary numbers\n#\nforeach x {\n  0\n  1\n  0x7f\n  0x7fff\n  0x7fffff\n  0x7fffffff\n  0x7fffffffff\n  0x7fffffffffff\n  0x7fffffffffffff\n  0x7fffffffffffffff\n} {\n  set x [expr {wide($x)}]\n  set boundarynum($x) 1\n  set boundarynum([expr {$",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 18,
        "end": 43,
        "startLoc": {
          "line": 18,
          "column": 1,
          "position": 36
        },
        "endLoc": {
          "line": 43,
          "column": 2,
          "position": 168
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 17,
        "end": 42,
        "startLoc": {
          "line": 17,
          "column": 1,
          "position": 34
        },
        "endLoc": {
          "line": 42,
          "column": 5,
          "position": 166
        }
      }
    },
    {
      "format": "tcl",
      "lines": 19,
      "fragment": "0x7f\n  0x7fff\n  0x7fffff\n  0x7fffffff\n  0x7fffffffff\n  0x7fffffffffff\n  0x7fffffffffffff\n  0x7fffffffffffffff\n} {\n  set x [expr {wide($x)}]\n  set boundarynum($x) 1\n  set boundarynum([expr {$x+1}]) 1\n  set boundarynum([expr {-($x+1)}]) 1\n  set boundarynum([expr {-($x+2)}]) 1\n  set boundarynum([expr {$x+$x+1}]) 1\n  set boundarynum([expr {$x+$x+2}]) 1\n}\nset x [expr {wide(127)}]\nfor {set i 1",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 32,
        "end": 50,
        "startLoc": {
          "line": 32,
          "column": 3,
          "position": 104
        },
        "endLoc": {
          "line": 50,
          "column": 2,
          "position": 290
        }
      },
      "secondFile": {
        "name": "test/boundary4.tcl",
        "start": 31,
        "end": 49,
        "startLoc": {
          "line": 31,
          "column": 3,
          "position": 111
        },
        "endLoc": {
          "line": 49,
          "column": 4,
          "position": 297
        }
      }
    },
    {
      "format": "tcl",
      "lines": 61,
      "fragment": "} {$i<=9} {incr i} {\n  set boundarynum($x) 1\n  set boundarynum([expr {$x+1}]) 1\n  set x [expr {wide($x*128 + 127)}]\n}\n\n# Scramble the $inlist into a random order.\n#\nproc scramble {inlist} {\n  set y {}\n  foreach x $inlist {\n    lappend y [list [expr {rand()}] $x]\n  }\n  set y [lsort $y]\n  set outlist {}\n  foreach x $y {\n    lappend outlist [lindex $x 1]\n  }\n  return $outlist\n}\n\n# A simple selection sort.  Not trying to be efficient.\n#\nproc sort {inlist} {\n  set outlist {}\n  set mn [lindex $inlist 0]\n  foreach x $inlist {\n    if {$x<$mn} {set mn $x}\n  }\n  set outlist $mn\n  set mx $mn\n  while {1} {\n    set valid 0\n    foreach x $inlist {\n      if {$x>$mx && (!$valid || $mn>$x)} {\n        set mn $x\n        set valid 1\n      }\n    }\n    if {!$valid} break\n    lappend outlist $mn\n    set mx $mn\n  }\n  return $outlist\n}\n\n# Reverse the order of a list\n#\nproc reverse {inlist} {\n  set i [llength $inlist]\n  set outlist {}\n  for {incr i -1} {$i>=0} {incr i -1} {\n    lappend outlist [lindex $inlist $i]\n  }\n  return $outlist\n}\n\nset nums1 [scramble [array names boundarynum]]\nset nums2 [scramble [array names boundarynum]]\n\nset tname boundary2",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 50,
        "end": 110,
        "startLoc": {
          "line": 50,
          "column": 2,
          "position": 291
        },
        "endLoc": {
          "line": 110,
          "column": 10,
          "position": 805
        }
      },
      "secondFile": {
        "name": "test/boundary4.tcl",
        "start": 49,
        "end": 109,
        "startLoc": {
          "line": 49,
          "column": 4,
          "position": 298
        },
        "endLoc": {
          "line": 109,
          "column": 10,
          "position": 812
        }
      }
    },
    {
      "format": "tcl",
      "lines": 8,
      "fragment": "foreach r $nums1 {\n  incr a\n  set t1ra($r) $a\n  set t1ar($a) $r\n  set x [format %08x%08x [expr {wide($r)>>32}] $r]\n  set t1rx($r) $x\n  set t1xr($x) $r\n  puts \"    INSERT INTO t1 VALUES($r,$a,'$x');\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 115,
        "end": 122,
        "startLoc": {
          "line": 115,
          "column": 1,
          "position": 825
        },
        "endLoc": {
          "line": 122,
          "column": 41,
          "position": 921
        }
      },
      "secondFile": {
        "name": "test/boundary4.tcl",
        "start": 117,
        "end": 124,
        "startLoc": {
          "line": 117,
          "column": 1,
          "position": 853
        },
        "endLoc": {
          "line": 124,
          "column": 50,
          "position": 949
        }
      }
    },
    {
      "format": "tcl",
      "lines": 18,
      "fragment": "puts \"  \\175\"\n    puts \"\\175 {$r $x}\"\n  }\n\n  foreach op {> >= < <=} subno {gt ge lt le} {\n\n    ################################################################ 2.x.y.1\n    set rset {}\n    set aset {}\n    foreach rx $nums2 {\n      if \"\\$rx $op \\$r\" {\n        lappend rset $rx\n        lappend aset $t1ra($rx)\n      }\n    }\n    puts \"do_test $tname-2.$i.$subno.1 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE r $op $r ORDER BY a\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 162,
        "end": 179,
        "startLoc": {
          "line": 162,
          "column": 5,
          "position": 1138
        },
        "endLoc": {
          "line": 179,
          "column": 49,
          "position": 1256
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 176,
        "end": 193,
        "startLoc": {
          "line": 176,
          "column": 5,
          "position": 1242
        },
        "endLoc": {
          "line": 193,
          "column": 43,
          "position": 1360
        }
      }
    },
    {
      "format": "tcl",
      "lines": 16,
      "fragment": "puts \"  \\175\"\n    puts \"\\175 {$aset}\"\n  \n    ################################################################ 2.x.y.5\n    set aset {}\n    set xset {}\n    foreach rx $rset {\n      lappend xset $t1rx($rx)\n    }\n    foreach x [sort $xset] {\n      set rx $t1xr($x)\n      lappend aset $t1ra($rx)\n    }\n    puts \"do_test $tname-2.$i.$subno.5 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE r $op $r ORDER BY x\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 209,
        "end": 224,
        "startLoc": {
          "line": 209,
          "column": 5,
          "position": 1427
        },
        "endLoc": {
          "line": 224,
          "column": 49,
          "position": 1536
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 231,
        "end": 246,
        "startLoc": {
          "line": 231,
          "column": 5,
          "position": 1573
        },
        "endLoc": {
          "line": 246,
          "column": 55,
          "position": 1682
        }
      }
    },
    {
      "format": "tcl",
      "lines": 14,
      "fragment": "[string length $r5]>15} continue\n    set rset {}\n    set aset {}\n    foreach rx $nums2 {\n      if \"\\$rx $op \\$r0\" {\n        lappend rset $rx\n      }\n    }\n    foreach rx [sort $rset] {\n      lappend aset $t1ra($rx)\n    }\n    puts \"do_test $tname-2.$i.$subno.10 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE r $op $r0 ORDER BY r\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 229,
        "end": 242,
        "startLoc": {
          "line": 229,
          "column": 2,
          "position": 1567
        },
        "endLoc": {
          "line": 242,
          "column": 50,
          "position": 1670
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 253,
        "end": 266,
        "startLoc": {
          "line": 253,
          "column": 2,
          "position": 1713
        },
        "endLoc": {
          "line": 266,
          "column": 69,
          "position": 1816
        }
      }
    },
    {
      "format": "tcl",
      "lines": 10,
      "fragment": "set i 0\nforeach r $nums3 {\n  incr i\n\n  if {abs($r)<9.22337203685477580800e+18} {\n    set x $t1rx($r)\n    set a $t1ra($r)\n    set r5 $r.5\n    set r0 $r.0\n    puts \"do_test $tname-4.$i.1 \\173\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 296,
        "end": 305,
        "startLoc": {
          "line": 296,
          "column": 1,
          "position": 1965
        },
        "endLoc": {
          "line": 305,
          "column": 29,
          "position": 2048
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 140,
        "end": 149,
        "startLoc": {
          "line": 140,
          "column": 1,
          "position": 992
        },
        "endLoc": {
          "line": 149,
          "column": 29,
          "position": 1075
        }
      }
    },
    {
      "format": "tcl",
      "lines": 18,
      "fragment": "puts \"  db eval \\173\"\n    puts \"    SELECT r, x FROM t1 WHERE a=$a\"\n    puts \"  \\175\"\n    puts \"\\175 {$r $x}\"\n  }\n\n  foreach op {> >= < <=} subno {gt ge lt le} {\n\n    ################################################################ 2.x.y.1\n    set rset {}\n    set aset {}\n    foreach rx $nums2 {\n      if \"\\$rx $op \\$r\" {\n        lappend rset $rx\n        lappend aset $t1ra($rx)\n      }\n    }\n    puts \"do_test $tname-4.$i.$subno.1 \\173\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 316,
        "end": 333,
        "startLoc": {
          "line": 316,
          "column": 5,
          "position": 2101
        },
        "endLoc": {
          "line": 333,
          "column": 36,
          "position": 2219
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 160,
        "end": 191,
        "startLoc": {
          "line": 160,
          "column": 5,
          "position": 1128
        },
        "endLoc": {
          "line": 191,
          "column": 36,
          "position": 1350
        }
      }
    },
    {
      "format": "tcl",
      "lines": 16,
      "fragment": "puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE r $op $r ORDER BY r DESC\"\n    puts \"  \\175\"\n    puts \"\\175 {$aset}\"\n  \n    ################################################################ 2.x.y.5\n    set aset {}\n    set xset {}\n    foreach rx $rset {\n      lappend xset $t1rx($rx)\n    }\n    foreach x [sort $xset] {\n      set rx $t1xr($x)\n      lappend aset $t1ra($rx)\n    }\n    puts \"do_test $tname-4.$i.$subno.5 \\173\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 363,
        "end": 378,
        "startLoc": {
          "line": 363,
          "column": 5,
          "position": 2390
        },
        "endLoc": {
          "line": 378,
          "column": 36,
          "position": 2499
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 207,
        "end": 244,
        "startLoc": {
          "line": 207,
          "column": 5,
          "position": 1417
        },
        "endLoc": {
          "line": 244,
          "column": 36,
          "position": 1672
        }
      }
    },
    {
      "format": "tcl",
      "lines": 18,
      "fragment": "puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE r $op $r ORDER BY x\"\n    puts \"  \\175\"\n    puts \"\\175 {$aset}\"\n  \n    ################################################################ 2.x.y.10\n    if {abs($r)>9223372036854775808 || [string length $r5]>15} continue\n    set rset {}\n    set aset {}\n    foreach rx $nums2 {\n      if \"\\$rx $op \\$r0\" {\n        lappend rset $rx\n      }\n    }\n    foreach rx [sort $rset] {\n      lappend aset $t1ra($rx)\n    }\n    puts \"do_test $tname-4.$i.$subno.10 \\173\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary2.tcl",
        "start": 379,
        "end": 396,
        "startLoc": {
          "line": 379,
          "column": 5,
          "position": 2502
        },
        "endLoc": {
          "line": 396,
          "column": 37,
          "position": 2633
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 223,
        "end": 264,
        "startLoc": {
          "line": 223,
          "column": 5,
          "position": 1529
        },
        "endLoc": {
          "line": 264,
          "column": 37,
          "position": 1806
        }
      }
    },
    {
      "format": "tcl",
      "lines": 93,
      "fragment": "set testdir [file dirname $argv0]\nsource $testdir/tester.tcl\n\n# Many of the boundary tests depend on a working 64-bit implementation.\nif {![working_64bit_int]} { finish_test; return }\n}\n\nexpr srand(0)\n\n# Generate interesting boundary numbers\n#\nforeach x {\n  0\n  1\n  0x7f\n  0x7fff\n  0x7fffff\n  0x7fffffff\n  0x7fffffffff\n  0x7fffffffffff\n  0x7fffffffffffff\n  0x7fffffffffffffff\n} {\n  set x [expr {wide($x)}]\n  set boundarynum($x) 1\n  set boundarynum([expr {$x+1}]) 1\n  set boundarynum([expr {-($x+1)}]) 1\n  set boundarynum([expr {-($x+2)}]) 1\n  set boundarynum([expr {$x+$x+1}]) 1\n  set boundarynum([expr {$x+$x+2}]) 1\n}\nset x [expr {wide(127)}]\nfor {set i 1} {$i<=9} {incr i} {\n  set boundarynum($x) 1\n  set boundarynum([expr {$x+1}]) 1\n  set x [expr {wide($x*128 + 127)}]\n}\n\n# Scramble the $inlist into a random order.\n#\nproc scramble {inlist} {\n  set y {}\n  foreach x $inlist {\n    lappend y [list [expr {rand()}] $x]\n  }\n  set y [lsort $y]\n  set outlist {}\n  foreach x $y {\n    lappend outlist [lindex $x 1]\n  }\n  return $outlist\n}\n\n# A simple selection sort.  Not trying to be efficient.\n#\nproc sort {inlist} {\n  set outlist {}\n  set mn [lindex $inlist 0]\n  foreach x $inlist {\n    if {$x<$mn} {set mn $x}\n  }\n  set outlist $mn\n  set mx $mn\n  while {1} {\n    set valid 0\n    foreach x $inlist {\n      if {$x>$mx && (!$valid || $mn>$x)} {\n        set mn $x\n        set valid 1\n      }\n    }\n    if {!$valid} break\n    lappend outlist $mn\n    set mx $mn\n  }\n  return $outlist\n}\n\n# Reverse the order of a list\n#\nproc reverse {inlist} {\n  set i [llength $inlist]\n  set outlist {}\n  for {incr i -1} {$i>=0} {incr i -1} {\n    lappend outlist [lindex $inlist $i]\n  }\n  return $outlist\n}\n\nset nums1 [scramble [array names boundarynum]]\nset nums2 [scramble [array names boundarynum]]\n\nset tname boundary1",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary1.tcl",
        "start": 18,
        "end": 110,
        "startLoc": {
          "line": 18,
          "column": 1,
          "position": 36
        },
        "endLoc": {
          "line": 110,
          "column": 10,
          "position": 805
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 17,
        "end": 109,
        "startLoc": {
          "line": 17,
          "column": 1,
          "position": 34
        },
        "endLoc": {
          "line": 109,
          "column": 10,
          "position": 812
        }
      }
    },
    {
      "format": "tcl",
      "lines": 10,
      "fragment": "set a 0\nforeach r $nums1 {\n  incr a\n  set t1ra($r) $a\n  set t1ar($a) $r\n  set x [format %08x%08x [expr {wide($r)>>32}] $r]\n  set t1rx($r) $x\n  set t1xr($x) $r\n  puts \"    INSERT INTO t1(oid,a,x) VALUES($r,$a,'$x');\"\n}",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary1.tcl",
        "start": 114,
        "end": 123,
        "startLoc": {
          "line": 114,
          "column": 1,
          "position": 819
        },
        "endLoc": {
          "line": 123,
          "column": 2,
          "position": 923
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 114,
        "end": 125,
        "startLoc": {
          "line": 114,
          "column": 1,
          "position": 819
        },
        "endLoc": {
          "line": 125,
          "column": 8,
          "position": 952
        }
      }
    },
    {
      "format": "tcl",
      "lines": 25,
      "fragment": "puts \"  \\175\"\nputs \"\\175 {}\"\n\nputs \"do_test $tname-1.2 \\173\"\nputs \"  db eval \\173\"\nputs \"    SELECT count(*) FROM t1\"\nputs \"  \\175\"\nputs \"\\175 {64}\"\n\nset nums3 $nums2\nlappend nums3 9.22337303685477580800e+18\nlappend nums3 -9.22337303685477580800e+18\n\nset i 0\nforeach r $nums3 {\n  incr i\n\n  if {abs($r)<9.22337203685477580800e+18} {\n    set x $t1rx($r)\n    set a $t1ra($r)\n    set r5 $r.5\n    set r0 $r.0\n    puts \"do_test $tname-2.$i.1 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT * FROM t1 WHERE rowid=$r\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary1.tcl",
        "start": 126,
        "end": 150,
        "startLoc": {
          "line": 126,
          "column": 1,
          "position": 933
        },
        "endLoc": {
          "line": 150,
          "column": 38,
          "position": 1081
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 127,
        "end": 151,
        "startLoc": {
          "line": 127,
          "column": 1,
          "position": 937
        },
        "endLoc": {
          "line": 151,
          "column": 34,
          "position": 1085
        }
      }
    },
    {
      "format": "tcl",
      "lines": 18,
      "fragment": "puts \"  \\175\"\n    puts \"\\175 {$r $x}\"\n  }\n\n  foreach op {> >= < <=} subno {gt ge lt le} {\n\n    ################################################################ 2.x.y.1\n    set rset {}\n    set aset {}\n    foreach rx $nums2 {\n      if \"\\$rx $op \\$r\" {\n        lappend rset $rx\n        lappend aset $t1ra($rx)\n      }\n    }\n    puts \"do_test $tname-2.$i.$subno.1 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE rowid $op $r ORDER BY a\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary1.tcl",
        "start": 161,
        "end": 178,
        "startLoc": {
          "line": 161,
          "column": 5,
          "position": 1134
        },
        "endLoc": {
          "line": 178,
          "column": 53,
          "position": 1252
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 176,
        "end": 193,
        "startLoc": {
          "line": 176,
          "column": 5,
          "position": 1242
        },
        "endLoc": {
          "line": 193,
          "column": 43,
          "position": 1360
        }
      }
    },
    {
      "format": "tcl",
      "lines": 16,
      "fragment": "puts \"  \\175\"\n    puts \"\\175 {$aset}\"\n  \n    ################################################################ 2.x.y.5\n    set aset {}\n    set xset {}\n    foreach rx $rset {\n      lappend xset $t1rx($rx)\n    }\n    foreach x [sort $xset] {\n      set rx $t1xr($x)\n      lappend aset $t1ra($rx)\n    }\n    puts \"do_test $tname-2.$i.$subno.5 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE rowid $op $r ORDER BY x\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary1.tcl",
        "start": 208,
        "end": 223,
        "startLoc": {
          "line": 208,
          "column": 5,
          "position": 1423
        },
        "endLoc": {
          "line": 223,
          "column": 53,
          "position": 1532
        }
      },
      "secondFile": {
        "name": "test/boundary3.tcl",
        "start": 231,
        "end": 246,
        "startLoc": {
          "line": 231,
          "column": 5,
          "position": 1573
        },
        "endLoc": {
          "line": 246,
          "column": 55,
          "position": 1682
        }
      }
    },
    {
      "format": "tcl",
      "lines": 18,
      "fragment": "puts \"  \\175\"\n    puts \"\\175 {$aset}\"\n  \n    ################################################################ 2.x.y.10\n    if {abs($r)>9223372036854775808 || [string length $r5]>15} continue\n    set rset {}\n    set aset {}\n    foreach rx $nums2 {\n      if \"\\$rx $op \\$r0\" {\n        lappend rset $rx\n      }\n    }\n    foreach rx [sort $rset] {\n      lappend aset $t1ra($rx)\n    }\n    puts \"do_test $tname-2.$i.$subno.10 \\173\"\n    puts \"  db eval \\173\"\n    puts \"    SELECT a FROM t1 WHERE rowid $op $r0 ORDER BY rowid\"",
      "tokens": 0,
      "firstFile": {
        "name": "test/boundary1.tcl",
        "start": 224,
        "end": 241,
        "startLoc": {
          "line": 224,
          "column": 5,
          "position": 1535
        },
        "endLoc": {
          "line": 241,
          "column": 58,
          "position": 1666
        }
      },
      "secondFile": {
        "name": "test/boundary2.tcl",
        "start": 225,
        "end": 266,
        "startLoc": {
          "line": 225,
          "column": 5,
          "position": 1539
        },
        "endLoc": {
          "line": 266,
          "column": 69,
          "position": 1816
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "  \"wr INT,\"\n      \"subprog TEXT,\" \n      \"stmt HIDDEN\"\n   \");\"\n  };\n\n  rc = sqlite3_declare_vtab(db, azSchema[isTabUsed]);\n  if( rc==SQLITE_OK ){\n    pNew = sqlite3_malloc( sizeof(*pNew) );\n    *ppVtab = (sq",
      "tokens": 0,
      "firstFile": {
        "name": "src/vdbevtab.c",
        "start": 86,
        "end": 93,
        "startLoc": {
          "line": 86,
          "column": 2,
          "position": 367
        },
        "endLoc": {
          "line": 93,
          "column": 5,
          "position": 454
        }
      },
      "secondFile": {
        "name": "ext/misc/vtablog.c",
        "start": 203,
        "end": 100,
        "startLoc": {
          "line": 203,
          "column": 8,
          "position": 1283
        },
        "endLoc": {
          "line": 100,
          "column": 2,
          "position": 305
        }
      }
    },
    {
      "format": "c",
      "lines": 45,
      "fragment": "SQLITE_BYTEORDER==0 */\n\n/*\n** This lookup table is used to help decode the first byte of\n** a multi-byte UTF8 character.\n*/\nstatic const unsigned char sqlite3Utf8Trans1[] = {\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,\n};\n\n\n#define WRITE_UTF8(zOut, c) {                          \\\n  if( c<0x00080 ){                                     \\\n    *zOut++ = (u8)(c&0xFF);                            \\\n  }                                                    \\\n  else if( c<0x00800 ){                                \\\n    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \\\n    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n  }                                                    \\\n  else if( c<0x10000 ){                                \\\n    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \\\n    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \\\n    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n  }else{                                               \\\n    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \\\n    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \\\n    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \\\n    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n  }            ",
      "tokens": 0,
      "firstFile": {
        "name": "src/utf.c",
        "start": 52,
        "end": 96,
        "startLoc": {
          "line": 52,
          "column": 1,
          "position": 25
        },
        "endLoc": {
          "line": 96,
          "column": 3,
          "position": 252
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_unicode.c",
        "start": 35,
        "end": 142,
        "startLoc": {
          "line": 35,
          "column": 1,
          "position": 19
        },
        "endLoc": {
          "line": 142,
          "column": 9,
          "position": 933
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "\n  /* If the translation is between UTF-16 little and big endian, then \n  ** all that is required is to swap the byte order. This case is handled\n  ** differently from the others.\n  */\n  if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){\n    u",
      "tokens": 0,
      "firstFile": {
        "name": "src/utf.c",
        "start": 273,
        "end": 283,
        "startLoc": {
          "line": 273,
          "column": 2,
          "position": 1619
        },
        "endLoc": {
          "line": 283,
          "column": 2,
          "position": 1714
        }
      },
      "secondFile": {
        "name": "src/utf.c",
        "start": 244,
        "end": 254,
        "startLoc": {
          "line": 244,
          "column": 2,
          "position": 1316
        },
        "endLoc": {
          "line": 254,
          "column": 2,
          "position": 1411
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "7    /* unicode characters usable in IDs */\n#define CC_ILLEGAL   28    /* Illegal character */\n#define CC_NUL       29    /* 0x00 */\n\nstatic const unsigned char aiClass[] = {\n#ifdef SQLITE_ASCII\n/*         x0  x1  x2  x3  x4  x5  x6  x7  x8  x9  xa  xb  xc  xd  xe  xf */\n/* 0x */   29, 28, 28, 28, 28, 28, 28, 28, 28,  7,  7, 28,  7,  7, 28, 28,\n/* 1x */   28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,\n/* 2x */    7, 15,  8,  5,  4, 22, 24,  8, 17, 18, 21, 20, 23, 11, 26, 16,\n/* 3x */    3,  3,  3,  3,  3,  3,  3,  3,  3,  3,  5, 19, 12, 14, 13,  6,\n/* 4x */    5,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,\n/* 5x */    1,  1,  1,  1,  1,  ",
      "tokens": 0,
      "firstFile": {
        "name": "src/tokenize.c",
        "start": 70,
        "end": 81,
        "startLoc": {
          "line": 70,
          "column": 3,
          "position": 485
        },
        "endLoc": {
          "line": 81,
          "column": 77,
          "position": 888
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 115,
        "end": 124,
        "startLoc": {
          "line": 115,
          "column": 3,
          "position": 484
        },
        "endLoc": {
          "line": 124,
          "column": 2,
          "position": 885
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "token is either TK_LP or an identifier.\n**\n** FILTER is a keyword if:\n**\n**   * the previous token was TK_RP, and\n**   * the next token is TK_LP.\n*/\nstatic int analyzeWindowKeyword(const unsigned char *z){\n  int t;\n  t = getToken(&z);\n  i",
      "tokens": 0,
      "firstFile": {
        "name": "src/tokenize.c",
        "start": 283,
        "end": 290,
        "startLoc": {
          "line": 283,
          "column": 7,
          "position": 3677
        },
        "endLoc": {
          "line": 290,
          "column": 25,
          "position": 3780
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 306,
        "end": 314,
        "startLoc": {
          "line": 306,
          "column": 7,
          "position": 2536
        },
        "endLoc": {
          "line": 314,
          "column": 7,
          "position": 2640
        }
      }
    },
    {
      "format": "c",
      "lines": 33,
      "fragment": "ID ) return TK_ID;\n  t = getToken(&z);\n  if( t!=TK_AS ) return TK_ID;\n  return TK_WINDOW;\n}\nstatic int analyzeOverKeyword(const unsigned char *z, int lastToken){\n  if( lastToken==TK_RP ){\n    int t = getToken(&z);\n    if( t==TK_LP || t==TK_ID ) return TK_OVER;\n  }\n  return TK_ID;\n}\nstatic int analyzeFilterKeyword(const unsigned char *z, int lastToken){\n  if( lastToken==TK_RP && getToken(&z)==TK_LP ){\n    return TK_FILTER;\n  }\n  return TK_ID;\n}\n#endif /* SQLITE_OMIT_WINDOWFUNC */\n\n/*\n** Return the length (in bytes) of the token that begins at z[0]. \n** Store the token type in *tokenType before returning.\n*/\nint sqlite3GetToken(const unsigned char *z, int *to",
      "tokens": 0,
      "firstFile": {
        "name": "src/tokenize.c",
        "start": 291,
        "end": 323,
        "startLoc": {
          "line": 291,
          "column": 9,
          "position": 3783
        },
        "endLoc": {
          "line": 323,
          "column": 25,
          "position": 4060
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 314,
        "end": 347,
        "startLoc": {
          "line": 314,
          "column": 9,
          "position": 2640
        },
        "endLoc": {
          "line": 347,
          "column": 7,
          "position": 2918
        }
      }
    },
    {
      "format": "c",
      "lines": 106,
      "fragment": "){\n  int i, c;\n  switch( aiClass[*z] ){  /* Switch on the character-class of the first byte\n                          ** of the token. See the comment on the CC_ defines\n                          ** above. */\n    case CC_SPACE: {\n      testcase( z[0]==' ' );\n      testcase( z[0]=='\\t' );\n      testcase( z[0]=='\\n' );\n      testcase( z[0]=='\\f' );\n      testcase( z[0]=='\\r' );\n      for(i=1; sqlite3Isspace(z[i]); i++){}\n      *tokenType = TK_SPACE;\n      return i;\n    }\n    case CC_MINUS: {\n      if( z[1]=='-' ){\n        for(i=2; (c=z[i])!=0 && c!='\\n'; i++){}\n        *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */\n        return i;\n      }\n      *tokenType = TK_MINUS;\n      return 1;\n    }\n    case CC_LP: {\n      *tokenType = TK_LP;\n      return 1;\n    }\n    case CC_RP: {\n      *tokenType = TK_RP;\n      return 1;\n    }\n    case CC_SEMI: {\n      *tokenType = TK_SEMI;\n      return 1;\n    }\n    case CC_PLUS: {\n      *tokenType = TK_PLUS;\n      return 1;\n    }\n    case CC_STAR: {\n      *tokenType = TK_STAR;\n      return 1;\n    }\n    case CC_SLASH: {\n      if( z[1]!='*' || z[2]==0 ){\n        *tokenType = TK_SLASH;\n        return 1;\n      }\n      for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}\n      if( c ) i++;\n      *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */\n      return i;\n    }\n    case CC_PERCENT: {\n      *tokenType = TK_REM;\n      return 1;\n    }\n    case CC_EQ: {\n      *tokenType = TK_EQ;\n      return 1 + (z[1]=='=');\n    }\n    case CC_LT: {\n      if( (c=z[1])=='=' ){\n        *tokenType = TK_LE;\n        return 2;\n      }else if( c=='>' ){\n        *tokenType = TK_NE;\n        return 2;\n      }else if( c=='<' ){\n        *tokenType = TK_LSHIFT;\n        return 2;\n      }else{\n        *tokenType = TK_LT;\n        return 1;\n      }\n    }\n    case CC_GT: {\n      if( (c=z[1])=='=' ){\n        *tokenType = TK_GE;\n        return 2;\n      }else if( c=='>' ){\n        *tokenType = TK_RSHIFT;\n        return 2;\n      }else{\n        *tokenType = TK_GT;\n        return 1;\n      }\n    }\n    case CC_BANG: {\n      if( z[1]!='=' ){\n        *tokenType = TK_ILLEGAL;\n        return 1;\n      }else{\n        *tokenT",
      "tokens": 0,
      "firstFile": {
        "name": "src/tokenize.c",
        "start": 324,
        "end": 429,
        "startLoc": {
          "line": 324,
          "column": 7,
          "position": 4063
        },
        "endLoc": {
          "line": 429,
          "column": 9,
          "position": 4839
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 347,
        "end": 449,
        "startLoc": {
          "line": 347,
          "column": 7,
          "position": 2918
        },
        "endLoc": {
          "line": 449,
          "column": 2,
          "position": 3690
        }
      }
    },
    {
      "format": "c",
      "lines": 71,
      "fragment": "= TK_COMMA;\n      return 1;\n    }\n    case CC_AND: {\n      *tokenType = TK_BITAND;\n      return 1;\n    }\n    case CC_TILDA: {\n      *tokenType = TK_BITNOT;\n      return 1;\n    }\n    case CC_QUOTE: {\n      int delim = z[0];\n      testcase( delim=='`' );\n      testcase( delim=='\\'' );\n      testcase( delim=='\"' );\n      for(i=1; (c=z[i])!=0; i++){\n        if( c==delim ){\n          if( z[i+1]==delim ){\n            i++;\n          }else{\n            break;\n          }\n        }\n      }\n      if( c=='\\'' ){\n        *tokenType = TK_STRING;\n        return i+1;\n      }else if( c!=0 ){\n        *tokenType = TK_ID;\n        return i+1;\n      }else{\n        *tokenType = TK_ILLEGAL;\n        return i;\n      }\n    }\n    case CC_DOT: {\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      if( !sqlite3Isdigit(z[1]) )\n#endif\n      {\n        *tokenType = TK_DOT;\n        return 1;\n      }\n      /* If the next character is a digit, this is a floating point\n      ** number that begins with \".\".  Fall thru into the next case */\n      /* no break */ deliberate_fall_through\n    }\n    case CC_DIGIT: {\n      testcase( z[0]=='0' );  testcase( z[0]=='1' );  testcase( z[0]=='2' );\n      testcase( z[0]=='3' );  testcase( z[0]=='4' );  testcase( z[0]=='5' );\n      testcase( z[0]=='6' );  testcase( z[0]=='7' );  testcase( z[0]=='8' );\n      testcase( z[0]=='9' );\n      *tokenType = TK_INTEGER;\n#ifndef SQLITE_OMIT_HEX_INTEGER\n      if( z[0]=='0' && (z[1]=='x' || z[1]=='X') && sqlite3Isxdigit(z[2]) ){\n        for(i=3; sqlite3Isxdigit(z[i]); i++){}\n        return i;\n      }\n#endif\n      for(i=0; sqlite3Isdigit(z[i]); i++){}\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      if( z[i]=='.' ){\n        i++;\n        while( sqlite3Isdigit(",
      "tokens": 0,
      "firstFile": {
        "name": "src/tokenize.c",
        "start": 433,
        "end": 503,
        "startLoc": {
          "line": 433,
          "column": 7,
          "position": 4973
        },
        "endLoc": {
          "line": 503,
          "column": 9,
          "position": 5733
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 449,
        "end": 513,
        "startLoc": {
          "line": 449,
          "column": 7,
          "position": 3690
        },
        "endLoc": {
          "line": 513,
          "column": 8,
          "position": 4444
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "TK_ILLEGAL;\n        i++;\n      }\n      return i;\n    }\n    case CC_QUOTE2: {\n      for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}\n      *tokenType = c==']' ? TK_ID : TK_ILLEGAL;\n      return i;\n    }\n    case CC_VARNUM: {\n      *tokenType = TK_VARIABLE;\n      for(i=1; sqlite3Isdigit(z[i]); i++){}\n      return i;\n    }\n    case CC_DOLLAR:\n    case CC_VARALPHA: {\n      int n = 0;\n      testcase( z[0]=='$' );  testcase( z[0]=='@' );\n      testcase( z[0]==':' );  testcase( z[0]=='#' );\n      *tokenType = TK_VARIABLE;\n      for(i=1; (c=z[i])!=0; i++){\n    ",
      "tokens": 0,
      "firstFile": {
        "name": "src/tokenize.c",
        "start": 513,
        "end": 533,
        "startLoc": {
          "line": 513,
          "column": 2,
          "position": 5819
        },
        "endLoc": {
          "line": 533,
          "column": 8,
          "position": 6004
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 523,
        "end": 541,
        "startLoc": {
          "line": 523,
          "column": 2,
          "position": 4517
        },
        "endLoc": {
          "line": 541,
          "column": 6,
          "position": 4700
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "on does not actually create a new thread.  It does the\n** work of the thread in the main thread, when either the thread is created\n** or when it is joined\n*/\n\n/* A running thread */\nstruct SQLiteThread {\n  void *(*xTask)(void*);   /* The routine to run as a thread */\n  void *pIn;               /* Argument to xTask */\n  void *pResult;           /* Result of xTask */\n};\n\n/* Create a new thread */\nint sqlite3Thread",
      "tokens": 0,
      "firstFile": {
        "name": "src/threads.c",
        "start": 225,
        "end": 238,
        "startLoc": {
          "line": 225,
          "column": 1,
          "position": 1299
        },
        "endLoc": {
          "line": 238,
          "column": 3,
          "position": 1413
        }
      },
      "secondFile": {
        "name": "src/threads.c",
        "start": 145,
        "end": 162,
        "startLoc": {
          "line": 145,
          "column": 1,
          "position": 690
        },
        "endLoc": {
          "line": 162,
          "column": 18,
          "position": 804
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "ata(ctx);\n  Tcl_Obj *pEval = Tcl_DuplicateObj(bValue ? p->xValue : p->xFinal);\n  TestWindowCtx *pCtx = sqlite3_aggregate_context(ctx, sizeof(TestWindowCtx));\n\n  Tcl_IncrRefCount(pEval);\n  if( pCtx ){\n    const char *zResult;\n    int rc;\n    if( pCtx->pVal ){\n      Tcl_ListObjAppendElement(p->interp, pEval, Tcl_DuplicateObj(pCtx->pVal));\n    }else{\n      Tcl_Lis",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_window.c",
        "start": 78,
        "end": 91,
        "startLoc": {
          "line": 78,
          "column": 7,
          "position": 585
        },
        "endLoc": {
          "line": 91,
          "column": 3,
          "position": 703
        }
      },
      "secondFile": {
        "name": "src/test_window.c",
        "start": 46,
        "end": 58,
        "startLoc": {
          "line": 46,
          "column": 6,
          "position": 217
        },
        "endLoc": {
          "line": 58,
          "column": 4,
          "position": 334
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "lite3_result_int64(ctx, res);\n}\n\nstatic int SQLITE_TCLAPI test_create_sumint(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  sqlite3 *db;\n  int rc;\n\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB\");\n    return TCL_ERROR;\n  }\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_window.c",
        "start": 278,
        "end": 293,
        "startLoc": {
          "line": 278,
          "column": 19,
          "position": 2197
        },
        "endLoc": {
          "line": 293,
          "column": 9,
          "position": 2323
        }
      },
      "secondFile": {
        "name": "src/test_window.c",
        "start": 179,
        "end": 194,
        "startLoc": {
          "line": 179,
          "column": 26,
          "position": 1420
        },
        "endLoc": {
          "line": 194,
          "column": 6,
          "position": 1546
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "CL_ERROR;\n  }\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI test_override_sum(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  sqlite3 *db;\n  int rc;\n\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB\");\n    return TCL_ERROR;\n  }\n  if( getDbPointer(interp, Tcl_",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_window.c",
        "start": 305,
        "end": 320,
        "startLoc": {
          "line": 305,
          "column": 18,
          "position": 2412
        },
        "endLoc": {
          "line": 320,
          "column": 24,
          "position": 2533
        }
      },
      "secondFile": {
        "name": "src/test_window.c",
        "start": 179,
        "end": 194,
        "startLoc": {
          "line": 179,
          "column": 26,
          "position": 1420
        },
        "endLoc": {
          "line": 194,
          "column": 31,
          "position": 1541
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  EvalEvent *pEvent;\n  char *zMsg;\n  int nMsg;\n  SqlThread *p = (SqlThread *)clientData;\n\n  assert(objc==3);\n  UNUSED_PARAMETER(objc);\n\n  if( p==0 ){\n    Tcl_AppendResult(interp, \"no parent thread\", 0);\n    return TCL_ERROR;\n  }\n\n  zMsg = Tcl_GetStringFromObj(objv[2], &nMsg);\n  pEvent = (EvalEvent *)",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_thread.c",
        "start": 246,
        "end": 256,
        "startLoc": {
          "line": 246,
          "column": 2,
          "position": 1547
        },
        "endLoc": {
          "line": 256,
          "column": 7,
          "position": 1680
        }
      },
      "secondFile": {
        "name": "src/test_thread.c",
        "start": 99,
        "end": 109,
        "startLoc": {
          "line": 99,
          "column": 8,
          "position": 424
        },
        "endLoc": {
          "line": 109,
          "column": 2,
          "position": 557
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "d res $v\\n\"\n      \"    }\\n\"\n      \"  }\\n\"\n      \"  set res\\n\"\n      \"}\\n\"\n  );\n#endif\n  return rc;\n}\n\n#endif\n\n\n/*\n** Register commands with the TCL interpret",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_tclvar.c",
        "start": 553,
        "end": 558,
        "startLoc": {
          "line": 553,
          "column": 2,
          "position": 3784
        },
        "endLoc": {
          "line": 558,
          "column": 8,
          "position": 3850
        }
      },
      "secondFile": {
        "name": "ext/rbu/test_rbu.c",
        "start": 374,
        "end": 378,
        "startLoc": {
          "line": 374,
          "column": 2,
          "position": 3062
        },
        "endLoc": {
          "line": 378,
          "column": 2,
          "position": 3126
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "\n** Decode a pointer to an sqlite3 object.\n*/\nextern int getDbPointer(Tcl_Interp *interp, const char *zA, sqlite3 **ppDb);\n\n/*\n** Register the schema virtual table module.\n*/\nstatic int SQLITE_TCLAPI register_schem",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_schema.c",
        "start": 313,
        "end": 320,
        "startLoc": {
          "line": 313,
          "column": 3,
          "position": 1812
        },
        "endLoc": {
          "line": 320,
          "column": 9,
          "position": 1890
        }
      },
      "secondFile": {
        "name": "src/test_tclvar.c",
        "start": 507,
        "end": 514,
        "startLoc": {
          "line": 507,
          "column": 3,
          "position": 3542
        },
        "endLoc": {
          "line": 514,
          "column": 9,
          "position": 3620
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "B\");\n    return TCL_ERROR;\n  }\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) ) return TCL_ERROR;\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3_create_module(db, \"schema\", &schemaModule, 0);\n#endif",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_schema.c",
        "start": 334,
        "end": 342,
        "startLoc": {
          "line": 334,
          "column": 23,
          "position": 1970
        },
        "endLoc": {
          "line": 342,
          "column": 2,
          "position": 2061
        }
      },
      "secondFile": {
        "name": "src/test_tclvar.c",
        "start": 553,
        "end": 562,
        "startLoc": {
          "line": 553,
          "column": 23,
          "position": 3780
        },
        "endLoc": {
          "line": 562,
          "column": 2,
          "position": 3872
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "' ' ) z++;\n        while( z[0]==' ' ) z++;\n      }\n    }\n    if( pCircle->radius<0.0 ){\n      sqlite3_free(pCircle);\n      return SQLITE_NOMEM;\n    }\n\n    /* Define two bounding box regions. The first, aBox[0], extends to\n    ** infinity in the X dimension. It covers the same range of the Y dimension\n    ** as the circular region. The second, aBox[1], extends to infinity in\n    ** the Y dimension and is constrained to the range of the circle in the\n    ** X dimension.\n    **\n    ** Then imagine each box is split in half along its short axis by a line\n    ** that intersects the center of the circular region. A bounding box\n    ** being tested can be said to intersect the circular region if it contains\n    ** points from each half of either of the two infinite bounding boxes.\n    */\n    pCircle->aBox[0].xmin = pCircle->centerx;\n    pCircle->aBox[0].xmax = pCircle->centerx;\n    pCircle->aBox[0].ymin = pCircle->centery + pCircle->radius;\n    pCircle->aBox[0].ymax = pCircle->centery - pCircle->radius;\n    pCircle->aBox[1].xmin = pCircle->centerx + pCircle->radius;\n    pCircle->aBox[1].xmax = ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_rtree.c",
        "start": 235,
        "end": 254,
        "startLoc": {
          "line": 235,
          "column": 5,
          "position": 1624
        },
        "endLoc": {
          "line": 254,
          "column": 6,
          "position": 1793
        }
      },
      "secondFile": {
        "name": "src/test_rtree.c",
        "start": 99,
        "end": 118,
        "startLoc": {
          "line": 99,
          "column": 5,
          "position": 440
        },
        "endLoc": {
          "line": 118,
          "column": 2,
          "position": 609
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "e->centerx - pCircle->radius;\n    pCircle->aBox[1].ymin = pCircle->centery;\n    pCircle->aBox[1].ymax = pCircle->centery;\n    pCircle->mxArea = 200.0*200.0;\n  }\n\n  /* Check if any of the 4 corners of the bounding-box being tested lie \n  ** inside the circular region. If they do, then the bounding-box does\n  ** intersect the region of interest. Set the output variable to true and\n  ** return SQLITE_OK in this case. */\n  for(i=0; i<4; i++){\n    double x = (i&0x01) ? xmax : xmin;\n    double y = (i&0x02) ? ymax : ymin;\n    double d2;\n    \n    d",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_rtree.c",
        "start": 254,
        "end": 268,
        "startLoc": {
          "line": 254,
          "column": 6,
          "position": 1796
        },
        "endLoc": {
          "line": 268,
          "column": 8,
          "position": 1938
        }
      },
      "secondFile": {
        "name": "src/test_rtree.c",
        "start": 118,
        "end": 132,
        "startLoc": {
          "line": 118,
          "column": 4,
          "position": 628
        },
        "endLoc": {
          "line": 132,
          "column": 2,
          "position": 769
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": " this test works. If it does\n  ** cover part of the circular region, set the output variable to true\n  ** and return SQLITE_OK. */\n  if( nWithin==0 ){\n    for(i=0; i<2; i++){\n      if( xmin<=pCircle->",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_rtree.c",
        "start": 276,
        "end": 282,
        "startLoc": {
          "line": 276,
          "column": 5,
          "position": 1961
        },
        "endLoc": {
          "line": 282,
          "column": 8,
          "position": 2044
        }
      },
      "secondFile": {
        "name": "src/test_rtree.c",
        "start": 142,
        "end": 148,
        "startLoc": {
          "line": 142,
          "column": 3,
          "position": 797
        },
        "endLoc": {
          "line": 148,
          "column": 2,
          "position": 880
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "nterp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n#ifndef SQLITE_ENABLE_RTREE\n  UNUSED_PARAMETER(clientData);\n  UNUSED_PARAMETER(interp);\n  UNUSED_PARAMETER(objc);\n  UNUSED_PARAMETER(objv);\n#else\n  extern int getDbPointer(Tcl_Inte",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_rtree.c",
        "start": 457,
        "end": 465,
        "startLoc": {
          "line": 457,
          "column": 3,
          "position": 3370
        },
        "endLoc": {
          "line": 465,
          "column": 32,
          "position": 3453
        }
      },
      "secondFile": {
        "name": "src/test_window.c",
        "start": 185,
        "end": 194,
        "startLoc": {
          "line": 185,
          "column": 3,
          "position": 1457
        },
        "endLoc": {
          "line": 194,
          "column": 31,
          "position": 1541
        }
      }
    },
    {
      "format": "c",
      "lines": 23,
      "fragment": "CL_ERROR;\n  }\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) ) return TCL_ERROR;\n  rc = sqlite3_rtree_geometry_callback(db, \"cube\", cube_geom, (void *)&gHere);\n  Tcl_SetResult(interp, (char *)sqlite3ErrName(rc), TCL_STATIC);\n#endif\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI register_circle_geom(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n#ifndef SQLITE_ENABLE_RTREE\n  UNUSED_PARAMETER(clientData);\n  UNUSED_PARAMETER(interp);\n  UNUSED_PARAMETER(objc);\n  UNUSED_PARAMETER(objv);\n#else\n  extern ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_rtree.c",
        "start": 471,
        "end": 493,
        "startLoc": {
          "line": 471,
          "column": 21,
          "position": 3512
        },
        "endLoc": {
          "line": 493,
          "column": 9,
          "position": 3704
        }
      },
      "secondFile": {
        "name": "src/test_rtree.c",
        "start": 443,
        "end": 465,
        "startLoc": {
          "line": 443,
          "column": 19,
          "position": 3266
        },
        "endLoc": {
          "line": 465,
          "column": 7,
          "position": 3458
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "rn 0;\n  }\n\n  /* If there are no free pages, recycle a page.  The page to\n  ** recycle is selected at random from all unpinned pages.\n  */\n  j = testpcacheRandom(p) % TESTPCACHE_NPAGE;\n  for",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_pcache.c",
        "start": 270,
        "end": 276,
        "startLoc": {
          "line": 270,
          "column": 9,
          "position": 1679
        },
        "endLoc": {
          "line": 276,
          "column": 7,
          "position": 1771
        }
      },
      "secondFile": {
        "name": "src/test_pcache.c",
        "start": 243,
        "end": 249,
        "startLoc": {
          "line": 243,
          "column": 4,
          "position": 1423
        },
        "endLoc": {
          "line": 249,
          "column": 2,
          "position": 1515
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": ">(pReal->nBlob-pReal->nJournal) ){\n      rc = SQLITE_FULL;\n    }else{\n      rc = pF->pMethods->xWrite(pF, zBuf, iAmt, iOfst+BLOCKSIZE);\n      if( rc==SQLITE_OK ){\n        pReal->nDatabase = (int)MAX(pReal->nDatabase, iAmt+iOfst);\n      }\n    }\n  }else{\n    /* Journal file. */\n    int iRem",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_onefile.c",
        "start": 459,
        "end": 468,
        "startLoc": {
          "line": 459,
          "column": 3,
          "position": 2740
        },
        "endLoc": {
          "line": 468,
          "column": 3,
          "position": 2855
        }
      },
      "secondFile": {
        "name": "src/test_onefile.c",
        "start": 417,
        "end": 426,
        "startLoc": {
          "line": 417,
          "column": 3,
          "position": 2335
        },
        "endLoc": {
          "line": 426,
          "column": 3,
          "position": 2450
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "  Tcl_Obj *CONST objv[]\n){\n  sqlite3_mutex *pMutex;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"NAME\");\n    return TCL_ERROR;\n  }\n  pMutex = getStaticMutexPointer(interp, objv[1]);\n  if( !pMutex ){\n    return TCL_ERROR;\n  }\n  sqlite3_mutex_enter(pMutex);\n  return TCL_OK;\n}\n\nstatic int SQLITE_TCLAPI te",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_mutex.c",
        "start": 423,
        "end": 438,
        "startLoc": {
          "line": 423,
          "column": 24,
          "position": 2756
        },
        "endLoc": {
          "line": 438,
          "column": 20,
          "position": 2872
        }
      },
      "secondFile": {
        "name": "src/test_mutex.c",
        "start": 404,
        "end": 419,
        "startLoc": {
          "line": 404,
          "column": 24,
          "position": 2618
        },
        "endLoc": {
          "line": 419,
          "column": 20,
          "position": 2734
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "nterp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  sqlite3 *db;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB\");\n    return TCL_ERROR;\n  }\n  db = getDbPointer(interp, objv[1]);\n  if( !db ){\n    return TCL_ERROR;\n  }\n  sqlite3_mutex_enter(sqlite3_db_mutex(db));\n  return TCL_O",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_mutex.c",
        "start": 461,
        "end": 476,
        "startLoc": {
          "line": 461,
          "column": 20,
          "position": 3035
        },
        "endLoc": {
          "line": 476,
          "column": 20,
          "position": 3151
        }
      },
      "secondFile": {
        "name": "src/test_mutex.c",
        "start": 442,
        "end": 457,
        "startLoc": {
          "line": 442,
          "column": 20,
          "position": 2894
        },
        "endLoc": {
          "line": 457,
          "column": 20,
          "position": 3010
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "gv[2]);\n    amt = atoi(argv[3]);\n  }else{\n    ofst = 0;\n    amt = 2147483647;\n  }\n  in = fopen(argv[1],\"rb\");\n  if( in==0 ){\n    Tcl_AppendResult(interp,\"unable to open file \\\"\", argv[1],\n         \"\\\" for reading\", (char*)0);\n    return TCL_ERROR;\n  }\n  fseek(in, ofst, ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_md5.c",
        "start": 387,
        "end": 398,
        "startLoc": {
          "line": 387,
          "column": 3,
          "position": 4104
        },
        "endLoc": {
          "line": 398,
          "column": 3,
          "position": 4177
        }
      },
      "secondFile": {
        "name": "src/test_md5.c",
        "start": 334,
        "end": 345,
        "startLoc": {
          "line": 334,
          "column": 2,
          "position": 3618
        },
        "endLoc": {
          "line": 345,
          "column": 3,
          "position": 3691
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "r*)0);\n    return TCL_ERROR;\n  }\n#endif\n  return TCL_OK;\n}\n\n/*\n** Register commands with the TCL interpreter.\n*/\nint Sqlitetestintarray_Init(Tcl_Interp *interp){\n  static struct {\n     char *zName;\n     Tcl_ObjCmdProc *xPr",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_intarray.c",
        "start": 382,
        "end": 392,
        "startLoc": {
          "line": 382,
          "column": 19,
          "position": 2221
        },
        "endLoc": {
          "line": 392,
          "column": 18,
          "position": 2315
        }
      },
      "secondFile": {
        "name": "src/test_tclvar.c",
        "start": 553,
        "end": 348,
        "startLoc": {
          "line": 553,
          "column": 23,
          "position": 3780
        },
        "endLoc": {
          "line": 348,
          "column": 3,
          "position": 2066
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "_wrapper_query  },\n    {\"init_wrapper_uninstall\", init_wrapper_uninstall},\n    {\"init_wrapper_clear\",     init_wrapper_clear}\n  };\n  int i;\n\n  for(i=0; i<sizeof(aObjCm",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_init.c",
        "start": 287,
        "end": 295,
        "startLoc": {
          "line": 287,
          "column": 3,
          "position": 2191
        },
        "endLoc": {
          "line": 295,
          "column": 2,
          "position": 2269
        }
      },
      "secondFile": {
        "name": "ext/rbu/test_rbu.c",
        "start": 375,
        "end": 381,
        "startLoc": {
          "line": 375,
          "column": 3,
          "position": 3066
        },
        "endLoc": {
          "line": 381,
          "column": 2,
          "position": 3142
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "0, 0, 0, 0, 0, 0, 0, 0,\n     1, 2, 3, 4, 5, 6, 7, 8,  9,10, 0, 0, 0, 0, 0, 0,\n     0,11,12,13,14,15,16, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0,11,12,13,14,15,16, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,\n     0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_hexio.c",
        "start": 63,
        "end": 74,
        "startLoc": {
          "line": 63,
          "column": 2,
          "position": 483
        },
        "endLoc": {
          "line": 74,
          "column": 2,
          "position": 988
        }
      },
      "secondFile": {
        "name": "src/test_hexio.c",
        "start": 61,
        "end": 7,
        "startLoc": {
          "line": 61,
          "column": 3,
          "position": 391
        },
        "endLoc": {
          "line": 7,
          "column": 2,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "K;\n}\n\n\n/*\n** USAGE:   hexio_render_int32   INTEGER\n**\n** Render INTEGER has a 32-bit big-endian integer in hexadecimal.\n*/\nstatic int SQLITE_TCLAPI hexio_render_int32(\n  void * clientData,\n  Tcl_Interp *interp,\n  int objc,\n  Tcl_Obj *CONST objv[]\n){\n  int val;\n  unsigned char aNum[10];\n\n  if( objc!=2",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_hexio.c",
        "start": 266,
        "end": 280,
        "startLoc": {
          "line": 266,
          "column": 19,
          "position": 2509
        },
        "endLoc": {
          "line": 280,
          "column": 3,
          "position": 2635
        }
      },
      "secondFile": {
        "name": "src/test_hexio.c",
        "start": 239,
        "end": 253,
        "startLoc": {
          "line": 239,
          "column": 19,
          "position": 2320
        },
        "endLoc": {
          "line": 253,
          "column": 2,
          "position": 2446
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "urn TCL_ERROR;\n#endif\n}\n\nstatic int getFts3Varint(const char *p, sqlite_int64 *v){\n  const unsigned char *q = (const unsigned char *) p;\n  sql",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_hexio.c",
        "start": 331,
        "end": 340,
        "startLoc": {
          "line": 331,
          "column": 2,
          "position": 3054
        },
        "endLoc": {
          "line": 340,
          "column": 7,
          "position": 3145
        }
      },
      "secondFile": {
        "name": "ext/fts3/tool/fts3view.c",
        "start": 140,
        "end": 151,
        "startLoc": {
          "line": 140,
          "column": 2,
          "position": 997
        },
        "endLoc": {
          "line": 151,
          "column": 3,
          "position": 1089
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "    nAlloc = nNew;\n      }\n      nOut += putFts3Varint((char*)&aOut[nOut], iVal);\n    }else{\n      int nVal = 0;\n      char *zVal = Tcl_GetStringFromObj(aArg[i], &nVal);\n      while( (nOut + nVal)>nAlloc ){\n        int nNew = nAlloc?nAlloc*2:128;\n        unsigned c",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_hexio.c",
        "start": 422,
        "end": 432,
        "startLoc": {
          "line": 422,
          "column": 2,
          "position": 3903
        },
        "endLoc": {
          "line": 432,
          "column": 7,
          "position": 3991
        }
      },
      "secondFile": {
        "name": "src/test_hexio.c",
        "start": 408,
        "end": 418,
        "startLoc": {
          "line": 408,
          "column": 3,
          "position": 3746
        },
        "endLoc": {
          "line": 418,
          "column": 5,
          "position": 3834
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "    },\n     { \"utf8_to_utf8\",                 utf8_to_utf8          },\n     { \"read_fts3varint\",              read_fts3varint       },\n     { \"make_fts3record\",          ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_hexio.c",
        "start": 458,
        "end": 465,
        "startLoc": {
          "line": 458,
          "column": 8,
          "position": 4186
        },
        "endLoc": {
          "line": 465,
          "column": 2,
          "position": 4266
        }
      },
      "secondFile": {
        "name": "ext/rbu/test_rbu.c",
        "start": 374,
        "end": 381,
        "startLoc": {
          "line": 374,
          "column": 2,
          "position": 3062
        },
        "endLoc": {
          "line": 381,
          "column": 2,
          "position": 3142
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "\n  sqlite3_context *pCtx, \n  int nArg,\n  sqlite3_value **argv\n){\n  char *zVal;\n  int len;\n  \n  test_destructor_count_var++;\n  assert( nArg==1 );\n  if( sqlite3_value_ty",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_func.c",
        "start": 133,
        "end": 141,
        "startLoc": {
          "line": 133,
          "column": 22,
          "position": 821
        },
        "endLoc": {
          "line": 141,
          "column": 21,
          "position": 900
        }
      },
      "secondFile": {
        "name": "src/test_func.c",
        "start": 110,
        "end": 118,
        "startLoc": {
          "line": 110,
          "column": 20,
          "position": 622
        },
        "endLoc": {
          "line": 118,
          "column": 19,
          "position": 701
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "tes(argv[0]);\n  zIn = (const char*)sqlite3_value_text(argv[0]);\n  zOut = sqlite3_malloc( n/2 );\n  if( zOut==0 ){\n    sqlite3_result_error_nomem(pCtx);\n  }else{\n    testHexToBin(zIn, zOut);\n    sqlite3_result_text16be(pCtx, zOut, n/2, sqlite3_free);\n  }\n}\n#endif\n\n/*\n**      hex_to_utf8(HEX)\n**\n** Convert the input string from HEX into binary.  Then return the\n**",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_func.c",
        "start": 381,
        "end": 397,
        "startLoc": {
          "line": 381,
          "column": 14,
          "position": 2463
        },
        "endLoc": {
          "line": 397,
          "column": 20,
          "position": 2605
        }
      },
      "secondFile": {
        "name": "src/test_func.c",
        "start": 354,
        "end": 370,
        "startLoc": {
          "line": 354,
          "column": 17,
          "position": 2290
        },
        "endLoc": {
          "line": 370,
          "column": 24,
          "position": 2432
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "e_bytes(argv[0]);\n  zIn = (const char*)sqlite3_value_text(argv[0]);\n  zOut = sqlite3_malloc( n/2 );\n  if( zOut==0 ){\n    sqlite3_result_error_nomem(pCtx);\n  }else{\n    testHexToBin(zIn, zOut);\n    sqlite3_result_text(pCtx, zOut, n/2, sqlite3_free);\n  }\n}\n\n/*\n**      hex_to_utf16le(HEX)\n**\n** Convert the input string from HEX into binary.  Then return the\n** result ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_func.c",
        "start": 408,
        "end": 424,
        "startLoc": {
          "line": 408,
          "column": 17,
          "position": 2636
        },
        "endLoc": {
          "line": 424,
          "column": 24,
          "position": 2778
        }
      },
      "secondFile": {
        "name": "src/test_func.c",
        "start": 354,
        "end": 370,
        "startLoc": {
          "line": 354,
          "column": 17,
          "position": 2290
        },
        "endLoc": {
          "line": 370,
          "column": 24,
          "position": 2432
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "ent point in record header */\n  u8 *pBody;                      /* Current point in record data */\n  u64 nHdr;                       /* Bytes in record header */\n  Tcl_Obj *pRet;                  /* Return value */\n\n  pRet = Tcl_New",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_func.c",
        "start": 543,
        "end": 552,
        "startLoc": {
          "line": 543,
          "column": 5,
          "position": 3661
        },
        "endLoc": {
          "line": 552,
          "column": 7,
          "position": 3753
        }
      },
      "secondFile": {
        "name": "src/test_func.c",
        "start": 495,
        "end": 504,
        "startLoc": {
          "line": 495,
          "column": 5,
          "position": 3313
        },
        "endLoc": {
          "line": 504,
          "column": 3,
          "position": 3405
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "  return TCL_OK;\n}\n\n\n/*\n** Register commands with the TCL interpreter.\n*/\nint Sqlitetest_func_Init(Tcl_Interp *interp){\n  static struct {\n     char *zName;\n  ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_func.c",
        "start": 943,
        "end": 948,
        "startLoc": {
          "line": 943,
          "column": 2,
          "position": 6690
        },
        "endLoc": {
          "line": 948,
          "column": 19,
          "position": 6755
        }
      },
      "secondFile": {
        "name": "ext/rbu/test_rbu.c",
        "start": 376,
        "end": 380,
        "startLoc": {
          "line": 376,
          "column": 2,
          "position": 3073
        },
        "endLoc": {
          "line": 380,
          "column": 7,
          "position": 3137
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "xUpdate */\n  0,                              /* xBegin */\n  0,                              /* xSync */\n  0,                              /* xCommit */\n  0,                              /* xRollback */\n  0,                              /* xFindMethod */\n  0,                              /* xRename */\n};\n\n/*\n** Decode a pointer to an sqlite3 object.\n*/\nextern int getDbPointer(Tcl_Interp *",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_fs.c",
        "start": 877,
        "end": 888,
        "startLoc": {
          "line": 877,
          "column": 3,
          "position": 5458
        },
        "endLoc": {
          "line": 888,
          "column": 5,
          "position": 5568
        }
      },
      "secondFile": {
        "name": "src/test_schema.c",
        "start": 309,
        "end": 514,
        "startLoc": {
          "line": 309,
          "column": 3,
          "position": 1780
        },
        "endLoc": {
          "line": 514,
          "column": 9,
          "position": 3620
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "\n    Tcl_WrongNumArgs(interp, 1, objv, \"DB\");\n    return TCL_ERROR;\n  }\n  if( getDbPointer(interp, Tcl_GetString(objv[1]), &db) ) return TCL_ERROR;\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3_create_module",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_fs.c",
        "start": 908,
        "end": 917,
        "startLoc": {
          "line": 908,
          "column": 19,
          "position": 5691
        },
        "endLoc": {
          "line": 917,
          "column": 2,
          "position": 5783
        }
      },
      "secondFile": {
        "name": "src/test_tclvar.c",
        "start": 553,
        "end": 562,
        "startLoc": {
          "line": 553,
          "column": 23,
          "position": 3780
        },
        "endLoc": {
          "line": 562,
          "column": 2,
          "position": 3872
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "symUnlock,                     /* xUnlock */\n  devsymCheckReservedLock,          /* xCheckReservedLock */\n  devsymFileControl,                /* xFileControl */\n  writecrashSectorSize,             /* xSectorSize */\n  writecrashDeviceCharacteristics,  /* xDeviceCharacteristics */\n  devsymShmMap,                     /* xShmMap */\n  devsymShmLock,                    /* xShmLock */\n  devsymShmBarrier,                 /* xShmBarrier */\n  devsymShmUnmap                ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_devsym.c",
        "start": 404,
        "end": 416,
        "startLoc": {
          "line": 404,
          "column": 32,
          "position": 2638
        },
        "endLoc": {
          "line": 416,
          "column": 22,
          "position": 2758
        }
      },
      "secondFile": {
        "name": "src/test_devsym.c",
        "start": 240,
        "end": 252,
        "startLoc": {
          "line": 240,
          "column": 28,
          "position": 1677
        },
        "endLoc": {
          "line": 252,
          "column": 18,
          "position": 1797
        }
      }
    },
    {
      "format": "c",
      "lines": 28,
      "fragment": "c sqlite3_vfs writecrash_vfs = {\n  2,                     /* iVersion */\n  sizeof(devsym_file),      /* szOsFile */\n  DEVSYM_MAX_PATHNAME,      /* mxPathname */\n  0,                     /* pNext */\n  WRITECRASH_NAME,          /* zName */\n  0,                     /* pAppData */\n  writecrashOpen,           /* xOpen */\n  devsymDelete,             /* xDelete */\n  devsymAccess,             /* xAccess */\n  devsymFullPathname,       /* xFullPathname */\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n  devsymDlOpen,             /* xDlOpen */\n  devsymDlError,            /* xDlError */\n  devsymDlSym,              /* xDlSym */\n  devsymDlClose,            /* xDlClose */\n#else\n  0,                        /* xDlOpen */\n  0,                        /* xDlError */\n  0,                        /* xDlSym */\n  0,                        /* xDlClose */\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n  devsymRandomness,         /* xRandomness */\n  devsymSleep,              /* xSleep */\n  dev",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_devsym.c",
        "start": 457,
        "end": 484,
        "startLoc": {
          "line": 457,
          "column": 15,
          "position": 2982
        },
        "endLoc": {
          "line": 484,
          "column": 3,
          "position": 3090
        }
      },
      "secondFile": {
        "name": "src/test_devsym.c",
        "start": 428,
        "end": 450,
        "startLoc": {
          "line": 428,
          "column": 11,
          "position": 2824
        },
        "endLoc": {
          "line": 450,
          "column": 7,
          "position": 2931
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": ";\n  }else{\n    g.iDeviceChar = 0;\n  }\n  if( iSectorSize>=0 ){\n    g.iSectorSize = iSectorSize;\n  }else{\n    g.iSectorSize = 512;\n  }\n}\n\nvoid devsym_unregister(){\n  sqlite3_vfs_unregister(&devsym_vfs);\n  sqlite3_vfs_unregister(&writecrash_vfs);\n ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_devsym.c",
        "start": 514,
        "end": 522,
        "startLoc": {
          "line": 514,
          "column": 7,
          "position": 3333
        },
        "endLoc": {
          "line": 522,
          "column": 2,
          "position": 3418
        }
      },
      "secondFile": {
        "name": "src/test_devsym.c",
        "start": 485,
        "end": 494,
        "startLoc": {
          "line": 485,
          "column": 12,
          "position": 3104
        },
        "endLoc": {
          "line": 494,
          "column": 3,
          "position": 3190
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "se\",           test_blob_close       },\n     { \"sqlite3_blob_bytes\",           test_blob_bytes       },\n     { \"sqlite3_blob_read\",            test_blob_read        },\n     { \"sq",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_blob.c",
        "start": 322,
        "end": 328,
        "startLoc": {
          "line": 322,
          "column": 8,
          "position": 2102
        },
        "endLoc": {
          "line": 328,
          "column": 27,
          "position": 2176
        }
      },
      "secondFile": {
        "name": "ext/rbu/test_rbu.c",
        "start": 374,
        "end": 380,
        "startLoc": {
          "line": 374,
          "column": 2,
          "position": 3062
        },
        "endLoc": {
          "line": 380,
          "column": 7,
          "position": 3137
        }
      }
    },
    {
      "format": "c",
      "lines": 33,
      "fragment": " */\n  if( q=='[' || q=='\\'' || q=='\"' || q=='`' ){\n    int iIn = 1;\n    int iOut = 0;\n    if( q=='[' ) q = ']';  \n\n    while( ALWAYS(z[iIn]) ){\n      if( z[iIn]==q ){\n        if( z[iIn+1]!=q ){\n          /* Character iIn was the close quote. */\n          iIn++;\n          break;\n        }else{\n          /* Character iIn and iIn+1 form an escaped quote character. Skip\n          ** the input cursor past both and copy a single quote character \n          ** to the output buffer. */\n          iIn += 2;\n          z[iOut++] = q;\n        }\n      }else{\n        z[iOut++] = z[iIn++];\n      }\n    }\n\n    z[iOut] = '\\0';\n  }\n}\n\n/*\n** This function is the implementation of both the xConnect and xCreate\n** methods of the fs virtual table.\n**\n** The argv[] array contains the following:\n**\n**   arg",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_bestindex.c",
        "start": 135,
        "end": 167,
        "startLoc": {
          "line": 135,
          "column": 2,
          "position": 214
        },
        "endLoc": {
          "line": 167,
          "column": 3,
          "position": 336
        }
      },
      "secondFile": {
        "name": "ext/fts5/fts5_test_tok.c",
        "start": 89,
        "end": 122,
        "startLoc": {
          "line": 89,
          "column": 2,
          "position": 268
        },
        "endLoc": {
          "line": 122,
          "column": 3,
          "position": 390
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "d)\n    **   \"idxstr\"           (value of idxStr field)\n    **   \"omit\"             (index of omitted constraint in aConstraint[])\n    */\n    Tcl_Obj *pRes = Tcl_GetObjResult(interp);\n    Tcl_Obj **apElem = 0;\n    int nElem;\n    rc = Tcl_ListObjGetElements(interp, pRes, &nElem, &apElem);\n    if( rc!=TCL_OK ){\n      const ch",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_bestindex.c",
        "start": 483,
        "end": 492,
        "startLoc": {
          "line": 483,
          "column": 5,
          "position": 3151
        },
        "endLoc": {
          "line": 492,
          "column": 4,
          "position": 3263
        }
      },
      "secondFile": {
        "name": "src/test_bestindex.c",
        "start": 323,
        "end": 332,
        "startLoc": {
          "line": 323,
          "column": 5,
          "position": 1678
        },
        "endLoc": {
          "line": 332,
          "column": 4,
          "position": 1790
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "terp *interp, const char *zA, sqlite3 **ppDb);\n\n/*\n** Register the echo virtual table module.\n*/\nstatic int SQLITE_TCLAPI register_tcl_module(\n  ClientData clientData, /* Pointer to sqlite3_enable_XXX function */\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int objc,              /* Number of arguments */\n  Tcl_Obj *CONST objv[]  /* Command arguments */\n){\n  sqlite3 *db;\n  if( objc!=2 ){\n    Tcl_WrongNumArgs(interp, 1, objv, \"D",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_bestindex.c",
        "start": 580,
        "end": 593,
        "startLoc": {
          "line": 580,
          "column": 20,
          "position": 4036
        },
        "endLoc": {
          "line": 593,
          "column": 6,
          "position": 4157
        }
      },
      "secondFile": {
        "name": "src/test_fs.c",
        "start": 875,
        "end": 514,
        "startLoc": {
          "line": 875,
          "column": 19,
          "position": 5447
        },
        "endLoc": {
          "line": 514,
          "column": 9,
          "position": 3620
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "l_Init(Tcl_Interp *interp){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  static struct {\n     char *zName;\n     Tcl_ObjCmdProc *xProc;\n     void *clientData;\n  } aObjCmd[] = {\n     { \"register_tcl_module\",   regist",
      "tokens": 0,
      "firstFile": {
        "name": "src/test_bestindex.c",
        "start": 611,
        "end": 620,
        "startLoc": {
          "line": 611,
          "column": 20,
          "position": 4246
        },
        "endLoc": {
          "line": 620,
          "column": 2,
          "position": 4338
        }
      },
      "secondFile": {
        "name": "src/test_tclvar.c",
        "start": 553,
        "end": 562,
        "startLoc": {
          "line": 553,
          "column": 23,
          "position": 3780
        },
        "endLoc": {
          "line": 562,
          "column": 2,
          "position": 3872
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "    void *clientData;\n  } aObjCmd[] = {\n     { \"c_misuse_test\",    c_misuse_test, 0 },\n     { \"c_realloc_test\",   c_realloc_test, 0 },\n     { \"c_collation_test\", c_collation_test, 0 },\n  };\n  int i;\n  fo",
      "tokens": 0,
      "firstFile": {
        "name": "src/test9.c",
        "start": 196,
        "end": 204,
        "startLoc": {
          "line": 196,
          "column": 17,
          "position": 1174
        },
        "endLoc": {
          "line": 204,
          "column": 2,
          "position": 1265
        }
      },
      "secondFile": {
        "name": "src/test_tclvar.c",
        "start": 553,
        "end": 562,
        "startLoc": {
          "line": 553,
          "column": 23,
          "position": 3780
        },
        "endLoc": {
          "line": 562,
          "column": 2,
          "position": 3872
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "(p);\n  p->xOp = 0;\n  p->opnum++;\n  client_wait(p);\n  sqlite3_free(p->zArg);\n  p->zArg = 0;\n  sqlite3_free(p->zFilename);\n  p->zFilename = 0;\n  p->busy = 0;\n}\n\n/*\n** Usage:  client_halt ID\n**\n** Cause a client thread to shut itself down.  Wait for the shutdown to be\n** completed.  If ID is \"*\" then stop all client threads.\n*/\nstatic int SQLITE_T",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 252,
        "end": 265,
        "startLoc": {
          "line": 252,
          "column": 16,
          "position": 1559
        },
        "endLoc": {
          "line": 265,
          "column": 3,
          "position": 1650
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 208,
        "end": 221,
        "startLoc": {
          "line": 208,
          "column": 16,
          "position": 1274
        },
        "endLoc": {
          "line": 221,
          "column": 2,
          "position": 1365
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "he most recent client_step to complete, then return the\n** number of columns in the result set.\n*/\nstatic int SQLITE_TCLAPI tcl_client_argc(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  ch",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 307,
        "end": 321,
        "startLoc": {
          "line": 307,
          "column": 2,
          "position": 2000
        },
        "endLoc": {
          "line": 321,
          "column": 17,
          "position": 2127
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 214,
        "end": 228,
        "startLoc": {
          "line": 214,
          "column": 2,
          "position": 1318
        },
        "endLoc": {
          "line": 228,
          "column": 7,
          "position": 1445
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "t.\n*/\nstatic int SQLITE_TCLAPI tcl_client_argv(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **arg",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 343,
        "end": 352,
        "startLoc": {
          "line": 343,
          "column": 8,
          "position": 2262
        },
        "endLoc": {
          "line": 352,
          "column": 3,
          "position": 2347
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 218,
        "end": 227,
        "startLoc": {
          "line": 218,
          "column": 6,
          "position": 1349
        },
        "endLoc": {
          "line": 227,
          "column": 12,
          "position": 1434
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": "c ){\n    Tcl_AppendResult(interp, \"column number out of range\", 0);\n    return TCL_ERROR;\n  }\n  Tcl_AppendResult(interp, threadset[i].argv[n], 0);\n  return TCL_OK;\n}\n\n/*\n** Usage: client_colname  ID   N\n**\n** Wait on the most recent client_step to complete, then return the\n** name of the N-th columns in the result set.\n*/\nstatic int SQLITE_TCLAPI tcl_client_colname(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  int n;\n\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID N\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_client_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERR",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 368,
        "end": 394,
        "startLoc": {
          "line": 368,
          "column": 19,
          "position": 2466
        },
        "endLoc": {
          "line": 394,
          "column": 5,
          "position": 2723
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 332,
        "end": 358,
        "startLoc": {
          "line": 332,
          "column": 16,
          "position": 2181
        },
        "endLoc": {
          "line": 358,
          "column": 5,
          "position": 2438
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "the most recent operation to complete, then return the\n** result code from that operation.\n*/\nstatic int SQLITE_TCLAPI tcl_client_result(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 413,
        "end": 427,
        "startLoc": {
          "line": 413,
          "column": 6,
          "position": 2818
        },
        "endLoc": {
          "line": 427,
          "column": 6,
          "position": 2945
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 214,
        "end": 228,
        "startLoc": {
          "line": 214,
          "column": 2,
          "position": 1318
        },
        "endLoc": {
          "line": 228,
          "column": 7,
          "position": 1445
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "   Tcl_AppendResult(interp, \"no such thread\", 0);\n    return TCL_ERROR;\n  }\n  client_wait(&threadset[i]);\n  zName = sqlite3ErrName(threadset[i].rc);\n  Tcl_AppendResult(interp, zName, 0);\n  return TCL_OK;\n}\n\n/*\n** Usage: client_error  ID\n**\n** Wait on the most recent operation to complete, then return the\n** error string.\n*/\nstatic int SQLITE_TCLAPI tcl_client_error(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument *",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 438,
        "end": 458,
        "startLoc": {
          "line": 438,
          "column": 17,
          "position": 2991
        },
        "endLoc": {
          "line": 458,
          "column": 17,
          "position": 3162
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 208,
        "end": 228,
        "startLoc": {
          "line": 208,
          "column": 16,
          "position": 1274
        },
        "endLoc": {
          "line": 228,
          "column": 7,
          "position": 1445
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "achine.\n*/\nstatic int SQLITE_TCLAPI tcl_client_compile(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argume",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 492,
        "end": 502,
        "startLoc": {
          "line": 492,
          "column": 10,
          "position": 3401
        },
        "endLoc": {
          "line": 502,
          "column": 10,
          "position": 3497
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 218,
        "end": 228,
        "startLoc": {
          "line": 218,
          "column": 6,
          "position": 1349
        },
        "endLoc": {
          "line": 228,
          "column": 7,
          "position": 1445
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "e by one step\n*/\nstatic int SQLITE_TCLAPI tcl_client_step(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 545,
        "end": 555,
        "startLoc": {
          "line": 545,
          "column": 7,
          "position": 3856
        },
        "endLoc": {
          "line": 555,
          "column": 8,
          "position": 3961
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 218,
        "end": 502,
        "startLoc": {
          "line": 218,
          "column": 6,
          "position": 1349
        },
        "endLoc": {
          "line": 502,
          "column": 11,
          "position": 3506
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "lize a virtual machine.\n*/\nstatic void do_finalize(Thread *p){\n  if( p->pStmt==0 ){\n    p->zErr = p->zStaticErr = \"no virtual machine available\";\n    p->rc = SQLITE_ERROR;\n    return;\n  }\n  p->rc = sqlite3_client_finalize(p->pStmt);\n  p->pStmt = 0;\n}\n\n/*\n** Usage: client_finalize ID\n**\n** Finalize the virtual machine.\n*/\nstatic int SQLITE_TCLAPI tcl_client_finalize(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 578,
        "end": 597,
        "startLoc": {
          "line": 578,
          "column": 20,
          "position": 4081
        },
        "endLoc": {
          "line": 597,
          "column": 12,
          "position": 4260
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 536,
        "end": 502,
        "startLoc": {
          "line": 536,
          "column": 16,
          "position": 3782
        },
        "endLoc": {
          "line": 502,
          "column": 11,
          "position": 3506
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": " thread to reset a virtual machine.\n*/\nstatic void do_reset(Thread *p){\n  if( p->pStmt==0 ){\n    p->zErr = p->zStaticErr = \"no virtual machine available\";\n    p->rc = SQLITE_ERROR;\n    return;\n  }\n  p->rc = sqlite3_client_reset(p->pStmt);\n  p->pStmt = 0;\n}\n\n/*\n** Usage: client_reset ID\n**\n** Finalize the virtual machine.\n*/\nstatic int SQLITE_TCLAPI tcl_client_reset(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 622,
        "end": 641,
        "startLoc": {
          "line": 622,
          "column": 17,
          "position": 4405
        },
        "endLoc": {
          "line": 641,
          "column": 9,
          "position": 4584
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 536,
        "end": 502,
        "startLoc": {
          "line": 536,
          "column": 16,
          "position": 3782
        },
        "endLoc": {
          "line": 502,
          "column": 11,
          "position": 3506
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "int SQLITE_TCLAPI tcl_client_swap(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  in",
      "tokens": 0,
      "firstFile": {
        "name": "src/test7.c",
        "start": 663,
        "end": 673,
        "startLoc": {
          "line": 663,
          "column": 11,
          "position": 4724
        },
        "endLoc": {
          "line": 673,
          "column": 2,
          "position": 4820
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 218,
        "end": 228,
        "startLoc": {
          "line": 218,
          "column": 6,
          "position": 1349
        },
        "endLoc": {
          "line": 228,
          "column": 7,
          "position": 1445
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "erhead\",     (Tcl_ObjCmdProc*)test_value_overhead },\n    { \"test_translate\",          (Tcl_ObjCmdProc*)test_translate     },\n    { \"translate_selfte",
      "tokens": 0,
      "firstFile": {
        "name": "src/test5.c",
        "start": 213,
        "end": 219,
        "startLoc": {
          "line": 213,
          "column": 24,
          "position": 1332
        },
        "endLoc": {
          "line": 219,
          "column": 7,
          "position": 1407
        }
      },
      "secondFile": {
        "name": "src/test_mutex.c",
        "start": 498,
        "end": 505,
        "startLoc": {
          "line": 498,
          "column": 2,
          "position": 3377
        },
        "endLoc": {
          "line": 505,
          "column": 12,
          "position": 3453
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "       /* argument usable by xOp */\n  int opnum;             /* Operation number */\n  int busy;              /* True if this thread is in use */\n\n  /* The next group of fields are writable by the thread but read-only to the\n  ** leader. */\n  int completed;        /* Number of operations completed */\n  sqlite3 *db;           /* Open database */\n  sqlite3_stmt *pStmt;     /* Pending operation */\n  char *zErr;           /* operation error */\n  char *zStaticErr;    ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 45,
        "end": 54,
        "startLoc": {
          "line": 45,
          "column": 3,
          "position": 103
        },
        "endLoc": {
          "line": 54,
          "column": 2,
          "position": 190
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 66,
        "end": 80,
        "startLoc": {
          "line": 66,
          "column": 2,
          "position": 209
        },
        "endLoc": {
          "line": 80,
          "column": 5,
          "position": 298
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "\nstatic void *test_thread_main(void *pArg){\n  Thread *p = (Thread*)pArg;\n  if( p->db ){\n    sqlite3_close(p->db);\n  }\n  sqlite3_open(p->zFilename, &p->db);\n  if( SQLITE_OK!=sqlite3_errcode(p->db) ){\n    p->zErr = strdup(sqlite3_errmsg(p->db));\n    sqlite3_close(p->db);\n    p->db = 0;\n  }\n  p->pStmt = 0;\n  p->completed = 1;\n  while( p->opnum<=p->completed ) sch",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 75,
        "end": 91,
        "startLoc": {
          "line": 75,
          "column": 14,
          "position": 314
        },
        "endLoc": {
          "line": 91,
          "column": 17,
          "position": 480
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 102,
        "end": 118,
        "startLoc": {
          "line": 102,
          "column": 21,
          "position": 431
        },
        "endLoc": {
          "line": 118,
          "column": 24,
          "position": 597
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "ticErr ){\n      sqlite3_free(p->zErr);\n      p->zErr = 0;\n    }\n    (*p->xOp)(p);\n    p->completed++;\n    while( p->opnum<=p->completed ) sched_yield();\n  }\n  if( p->pStmt ){\n    sqlite3_finalize(p->pStmt);\n    p->pStmt = 0;\n  }\n  if( p->db ){\n    sqlite3_close(p->db);\n    p->db = 0;\n  }\n  if( p->zErr && p->zErr!=p->zStaticErr ){\n    sqlite3_free(p->zErr);\n    p->zErr = 0;\n  }\n  p->",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 95,
        "end": 114,
        "startLoc": {
          "line": 95,
          "column": 14,
          "position": 514
        },
        "endLoc": {
          "line": 114,
          "column": 16,
          "position": 607
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 122,
        "end": 141,
        "startLoc": {
          "line": 122,
          "column": 21,
          "position": 631
        },
        "endLoc": {
          "line": 141,
          "column": 16,
          "position": 724
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "completed++;\n#ifndef SQLITE_OMIT_DEPRECATED\n  sqlite3_thread_cleanup();\n#endif\n  return 0;\n}\n\n/*\n** Get a thread ID which is an upper case letter.  Return the index.\n** If the argument is not a valid thread ID put an error message in\n** the interpreter and return -1.\n*/\nstatic int parse_thread_id(Tcl_Interp *interp, const char *zArg){\n  if( zArg==0 || zArg[0]==0 || zArg[1]!=0 || !isupper((unsigned char)zA",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 114,
        "end": 127,
        "startLoc": {
          "line": 114,
          "column": 16,
          "position": 608
        },
        "endLoc": {
          "line": 127,
          "column": 3,
          "position": 708
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 141,
        "end": 154,
        "startLoc": {
          "line": 141,
          "column": 16,
          "position": 725
        },
        "endLoc": {
          "line": 154,
          "column": 3,
          "position": 825
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "ead ID must be an upper case letter\", 0);\n    return -1;\n  }\n  return zArg[0] - 'A';\n}\n\n/*\n** Usage:    thread_create NAME  FILENAME\n**\n** NAME should be an upper case letter.  Start the thread running with\n** an open connection to the given database.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_create(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  in",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 128,
        "end": 143,
        "startLoc": {
          "line": 128,
          "column": 18,
          "position": 717
        },
        "endLoc": {
          "line": 143,
          "column": 16,
          "position": 824
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 155,
        "end": 170,
        "startLoc": {
          "line": 155,
          "column": 18,
          "position": 834
        },
        "endLoc": {
          "line": 170,
          "column": 16,
          "position": 941
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "t argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  pthread_t x;\n  int rc;\n\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID FILENAME\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( threadset[i].busy ){\n    Tcl_AppendResult(interp, \"",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 143,
        "end": 154,
        "startLoc": {
          "line": 143,
          "column": 16,
          "position": 825
        },
        "endLoc": {
          "line": 154,
          "column": 17,
          "position": 983
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 170,
        "end": 181,
        "startLoc": {
          "line": 170,
          "column": 16,
          "position": 942
        },
        "endLoc": {
          "line": 181,
          "column": 12,
          "position": 1100
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "thread \", argv[1], \" is already running\", 0);\n    return TCL_ERROR;\n  }\n  threadset[i].busy = 1;\n  sqlite3_free(threadset[i].zFilename);\n  threadset[i].zFilename = sqlite3_mprintf(\"%s\", argv[2]);\n  threadset[i].opnum =",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 154,
        "end": 162,
        "startLoc": {
          "line": 154,
          "column": 17,
          "position": 984
        },
        "endLoc": {
          "line": 162,
          "column": 7,
          "position": 1058
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 181,
        "end": 189,
        "startLoc": {
          "line": 181,
          "column": 12,
          "position": 1101
        },
        "endLoc": {
          "line": 189,
          "column": 3,
          "position": 1175
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "_detach(x);\n  return TCL_OK;\n}\n\n/*\n** Wait for a thread to reach its idle state.\n*/\nstatic void test_thread_wait(Thread *p){\n  while( p->opnum>p->completed ) sched_yield();\n}\n\n/*\n** Usage:  thread_wait ID\n**\n** Wait on thread ID to reach its idle state.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_wait(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 177,
        "end": 190,
        "startLoc": {
          "line": 177,
          "column": 16,
          "position": 1112
        },
        "endLoc": {
          "line": 190,
          "column": 16,
          "position": 1207
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 208,
        "end": 221,
        "startLoc": {
          "line": 208,
          "column": 16,
          "position": 1274
        },
        "endLoc": {
          "line": 221,
          "column": 16,
          "position": 1369
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "ite3_free(p->zArg);\n  p->zArg = 0;\n  sqlite3_free(p->zFilename);\n  p->zFilename = 0;\n  p->busy = 0;\n}\n\n/*\n** Usage:  thread_halt ID\n**\n** Cause a thread to shut itself down.  Wait for the shutdown to be\n** completed.  If ID is \"*\" then stop all threads.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_halt(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **ar",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 221,
        "end": 236,
        "startLoc": {
          "line": 221,
          "column": 16,
          "position": 1397
        },
        "endLoc": {
          "line": 236,
          "column": 17,
          "position": 1547
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 208,
        "end": 267,
        "startLoc": {
          "line": 208,
          "column": 16,
          "position": 1274
        },
        "endLoc": {
          "line": 267,
          "column": 2,
          "position": 1708
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": " \"no such thread\", 0);\n      return TCL_ERROR;\n    }\n    test_stop_thread(&threadset[i]);\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_argc  ID\n**\n** Wait on the most recent thread_step to complete, then return the\n** number of columns in the result set.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_argc(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 256,
        "end": 270,
        "startLoc": {
          "line": 256,
          "column": 16,
          "position": 1666
        },
        "endLoc": {
          "line": 270,
          "column": 16,
          "position": 1770
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 300,
        "end": 314,
        "startLoc": {
          "line": 300,
          "column": 16,
          "position": 1947
        },
        "endLoc": {
          "line": 314,
          "column": 16,
          "position": 2051
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "olumns in the result set.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_argc(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  char zBuf[100];\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args:",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 263,
        "end": 277,
        "startLoc": {
          "line": 263,
          "column": 2,
          "position": 1719
        },
        "endLoc": {
          "line": 277,
          "column": 17,
          "position": 1846
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 183,
        "end": 197,
        "startLoc": {
          "line": 183,
          "column": 2,
          "position": 1156
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "izeof(zBuf), zBuf, \"%d\", threadset[i].argc);\n  Tcl_AppendResult(interp, zBuf, 0);\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_argv  ID   N\n**\n** Wait on the most recent thread_step to complete, then return the\n** value of the N-th columns in the result set.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_argv(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invok",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 288,
        "end": 302,
        "startLoc": {
          "line": 288,
          "column": 16,
          "position": 1900
        },
        "endLoc": {
          "line": 302,
          "column": 16,
          "position": 2001
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 332,
        "end": 346,
        "startLoc": {
          "line": 332,
          "column": 16,
          "position": 2181
        },
        "endLoc": {
          "line": 346,
          "column": 16,
          "position": 2282
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  int n;\n\n  if( argc!=3",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 299,
        "end": 308,
        "startLoc": {
          "line": 299,
          "column": 8,
          "position": 1981
        },
        "endLoc": {
          "line": 308,
          "column": 3,
          "position": 2066
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 187,
        "end": 196,
        "startLoc": {
          "line": 187,
          "column": 6,
          "position": 1187
        },
        "endLoc": {
          "line": 196,
          "column": 17,
          "position": 1272
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "ed this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  int n;\n\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 302,
        "end": 309,
        "startLoc": {
          "line": 302,
          "column": 16,
          "position": 2002
        },
        "endLoc": {
          "line": 309,
          "column": 17,
          "position": 2092
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 346,
        "end": 353,
        "startLoc": {
          "line": 346,
          "column": 16,
          "position": 2283
        },
        "endLoc": {
          "line": 353,
          "column": 12,
          "position": 2373
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "       \" ID N\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( !threadset[i].busy ){\n    Tcl_AppendResult(interp, \"no such thread\", 0);\n    return TCL_ERROR;\n  }\n  if( Tcl_GetInt(interp, argv[2], &n) ) return TCL_ERROR;\n  test_thread_wait(&threadset[i]);\n  if( n<0 || n>=threadset[i].argc ){\n    Tcl_AppendResult(",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 309,
        "end": 323,
        "startLoc": {
          "line": 309,
          "column": 17,
          "position": 2093
        },
        "endLoc": {
          "line": 323,
          "column": 3,
          "position": 2176
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 353,
        "end": 367,
        "startLoc": {
          "line": 353,
          "column": 12,
          "position": 2374
        },
        "endLoc": {
          "line": 367,
          "column": 3,
          "position": 2457
        }
      }
    },
    {
      "format": "c",
      "lines": 27,
      "fragment": "  return TCL_ERROR;\n  }\n  Tcl_AppendResult(interp, threadset[i].argv[n], 0);\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_colname  ID   N\n**\n** Wait on the most recent thread_step to complete, then return the\n** name of the N-th columns in the result set.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_colname(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  int n;\n\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID N\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( !threadset[i].busy ){\n    Tcl_AppendResult(interp, \"no such threa",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 324,
        "end": 350,
        "startLoc": {
          "line": 324,
          "column": 19,
          "position": 2185
        },
        "endLoc": {
          "line": 350,
          "column": 5,
          "position": 2442
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 332,
        "end": 314,
        "startLoc": {
          "line": 332,
          "column": 16,
          "position": 2181
        },
        "endLoc": {
          "line": 314,
          "column": 5,
          "position": 2157
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "       \" ID N\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( !threadset[i].busy ){\n    Tcl_AppendResult(interp, \"no such thread\", 0);\n    return TCL_ERROR;\n  }\n  if( Tcl_GetInt(interp, argv[2], &n) ) return TCL_ERROR;\n  test_thread_wait(&threadset[i]);\n  if( n<0 || n>=threadset[i].argc ){\n   ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 345,
        "end": 359,
        "startLoc": {
          "line": 345,
          "column": 17,
          "position": 2378
        },
        "endLoc": {
          "line": 359,
          "column": 3,
          "position": 2461
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 389,
        "end": 398,
        "startLoc": {
          "line": 389,
          "column": 12,
          "position": 2659
        },
        "endLoc": {
          "line": 398,
          "column": 7,
          "position": 2742
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "t of range\", 0);\n    return TCL_ERROR;\n  }\n  Tcl_AppendResult(interp, threadset[i].colv[n], 0);\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_result  ID\n**\n** Wait on the most recent operation to complete, then return the\n** result code from that operation.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_result(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this co",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 360,
        "end": 374,
        "startLoc": {
          "line": 360,
          "column": 18,
          "position": 2470
        },
        "endLoc": {
          "line": 374,
          "column": 16,
          "position": 2574
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 406,
        "end": 420,
        "startLoc": {
          "line": 406,
          "column": 18,
          "position": 2765
        },
        "endLoc": {
          "line": 420,
          "column": 16,
          "position": 2869
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "from that operation.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_result(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  const char *zName;\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wr",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 367,
        "end": 381,
        "startLoc": {
          "line": 367,
          "column": 6,
          "position": 2523
        },
        "endLoc": {
          "line": 381,
          "column": 6,
          "position": 2650
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 183,
        "end": 197,
        "startLoc": {
          "line": 183,
          "column": 2,
          "position": 1156
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 21,
      "fragment": "\n  test_thread_wait(&threadset[i]);\n  zName = sqlite3ErrName(threadset[i].rc);\n  Tcl_AppendResult(interp, zName, 0);\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_error  ID\n**\n** Wait on the most recent operation to complete, then return the\n** error string.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_error(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args:",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 392,
        "end": 412,
        "startLoc": {
          "line": 392,
          "column": 17,
          "position": 2696
        },
        "endLoc": {
          "line": 412,
          "column": 17,
          "position": 2867
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 208,
        "end": 197,
        "startLoc": {
          "line": 208,
          "column": 16,
          "position": 1274
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( !threadset[i].busy ){\n    Tcl_AppendResult(interp, \"no such thread\", 0);\n    return TCL_ERROR;\n  }\n  test_thread_wait(&threadset[i]);\n  Tcl_AppendResult(interp, thre",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 411,
        "end": 426,
        "startLoc": {
          "line": 411,
          "column": 17,
          "position": 2857
        },
        "endLoc": {
          "line": 426,
          "column": 17,
          "position": 2966
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 457,
        "end": 472,
        "startLoc": {
          "line": 457,
          "column": 12,
          "position": 3152
        },
        "endLoc": {
          "line": 472,
          "column": 24,
          "position": 3261
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "\n    p->rc = SQLITE_ERROR;\n    return;\n  }\n  if( p->pStmt ){\n    sqlite3_finalize(p->pStmt);\n    p->pStmt = 0;\n  }\n  p->rc = sqlite3_prepare(p->db, p->zArg, -1, &p->pStmt, 0);\n}\n\n/*\n** Usage: thread_compile ID SQL\n**\n** Compile a new virtual machine.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_compile(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter th",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 437,
        "end": 449,
        "startLoc": {
          "line": 437,
          "column": 19,
          "position": 3032
        },
        "endLoc": {
          "line": 449,
          "column": 16,
          "position": 3126
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 483,
        "end": 495,
        "startLoc": {
          "line": 483,
          "column": 19,
          "position": 3327
        },
        "endLoc": {
          "line": 495,
          "column": 16,
          "position": 3421
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "d,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # ar",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 446,
        "end": 456,
        "startLoc": {
          "line": 446,
          "column": 10,
          "position": 3106
        },
        "endLoc": {
          "line": 456,
          "column": 10,
          "position": 3202
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 187,
        "end": 197,
        "startLoc": {
          "line": 187,
          "column": 6,
          "position": 1187
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "ndResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID SQL\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( !threadset[i].busy ){\n    Tcl_AppendResult(interp, \"no such thread\", 0);\n    return TCL_ERROR;\n  }\n  test_thread_wait(&threadset[i]);\n  threadset[i].xOp = do_compile;\n  sqlite3_free(threadset[i].zArg);\n  threadset[i].zArg = sqlite3_mprintf(\"%s\", argv[2]);\n  threa",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 455,
        "end": 473,
        "startLoc": {
          "line": 455,
          "column": 17,
          "position": 3192
        },
        "endLoc": {
          "line": 473,
          "column": 13,
          "position": 3341
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 501,
        "end": 519,
        "startLoc": {
          "line": 501,
          "column": 12,
          "position": 3487
        },
        "endLoc": {
          "line": 519,
          "column": 20,
          "position": 3636
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "dset[i].opnum++;\n  return TCL_OK;\n}\n\n/*\n** This procedure runs in the thread to step the virtual machine.\n*/\nstatic void do_step(Thread *p){\n  int i;\n  if( p->pStmt==0 ){\n    p->zErr = p->zStaticErr = \"no virtual machine available\";\n    p->rc = SQLITE_ERROR;\n    return;\n  }\n  p->rc = sqlite3_step(p->pStmt);\n  if( p->rc==SQLITE_ROW ){\n    p->argc = sqlite3_column_count(p->",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 473,
        "end": 489,
        "startLoc": {
          "line": 473,
          "column": 13,
          "position": 3342
        },
        "endLoc": {
          "line": 489,
          "column": 3,
          "position": 3478
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 519,
        "end": 535,
        "startLoc": {
          "line": 519,
          "column": 20,
          "position": 3637
        },
        "endLoc": {
          "line": 535,
          "column": 3,
          "position": 3773
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "(p->pStmt); i++){\n      p->argv[i] = (char*)sqlite3_column_text(p->pStmt, i);\n    }\n    for(i=0; i<p->argc; i++){\n      p->colv[i] = sqlite3_column_name(p->pStmt, i);\n    }\n  }\n}\n\n/*\n** Usage: thread_step ID\n**\n** Advance the virtual machine by one step\n*/\nstatic int SQLITE_TCLAPI tcl_thread_step(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 490,
        "end": 502,
        "startLoc": {
          "line": 490,
          "column": 16,
          "position": 3487
        },
        "endLoc": {
          "line": 502,
          "column": 16,
          "position": 3581
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 536,
        "end": 548,
        "startLoc": {
          "line": 536,
          "column": 16,
          "position": 3782
        },
        "endLoc": {
          "line": 548,
          "column": 16,
          "position": 3876
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "Used,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 499,
        "end": 509,
        "startLoc": {
          "line": 499,
          "column": 7,
          "position": 3561
        },
        "endLoc": {
          "line": 509,
          "column": 8,
          "position": 3666
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 187,
        "end": 456,
        "startLoc": {
          "line": 187,
          "column": 6,
          "position": 1187
        },
        "endLoc": {
          "line": 456,
          "column": 11,
          "position": 3211
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "ppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" IDL\", 0);\n    return TCL_ERROR;\n  }\n  i = parse_thread_id(interp, argv[1]);\n  if( i<0 ) return TCL_ERROR;\n  if( !threadset[i].busy ){\n    Tcl_AppendResult(interp, \"no such thread\", 0);\n    return TCL_ERROR;\n  }\n  test_thread_wait(&threadset[i]);\n  threadset[i].xOp = do_step;\n  thread",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 508,
        "end": 523,
        "startLoc": {
          "line": 508,
          "column": 17,
          "position": 3647
        },
        "endLoc": {
          "line": 523,
          "column": 17,
          "position": 3756
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 554,
        "end": 569,
        "startLoc": {
          "line": 554,
          "column": 12,
          "position": 3942
        },
        "endLoc": {
          "line": 569,
          "column": 24,
          "position": 4051
        }
      }
    },
    {
      "format": "c",
      "lines": 20,
      "fragment": "  if( p->pStmt==0 ){\n    p->zErr = p->zStaticErr = \"no virtual machine available\";\n    p->rc = SQLITE_ERROR;\n    return;\n  }\n  p->rc = sqlite3_finalize(p->pStmt);\n  p->pStmt = 0;\n}\n\n/*\n** Usage: thread_finalize ID\n**\n** Finalize the virtual machine.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_finalize(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\",",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 532,
        "end": 551,
        "startLoc": {
          "line": 532,
          "column": 20,
          "position": 3786
        },
        "endLoc": {
          "line": 551,
          "column": 12,
          "position": 3965
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 536,
        "end": 456,
        "startLoc": {
          "line": 536,
          "column": 16,
          "position": 3782
        },
        "endLoc": {
          "line": 456,
          "column": 11,
          "position": 3211
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "read_wait(&threadset[i]);\n  threadset[i].xOp = do_finalize;\n  sqlite3_free(threadset[i].zArg);\n  threadset[i].zArg = 0;\n  threadset[i].opnum++;\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_swap ID ID\n**\n** Interchange the sqlite* pointer between two threads.\n*/\nstatic int SQLITE_TCLAPI tcl_thread_swap(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this comma",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 563,
        "end": 576,
        "startLoc": {
          "line": 563,
          "column": 16,
          "position": 4021
        },
        "endLoc": {
          "line": 576,
          "column": 16,
          "position": 4125
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 653,
        "end": 666,
        "startLoc": {
          "line": 653,
          "column": 16,
          "position": 4640
        },
        "endLoc": {
          "line": 666,
          "column": 16,
          "position": 4744
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "rp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i, j;\n  sqlite3 *temp;\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wro",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 573,
        "end": 583,
        "startLoc": {
          "line": 573,
          "column": 11,
          "position": 4105
        },
        "endLoc": {
          "line": 583,
          "column": 2,
          "position": 4201
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 187,
        "end": 197,
        "startLoc": {
          "line": 187,
          "column": 6,
          "position": 1187
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "et(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  char zBuf[100];\n  extern int sqlite3TestMakePointerStr(Tcl_Interp*, char*, void*);\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should b",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 611,
        "end": 624,
        "startLoc": {
          "line": 611,
          "column": 2,
          "position": 4415
        },
        "endLoc": {
          "line": 624,
          "column": 26,
          "position": 4541
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 183,
        "end": 197,
        "startLoc": {
          "line": 183,
          "column": 2,
          "position": 1156
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": " arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  extern int sqlite3TestMakePointerStr(Tcl_Interp*, char*, void*);\n  extern void *sqlite3TestTextToPtr(const char *);\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 645,
        "end": 655,
        "startLoc": {
          "line": 645,
          "column": 9,
          "position": 4716
        },
        "endLoc": {
          "line": 655,
          "column": 7,
          "position": 4812
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 187,
        "end": 197,
        "startLoc": {
          "line": 187,
          "column": 6,
          "position": 1187
        },
        "endLoc": {
          "line": 197,
          "column": 7,
          "position": 1283
        }
      }
    },
    {
      "format": "c",
      "lines": 22,
      "fragment": "t( !threadset[i].db );\n  threadset[i].db = (sqlite3*)sqlite3TestTextToPtr(argv[2]);\n  return TCL_OK;\n}\n\n/*\n** Usage: thread_stmt_get ID\n**\n** Return the database stmt pointer for the given thread.  Then\n** remove the pointer from the thread itself. \n*/\nstatic int SQLITE_TCLAPI tcl_thread_stmt_get(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  int i;\n  char zBuf[100];\n  extern int sqlite3TestMakePointerStr(Tcl_Interp*, char*, void*);\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\", 0);",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 666,
        "end": 687,
        "startLoc": {
          "line": 666,
          "column": 20,
          "position": 4867
        },
        "endLoc": {
          "line": 687,
          "column": 6,
          "position": 5079
        }
      },
      "secondFile": {
        "name": "src/test4.c",
        "start": 603,
        "end": 624,
        "startLoc": {
          "line": 603,
          "column": 18,
          "position": 4342
        },
        "endLoc": {
          "line": 624,
          "column": 3,
          "position": 4554
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "dProc*)tcl_thread_finalize   },\n     { \"thread_swap\",       (Tcl_CmdProc*)tcl_thread_swap       },\n     { \"thread_db_get\",     (Tcl_CmdProc*)tcl_thread_db_get     },\n     { \"thre",
      "tokens": 0,
      "firstFile": {
        "name": "src/test4.c",
        "start": 715,
        "end": 725,
        "startLoc": {
          "line": 715,
          "column": 4,
          "position": 5389
        },
        "endLoc": {
          "line": 725,
          "column": 17,
          "position": 5475
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 706,
        "end": 716,
        "startLoc": {
          "line": 706,
          "column": 8,
          "position": 5189
        },
        "endLoc": {
          "line": 716,
          "column": 17,
          "position": 5275
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": ";\n    sDb.pVfs = 0;\n  }\n  return TCL_OK;\n}\n\n\n/*\n** Usage:   btree_begin_transaction ID\n**\n** Start a new transaction\n*/\nstatic int SQLITE_TCLAPI btree_begin_transaction(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Btree *pBt;\n  int rc;\n  if( argc!=2 ){\n    ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test3.c",
        "start": 121,
        "end": 135,
        "startLoc": {
          "line": 121,
          "column": 24,
          "position": 710
        },
        "endLoc": {
          "line": 135,
          "column": 18,
          "position": 821
        }
      },
      "secondFile": {
        "name": "src/test3.c",
        "start": 86,
        "end": 100,
        "startLoc": {
          "line": 86,
          "column": 12,
          "position": 477
        },
        "endLoc": {
          "line": 100,
          "column": 3,
          "position": 588
        }
      }
    },
    {
      "format": "c",
      "lines": 19,
      "fragment": "Buf, 0);\n  return SQLITE_OK;\n}\n\n/*\n** Usage:   btree_first ID\n**\n** Move the cursor to the first entry in the table.  Return 0 if the\n** cursor was left point to something and 1 if the table is empty.\n*/\nstatic int SQLITE_TCLAPI btree_first(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pCur;\n  int rc;\n  int res = 0;\n  char zB",
      "tokens": 0,
      "firstFile": {
        "name": "src/test3.c",
        "start": 330,
        "end": 348,
        "startLoc": {
          "line": 330,
          "column": 12,
          "position": 2186
        },
        "endLoc": {
          "line": 348,
          "column": 18,
          "position": 2330
        }
      },
      "secondFile": {
        "name": "src/test3.c",
        "start": 291,
        "end": 309,
        "startLoc": {
          "line": 291,
          "column": 11,
          "position": 1913
        },
        "endLoc": {
          "line": 309,
          "column": 17,
          "position": 2057
        }
      }
    },
    {
      "format": "c",
      "lines": 16,
      "fragment": "argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID\\\"\", 0);\n    return TCL_ERROR;\n  }\n  pCur = sqlite3TestTextToPtr(argv[1]);\n  sqlite3BtreeEnter(pCur->pBtree);\n  rc = sqlite3BtreeFirst(pCur, &res);\n  sqlite3BtreeLeave(pCur->pBtree);\n  if( rc ){\n    Tcl_AppendResult(interp, sqlite3ErrName(rc), 0);\n    return TCL_ERROR;\n  }\n  sqlite3_snprintf(sizeof(zBu",
      "tokens": 0,
      "firstFile": {
        "name": "src/test3.c",
        "start": 349,
        "end": 364,
        "startLoc": {
          "line": 349,
          "column": 3,
          "position": 2341
        },
        "endLoc": {
          "line": 364,
          "column": 3,
          "position": 2421
        }
      },
      "secondFile": {
        "name": "src/test3.c",
        "start": 314,
        "end": 329,
        "startLoc": {
          "line": 314,
          "column": 3,
          "position": 2097
        },
        "endLoc": {
          "line": 329,
          "column": 3,
          "position": 2177
        }
      }
    },
    {
      "format": "c",
      "lines": 11,
      "fragment": "payload_size(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  BtCursor *pC",
      "tokens": 0,
      "firstFile": {
        "name": "src/test3.c",
        "start": 401,
        "end": 411,
        "startLoc": {
          "line": 401,
          "column": 2,
          "position": 2679
        },
        "endLoc": {
          "line": 411,
          "column": 2,
          "position": 2758
        }
      },
      "secondFile": {
        "name": "src/test3.c",
        "start": 372,
        "end": 382,
        "startLoc": {
          "line": 372,
          "column": 3,
          "position": 2481
        },
        "endLoc": {
          "line": 382,
          "column": 3,
          "position": 2560
        }
      }
    },
    {
      "format": "c",
      "lines": 8,
      "fragment": "     },\n     { \"btree_from_db\",            (Tcl_CmdProc*)btree_from_db            },\n     { \"btree_ismemdb\",            (Tcl_CmdProc*)btree_ismemdb         ",
      "tokens": 0,
      "firstFile": {
        "name": "src/test3.c",
        "start": 680,
        "end": 687,
        "startLoc": {
          "line": 680,
          "column": 3,
          "position": 4904
        },
        "endLoc": {
          "line": 687,
          "column": 21,
          "position": 4977
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 707,
        "end": 713,
        "startLoc": {
          "line": 707,
          "column": 3,
          "position": 5193
        },
        "endLoc": {
          "line": 713,
          "column": 7,
          "position": 5265
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "ite3ErrName(rc), 0);\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage:   pager_rollback ID\n**\n** Rollback changes\n*/\nstatic int SQLITE_TCLAPI pager_rollback(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResu",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 109,
        "end": 123,
        "startLoc": {
          "line": 109,
          "column": 15,
          "position": 554
        },
        "endLoc": {
          "line": 123,
          "column": 21,
          "position": 669
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 82,
        "end": 96,
        "startLoc": {
          "line": 82,
          "column": 12,
          "position": 376
        },
        "endLoc": {
          "line": 96,
          "column": 18,
          "position": 491
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "qlite3ErrName(rc), 0);\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage:   pager_commit ID\n**\n** Commit all changes\n*/\nstatic int SQLITE_TCLAPI pager_commit(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResult(int",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 136,
        "end": 150,
        "startLoc": {
          "line": 136,
          "column": 13,
          "position": 729
        },
        "endLoc": {
          "line": 150,
          "column": 27,
          "position": 844
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 82,
        "end": 96,
        "startLoc": {
          "line": 82,
          "column": 12,
          "position": 376
        },
        "endLoc": {
          "line": 96,
          "column": 18,
          "position": 491
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "(rc), 0);\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage:   pager_stmt_begin ID\n**\n** Start a new checkpoint.\n*/\nstatic int SQLITE_TCLAPI pager_stmt_begin(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResult(in",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 168,
        "end": 182,
        "startLoc": {
          "line": 168,
          "column": 17,
          "position": 957
        },
        "endLoc": {
          "line": 182,
          "column": 26,
          "position": 1072
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 82,
        "end": 96,
        "startLoc": {
          "line": 82,
          "column": 12,
          "position": 376
        },
        "endLoc": {
          "line": 96,
          "column": 18,
          "position": 491
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "eturn TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage:   pager_stmt_rollback ID\n**\n** Rollback changes to a checkpoint\n*/\nstatic int SQLITE_TCLAPI pager_stmt_rollback(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResul",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 195,
        "end": 209,
        "startLoc": {
          "line": 195,
          "column": 20,
          "position": 1135
        },
        "endLoc": {
          "line": 209,
          "column": 22,
          "position": 1250
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 82,
        "end": 96,
        "startLoc": {
          "line": 82,
          "column": 12,
          "position": 376
        },
        "endLoc": {
          "line": 96,
          "column": 18,
          "position": 491
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": "\n    return TCL_ERROR;\n  }\n  return TCL_OK;\n}\n\n/*\n** Usage:   pager_stmt_commit ID\n**\n** Commit changes to a checkpoint\n*/\nstatic int SQLITE_TCLAPI pager_stmt_commit(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  int rc;\n  if( argc!=2 ){\n    Tcl_AppendResult(interp, \"wrong # args: s",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 223,
        "end": 237,
        "startLoc": {
          "line": 223,
          "column": 18,
          "position": 1329
        },
        "endLoc": {
          "line": 237,
          "column": 18,
          "position": 1449
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 82,
        "end": 209,
        "startLoc": {
          "line": 82,
          "column": 12,
          "position": 376
        },
        "endLoc": {
          "line": 209,
          "column": 19,
          "position": 1255
        }
      }
    },
    {
      "format": "c",
      "lines": 9,
      "fragment": "t argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  char zBuf[100];\n  DbPage *pPage;\n  int pgno;\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 355,
        "end": 363,
        "startLoc": {
          "line": 355,
          "column": 5,
          "position": 2310
        },
        "endLoc": {
          "line": 363,
          "column": 6,
          "position": 2396
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 319,
        "end": 327,
        "startLoc": {
          "line": 319,
          "column": 3,
          "position": 2029
        },
        "endLoc": {
          "line": 327,
          "column": 3,
          "position": 2115
        }
      }
    },
    {
      "format": "c",
      "lines": 10,
      "fragment": "L interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  Pager *pPager;\n  int pgno;\n  if( argc!=3 ){\n    Tcl_AppendResult(interp, \"wrong # args: should be \\\"\", argv[0],\n       \" ID PGNO",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 380,
        "end": 389,
        "startLoc": {
          "line": 380,
          "column": 7,
          "position": 2513
        },
        "endLoc": {
          "line": 389,
          "column": 26,
          "position": 2605
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 354,
        "end": 327,
        "startLoc": {
          "line": 354,
          "column": 6,
          "position": 2304
        },
        "endLoc": {
          "line": 327,
          "column": 3,
          "position": 2115
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "l_AppendResult(interp, zBuf, 0);\n  return TCL_OK;\n}\n\n/*\n** Usage:   page_number PAGE\n**\n** Return the page number for a page.\n*/\nstatic int SQLITE_TCLAPI page_number(\n  void *NotUsed,\n  Tcl_Interp *interp,    /* The TCL interpreter that invoked this command */\n  int argc,              /* Number of arguments */\n  const char **argv      /* Text of each argument */\n){\n  char zBuf[10",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 445,
        "end": 458,
        "startLoc": {
          "line": 445,
          "column": 12,
          "position": 2930
        },
        "endLoc": {
          "line": 458,
          "column": 2,
          "position": 3034
        }
      },
      "secondFile": {
        "name": "src/test2.c",
        "start": 421,
        "end": 434,
        "startLoc": {
          "line": 421,
          "column": 10,
          "position": 2767
        },
        "endLoc": {
          "line": 434,
          "column": 21,
          "position": 2871
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "f\n    { \"sqlite3BitvecBuiltinTest\",(Tcl_CmdProc*)testBitvecBuiltinTest     },\n    { \"sqlite3_test_control_pending_byte\",  (Tcl_CmdProc*)testPendingByt",
      "tokens": 0,
      "firstFile": {
        "name": "src/test2.c",
        "start": 729,
        "end": 735,
        "startLoc": {
          "line": 729,
          "column": 2,
          "position": 5321
        },
        "endLoc": {
          "line": 735,
          "column": 12,
          "position": 5396
        }
      },
      "secondFile": {
        "name": "src/test7.c",
        "start": 706,
        "end": 713,
        "startLoc": {
          "line": 706,
          "column": 8,
          "position": 5189
        },
        "endLoc": {
          "line": 713,
          "column": 7,
          "position": 5265
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "e current status value and the high-water\n** mark is adjusted if necessary.\n**\n** The StatusDown() routine lowers the current value by N.  The highwater\n** mark is unchanged.  N must be non-negative for StatusDown().\n*/\nvoid sqlite3StatusUp(int op, int N){\n  wsdS",
      "tokens": 0,
      "firstFile": {
        "name": "src/status.c",
        "start": 89,
        "end": 95,
        "startLoc": {
          "line": 89,
          "column": 2,
          "position": 293
        },
        "endLoc": {
          "line": 95,
          "column": 8,
          "position": 371
        }
      },
      "secondFile": {
        "name": "src/status.c",
        "start": 69,
        "end": 75,
        "startLoc": {
          "line": 69,
          "column": 3,
          "position": 188
        },
        "endLoc": {
          "line": 75,
          "column": 7,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "p] -= N;\n}\n\n/*\n** Adjust the highwater mark if necessary.\n** The caller must hold the appropriate mutex.\n*/\nvoid sqlite3StatusHighwater(int op, int X){\n  sqlite3StatValueType newValue;\n  wsdStatInit;\n  assert( X>=0 );\n  newValue = (sqlite3StatVal",
      "tokens": 0,
      "firstFile": {
        "name": "src/status.c",
        "start": 118,
        "end": 123,
        "startLoc": {
          "line": 118,
          "column": 2,
          "position": 592
        },
        "endLoc": {
          "line": 123,
          "column": 7,
          "position": 665
        }
      },
      "secondFile": {
        "name": "src/status.c",
        "start": 70,
        "end": 75,
        "startLoc": {
          "line": 70,
          "column": 12,
          "position": 193
        },
        "endLoc": {
          "line": 75,
          "column": 7,
          "position": 266
        }
      }
    },
    {
      "format": "c",
      "lines": 15,
      "fragment": " static preexisting mutex.  Six static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_",
      "tokens": 0,
      "firstFile": {
        "name": "src/mutex_unix.c",
        "start": 153,
        "end": 167,
        "startLoc": {
          "line": 153,
          "column": 14,
          "position": 256
        },
        "endLoc": {
          "line": 167,
          "column": 14,
          "position": 351
        }
      },
      "secondFile": {
        "name": "src/mutex_w32.c",
        "start": 99,
        "end": 114,
        "startLoc": {
          "line": 99,
          "column": 23,
          "position": 254
        },
        "endLoc": {
          "line": 114,
          "column": 7,
          "position": 348
        }
      }
    },
    {
      "format": "c",
      "lines": 14,
      "fragment": "iAmt>p->szAlloc\n     && (rc = memdbEnlarge(p, iOfst+iAmt))!=SQLITE_OK\n    ){\n      return rc;\n    }\n    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);\n    p->sz = iOfst+iAmt;\n  }\n  memcpy(p->aData+iOfst, z, iAmt);\n  return SQLITE_OK;\n}\n\n/*\n** Truncate an memdb-file.\n**\n** In rollback mode (which is always the case for memdb, as it does not\n** support WAL ",
      "tokens": 0,
      "firstFile": {
        "name": "src/memdb.c",
        "start": 197,
        "end": 210,
        "startLoc": {
          "line": 197,
          "column": 5,
          "position": 1389
        },
        "endLoc": {
          "line": 210,
          "column": 3,
          "position": 1463
        }
      },
      "secondFile": {
        "name": "ext/misc/memvfs.c",
        "start": 190,
        "end": 199,
        "startLoc": {
          "line": 190,
          "column": 5,
          "position": 1205
        },
        "endLoc": {
          "line": 199,
          "column": 3,
          "position": 1279
        }
      }
    },
    {
      "format": "c",
      "lines": 6,
      "fragment": "){\n  u32 size, hash;\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( i>=1 );\n  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );\n  size = mem3.aPool[i-1].u.hdr.size",
      "tokens": 0,
      "firstFile": {
        "name": "src/mem3.c",
        "start": 205,
        "end": 210,
        "startLoc": {
          "line": 205,
          "column": 2,
          "position": 820
        },
        "endLoc": {
          "line": 210,
          "column": 20,
          "position": 897
        }
      },
      "secondFile": {
        "name": "src/mem3.c",
        "start": 171,
        "end": 176,
        "startLoc": {
          "line": 171,
          "column": 2,
          "position": 494
        },
        "endLoc": {
          "line": 176,
          "column": 22,
          "position": 571
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "freed memory \n** allocations into that log.\n*/\nvoid sqlite3Memsys3Dump(const char *zFilename){\n#ifdef SQLITE_DEBUG\n  FILE *out;\n  u32 i, j;\n  u32 size;\n  if( zFilename==0 || zFilename[0]==0 ){\n    out = stdout;\n  }else{\n    out = fopen(zFilename, \"w\");\n    if( out==0 ){\n",
      "tokens": 0,
      "firstFile": {
        "name": "src/mem3.c",
        "start": 593,
        "end": 604,
        "startLoc": {
          "line": 593,
          "column": 5,
          "position": 4119
        },
        "endLoc": {
          "line": 604,
          "column": 13,
          "position": 4204
        }
      },
      "secondFile": {
        "name": "src/mem5.c",
        "start": 522,
        "end": 534,
        "startLoc": {
          "line": 522,
          "column": 8,
          "position": 2869
        },
        "endLoc": {
          "line": 534,
          "column": 13,
          "position": 2955
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": "  fprintf(out, \"\\n\"); \n  }\n  for(i=0; i<N_HASH; i++){\n    if( mem3.aiHash[i]==0 ) continue;\n    fprintf(out, \"hash(%2d):\", i);\n    for(j = mem3.aiHash[i]; j>0; j=mem3.aPool[j].u.list.",
      "tokens": 0,
      "firstFile": {
        "name": "src/mem3.c",
        "start": 642,
        "end": 648,
        "startLoc": {
          "line": 642,
          "column": 7,
          "position": 4768
        },
        "endLoc": {
          "line": 648,
          "column": 8,
          "position": 4857
        }
      },
      "secondFile": {
        "name": "src/mem3.c",
        "start": 633,
        "end": 639,
        "startLoc": {
          "line": 633,
          "column": 8,
          "position": 4621
        },
        "endLoc": {
          "line": 639,
          "column": 4,
          "position": 4710
        }
      }
    },
    {
      "format": "c",
      "lines": 7,
      "fragment": " p==NULL.\n**\n** This routine is designed for use within an assert() statement, to\n** verify the type of an allocation.  For example:\n**\n**     assert( sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );\n*/\nint sqlite3MemdebugNoType(void *p, u8 eType){\n  int rc = 1;\n  if( ",
      "tokens": 0,
      "firstFile": {
        "name": "src/mem2.c",
        "start": 421,
        "end": 427,
        "startLoc": {
          "line": 421,
          "column": 22,
          "position": 2572
        },
        "endLoc": {
          "line": 427,
          "column": 3,
          "position": 2660
        }
      },
      "secondFile": {
        "name": "src/mem2.c",
        "start": 399,
        "end": 405,
        "startLoc": {
          "line": 399,
          "column": 23,
          "position": 2450
        },
        "endLoc": {
          "line": 405,
          "column": 3,
          "position": 2538
        }
      }
    },
    {
      "format": "c",
      "lines": 13,
      "fragment": "in = pNew;\n  }else{\n    pHead = 0;\n  }\n  if( pHead ){\n    pNew->next = pHead;\n    pNew->prev = pHead->prev;\n    if( pHead->prev ){ pHead->prev->next = pNew; }\n    else             { pH->first = pNew; }\n    pHead->prev = pNew;\n  }else{\n    pNew->next = pH->first;\n    if( pH->first ){ pH->first->prev = pNew; }\n    pN",
      "tokens": 0,
      "firstFile": {
        "name": "src/hash.c",
        "start": 85,
        "end": 97,
        "startLoc": {
          "line": 85,
          "column": 3,
          "position": 422
        },
        "endLoc": {
          "line": 97,
          "column": 2,
          "position": 566
        }
      },
      "secondFile": {
        "name": "ext/fts3/fts3_hash.c",
        "start": 173,
        "end": 185,
        "startLoc": {
          "line": 173,
          "column": 3,
          "position": 970
        },
        "endLoc": {
          "line": 185,
          "column": 7,
          "position": 1115
        }
      }
    },
    {
      "format": "c",
      "lines": 12,
      "fragment": "/\n  HashElem* elem,   /* The element to be removed from the pH */\n  unsigned int h    /* Hash value for the element */\n){\n  struct _ht *pEntry;\n  if( elem->prev ){\n    elem->prev->next = elem->next; \n  }else{\n    pH->first = el",
      "tokens": 0,
      "firstFile": {
        "name": "src/hash.c",
        "start": 185,
        "end": 196,
        "startLoc": {
          "line": 185,
          "column": 2,
          "position": 1209
        },
        "endLoc": {
          "line": 196,
          "column": 3,
          "position": 1302
        }
      },
      "secondFile": {
        "name": "ext/fts1/ft_hash.c",
        "start": 285,
        "end": 262,
        "startLoc": {
          "line": 285,
          "column": 3,
          "position": 2074
        },
        "endLoc": {
          "line": 262,
          "column": 7,
          "position": 1754
        }
      }
    },
    {
      "format": "c",
      "lines": 17,
      "fragment": "han SQLite itself.\n*/\nconst unsigned char sqlite3UpperToLower[] = {\n#ifdef SQLITE_ASCII\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,\n    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,\n    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,\n    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,\n    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,\n    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,\n    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,\n    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,\n    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,\n    234,235,236,237,238,239,240,241,242,243,244,245,246,",
      "tokens": 0,
      "firstFile": {
        "name": "src/global.c",
        "start": 24,
        "end": 40,
        "startLoc": {
          "line": 24,
          "column": 1,
          "position": 6
        },
        "endLoc": {
          "line": 40,
          "column": 2,
          "position": 634
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 133,
        "end": 149,
        "startLoc": {
          "line": 133,
          "column": 2,
          "position": 893
        },
        "endLoc": {
          "line": 149,
          "column": 2,
          "position": 1521
        }
      }
    },
    {
      "format": "c",
      "lines": 49,
      "fragment": "t for whether or not a character is\n** part of an identifier is 0x46.\n*/\nconst unsigned char sqlite3CtypeMap[256] = {\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */\n  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */\n  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,  /* 20..27     !\"#$%&' */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */\n  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */\n  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */\n\n  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */\n  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */\n  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */\n  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,  /* 58..5f    XYZ[\\]^_ */\n  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */\n  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */\n  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */\n  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */\n\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 80..87    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 88..8f    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 90..97    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 98..9f    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a0..a7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a8..af    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b0..b7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b8..bf    ........ */\n\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c0..c7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c8..cf    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d0..d7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d8..df    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e0..e7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e8..ef    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* f0..f7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   /* f8..ff    ........ */\n};\n\n/* EVIDENCE-OF: R-02982-34736 In order to maintain full backwards\n** compatibility for legacy applications, the URI filename capability is\n** disabled by default.\n**\n** EVIDENCE-OF: R-38799-08373 URI filenames can be enabled or disabled\n** using the SQLITE_USE_URI=1 or SQLITE_USE_URI=0 compile-time options.\n**\n** EVIDENCE-OF: R-43642-56306 By default, URI handling is globally\n** disabled. The default value ",
      "tokens": 0,
      "firstFile": {
        "name": "src/global.c",
        "start": 118,
        "end": 166,
        "startLoc": {
          "line": 118,
          "column": 1,
          "position": 1444
        },
        "endLoc": {
          "line": 166,
          "column": 3,
          "position": 2329
        }
      },
      "secondFile": {
        "name": "ext/misc/normalize.c",
        "start": 179,
        "end": 241,
        "startLoc": {
          "line": 179,
          "column": 2,
          "position": 1529
        },
        "endLoc": {
          "line": 241,
          "column": 3,
          "position": 2423
        }
      }
    }
  ]
}
